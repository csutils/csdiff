Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/examples/Bye/Bye.cpp:11: constructor_uses_global_object: The constructor of global object "Wave" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Wave" might be created before "llvm::cl::TopLevelSubCommand" is available.
#    9|   using namespace llvm;
#   10|   
#   11|-> static cl::opt<bool> Wave("wave-goodbye", cl::init(false),
#   12|                             cl::desc("wave good bye"));
#   13|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/examples/IRTransforms/SimplifyCFG.cpp:49: constructor_uses_global_object: The constructor of global object "Version" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Version" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|   enum TutorialVersion { V1, V2, V3 };
#   48|   static cl::opt<TutorialVersion>
#   49|->     Version("tut-simplifycfg-version", cl::desc("Select tutorial version"),
#   50|               cl::Hidden, cl::ValueOptional, cl::init(V1),
#   51|               cl::values(clEnumValN(V1, "v1", "version 1"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:939: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:940: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeZero".
#  938|     static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {
#  939|       APFloat Val(Sem, uninitialized);
#  940|->     Val.makeZero(Negative);
#  941|       return Val;
#  942|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:948: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:949: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeInf".
#  947|     static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {
#  948|       APFloat Val(Sem, uninitialized);
#  949|->     Val.makeInf(Negative);
#  950|       return Val;
#  951|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:971: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:972: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeNaN".
#  970|                            const APInt *payload = nullptr) {
#  971|       APFloat Val(Sem, uninitialized);
#  972|->     Val.makeNaN(false, Negative, payload);
#  973|       return Val;
#  974|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:979: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:980: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeNaN".
#  978|                            const APInt *payload = nullptr) {
#  979|       APFloat Val(Sem, uninitialized);
#  980|->     Val.makeNaN(true, Negative, payload);
#  981|       return Val;
#  982|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:988: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:989: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeLargest".
#  987|     static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {
#  988|       APFloat Val(Sem, uninitialized);
#  989|->     Val.makeLargest(Negative);
#  990|       return Val;
#  991|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:998: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:999: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeSmallest".
#  997|     static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {
#  998|       APFloat Val(Sem, uninitialized);
#  999|->     Val.makeSmallest(Negative);
# 1000|       return Val;
# 1001|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:1009: var_decl: Declaring variable "Val".
llvm-17.0.6.src/include/llvm/ADT/APFloat.h:1010: uninit_use_in_call: Using uninitialized value "Val.U" when calling "makeSmallestNormalized".
# 1008|                                          bool Negative = false) {
# 1009|       APFloat Val(Sem, uninitialized);
# 1010|->     Val.makeSmallestNormalized(Negative);
# 1011|       return Val;
# 1012|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/BitVector.h:842: var_decl: Declaring variable "V".
llvm-17.0.6.src/include/llvm/ADT/BitVector.h:844: uninit_use: Using uninitialized value "V". Field "V.Bits.InlineElts" is uninitialized.
#  842|       BitVector V;
#  843|       V.invalid();
#  844|->     return V;
#  845|     }
#  846|     static unsigned getHashValue(const BitVector &V) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:945: uninit_in_ctor: Fields of "this" are uninitialized at the beginning of the constructor.
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:947: uninit_use_in_call: Using uninitialized value "this->NumEntries" when calling "swap".
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:947: uninit_use_in_call: Using uninitialized value "this->NumTombstones" when calling "swap".
#  945|     SmallDenseMap(SmallDenseMap &&other) : BaseT() {
#  946|       init(0);
#  947|->     swap(other);
#  948|     }
#  949|   

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1077: address_of: Taking address with "&TmpStorage" yields a singleton pointer.
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1077: assign: Assigning: "TmpBegin" = "reinterpret_cast<llvm::detail::DenseMapPair<int, unsigned int> *>(&TmpStorage)".
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1078: assign: Assigning: "TmpEnd" = "TmpBegin".
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1091: ptr_arith: Using "TmpEnd" as an array.  This might corrupt or misinterpret adjacent memory locations.
# 1089|             ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));
# 1090|             ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));
# 1091|->           ++TmpEnd;
# 1092|             P->getSecond().~ValueT();
# 1093|           }

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1077: address_of: Taking address with "&TmpStorage" yields a singleton pointer.
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1077: assign: Assigning: "TmpBegin" = "reinterpret_cast<llvm::detail::DenseMapPair<int, unsigned int> *>(&TmpStorage)".
llvm-17.0.6.src/include/llvm/ADT/DenseMap.h:1104: callee_ptr_arith: Passing "TmpBegin" to function "moveFromOldBuckets" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 1102|           new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));
# 1103|         }
# 1104|->       this->moveFromOldBuckets(TmpBegin, TmpEnd);
# 1105|         return;
# 1106|       }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1228: overrun-buffer-arg: Overrunning array "size" of 2 4-byte elements by passing it to a function which accesses it at element index 2 (byte offset 11) using argument "2U".
# 1226|       size[0] = rootSize;
# 1227|     else
# 1228|->     NewOffset = distribute(Nodes, rootSize, Leaf::Capacity,  nullptr, size,
# 1229|                              Position, true);
# 1230|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1679: assignment: Assigning: "i" = "NR.size() - 1U". The value of "i" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1681: overrun-call: Overrunning callee's array of size 16 by passing argument "i" (which evaluates to 63) in call to "stop".
# 1679|       unsigned i = NR.size() - 1;
# 1680|       Leaf &Node = NR.get<Leaf>();
# 1681|->     return Node.value(i) == Value && Traits::adjacent(Node.stop(i), Start);
# 1682|     }
# 1683|     return false;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1679: assignment: Assigning: "i" = "NR.size() - 1U". The value of "i" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1681: overrun-call: Overrunning callee's array of size 16 by passing argument "i" (which evaluates to 63) in call to "value".
# 1679|       unsigned i = NR.size() - 1;
# 1680|       Leaf &Node = NR.get<Leaf>();
# 1681|->     return Node.value(i) == Value && Traits::adjacent(Node.stop(i), Start);
# 1682|     }
# 1683|     return false;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1679: assignment: Assigning: "i" = "NR.size() - 1U". The value of "i" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1681: overrun-call: Overrunning callee's array of size 4 by passing argument "i" (which evaluates to 63) in call to "stop".
# 1679|       unsigned i = NR.size() - 1;
# 1680|       Leaf &Node = NR.get<Leaf>();
# 1681|->     return Node.value(i) == Value && Traits::adjacent(Node.stop(i), Start);
# 1682|     }
# 1683|     return false;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1679: assignment: Assigning: "i" = "NR.size() - 1U". The value of "i" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1681: overrun-call: Overrunning callee's array of size 4 by passing argument "i" (which evaluates to 63) in call to "value".
# 1679|       unsigned i = NR.size() - 1;
# 1680|       Leaf &Node = NR.get<Leaf>();
# 1681|->     return Node.value(i) == Value && Traits::adjacent(Node.stop(i), Start);
# 1682|     }
# 1683|     return false;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 10 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 10 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 11 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 11 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 16 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 16 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 21 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 21 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 4 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 4 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 8 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 8 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 9 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1871: overrun-call: Overrunning callee's array of size 9 by passing argument "SibOfs" (which evaluates to 63) in call to "value".
# 1869|         Leaf &SibLeaf = Sib.get<Leaf>();
# 1870|         unsigned SibOfs = Sib.size() - 1;
# 1871|->       if (SibLeaf.value(SibOfs) == y &&
# 1872|             Traits::adjacent(SibLeaf.stop(SibOfs), a)) {
# 1873|           // This insertion will coalesce with the last entry in SibLeaf. We can

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 10 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 11 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 16 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 21 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 4 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 8 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1883: overrun-call: Overrunning callee's array of size 9 by passing argument "SibOfs" (which evaluates to 63) in call to "stop".
# 1881|               (y != CurLeaf.value(0) || !Traits::adjacent(b, CurLeaf.start(0)))) {
# 1882|             // Easy, just extend SibLeaf and we're done.
# 1883|->           setNodeStop(P.height(), SibLeaf.stop(SibOfs) = b);
# 1884|             return;
# 1885|           } else {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 10 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 11 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 16 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 21 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 4 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 8 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1870: assignment: Assigning: "SibOfs" = "Sib.size() - 1U". The value of "SibOfs" is now between 0 and 63 (inclusive).
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:1888: overrun-call: Overrunning callee's array of size 9 by passing argument "SibOfs" (which evaluates to 63) in call to "start".
# 1886|             // We have both left and right coalescing. Erase the old SibLeaf entry
# 1887|             // and continue inserting the larger interval.
# 1888|->           a = SibLeaf.start(SibOfs);
# 1889|             treeErase(/* UpdateRoot= */false);
# 1890|           }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:2022: assignment: Assigning: "Nodes" = "0U".
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:2030: incr: Incrementing "Nodes". The value of "Nodes" is now 1.
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:2035: incr: Incrementing "Nodes". The value of "Nodes" is now 2.
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:2041: incr: Incrementing "Nodes". The value of "Nodes" is now 3.
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:2053: incr: Incrementing "Nodes". The value of "Nodes" is now 4.
llvm-17.0.6.src/include/llvm/ADT/IntervalMap.h:2058: overrun-buffer-arg: Overrunning array "NewSize" of 4 4-byte elements by passing it to a function which accesses it at element index 4 (byte offset 19) using argument "Nodes" (which evaluates to 4).
# 2056|     // Compute the new element distribution.
# 2057|     unsigned NewSize[4];
# 2058|->   IdxPair NewOffset = distribute(Nodes, Elements, NodeT::Capacity,
# 2059|                                    CurSize, NewSize, Offset, true);
# 2060|     adjustSiblingSizes(Node, Nodes, CurSize, NewSize);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/IntervalTree.h:619: var_decl: Declaring variable "IntervalSet".
llvm-17.0.6.src/include/llvm/ADT/IntervalTree.h:622: uninit_use: Using uninitialized value "IntervalSet". Field "IntervalSet.InlineElts" is uninitialized.
#  620|       for (find_iterator Iter = find(Point), E = find_end(); Iter != E; ++Iter)
#  621|         IntervalSet.push_back(const_cast<DataType *>(&(*Iter)));
#  622|->     return IntervalSet;
#  623|     }
#  624|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/STLExtras.h:585: move: "Range" is moved (indicated by "std::forward(Range)").
llvm-17.0.6.src/include/llvm/ADT/STLExtras.h:585: use_after_move: "Range" is used after it has been already moved.
#  583|     using FilterIteratorT =
#  584|         filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;
#  585|->   return make_range(
#  586|         FilterIteratorT(std::begin(std::forward<RangeT>(Range)),
#  587|                         std::end(std::forward<RangeT>(Range)), Pred),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/STLExtras.h:669: move: "Range" is moved (indicated by "std::forward(Range)").
llvm-17.0.6.src/include/llvm/ADT/STLExtras.h:669: use_after_move: "Range" is used after it has been already moved.
#  667|     using EarlyIncIteratorT =
#  668|         early_inc_iterator_impl<detail::IterOfRange<RangeT>>;
#  669|->   return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),
#  670|                       EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));
#  671|   }

Error: USE_AFTER_FREE (CWE-416):
llvm-17.0.6.src/include/llvm/ADT/SetVector.h:174: freed_arg: "insert" frees "X.P".
llvm-17.0.6.src/include/llvm/ADT/SetVector.h:176: deref_arg: Calling "push_back" dereferences freed pointer "X.P".
#  174|       bool result = set_.insert(X).second;
#  175|       if (result)
#  176|->       vector_.push_back(X);
#  177|       return result;
#  178|     }

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/include/llvm/ADT/SparseBitVector.h:366: tainted_data_return: Called function "this->Iter->find_next(this->BitNumber % 128U)", and a possible return value may be less than zero.
llvm-17.0.6.src/include/llvm/ADT/SparseBitVector.h:366: assign: Assigning: "NextSetBitNumber" = "this->Iter->find_next(this->BitNumber % 128U)".
llvm-17.0.6.src/include/llvm/ADT/SparseBitVector.h:385: overflow: The expression "NextSetBitNumber % 128U" might be negative, but is used in a context that treats it as unsigned.
llvm-17.0.6.src/include/llvm/ADT/SparseBitVector.h:385: overflow: The expression "NextSetBitNumber % 128U / BITWORD_SIZE" is deemed underflowed because at least one of its arguments has underflowed.
llvm-17.0.6.src/include/llvm/ADT/SparseBitVector.h:385: assign: Assigning: "this->WordNumber" = "NextSetBitNumber % 128U / BITWORD_SIZE".
llvm-17.0.6.src/include/llvm/ADT/SparseBitVector.h:386: overflow_sink: "this->WordNumber", which might have underflowed, is passed to "this->Iter->word(this->WordNumber)".
#  384|           } else {
#  385|             WordNumber = (NextSetBitNumber % ElementSize) / BITWORD_SIZE;
#  386|->           Bits = Iter->word(WordNumber);
#  387|             Bits >>= NextSetBitNumber % BITWORD_SIZE;
#  388|             BitNumber = Iter->index() * ElementSize;

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/StringMap.h:330: move: "Val" is moved (indicated by "std::forward(Val)").
llvm-17.0.6.src/include/llvm/ADT/StringMap.h:332: use_after_move: "Val" is used after it has been already moved.
#  330|       auto Ret = try_emplace(Key, std::forward<V>(Val));
#  331|       if (!Ret.second)
#  332|->       Ret.first->second = std::forward<V>(Val);
#  333|       return Ret;
#  334|     }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/ilist.h:138: move: "X" is moved (indicated by "std::move(static_cast<llvm::ilist_traits<llvm::IVStrideUse> &>(X))").
llvm-17.0.6.src/include/llvm/ADT/ilist.h:139: use_after_move: "X" is used after it has been already moved.
#  137|     iplist_impl(iplist_impl &&X)
#  138|         : TraitsT(std::move(static_cast<TraitsT &>(X))),
#  139|->         IntrusiveListT(std::move(static_cast<IntrusiveListT &>(X))) {}
#  140|     iplist_impl &operator=(iplist_impl &&X) {
#  141|       *static_cast<TraitsT *>(this) = std::move(static_cast<TraitsT &>(X));

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/iterator.h:338: move: "Range" is moved (indicated by "std::forward(Range)").
llvm-17.0.6.src/include/llvm/ADT/iterator.h:338: use_after_move: "Range" is used after it has been already moved.
#  336|   make_pointee_range(RangeT &&Range) {
#  337|     using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;
#  338|->   return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),
#  339|                       PointeeIteratorT(std::end(std::forward<RangeT>(Range))));
#  340|   }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/iterator.h:365: move: "Range" is moved (indicated by "std::forward(Range)").
llvm-17.0.6.src/include/llvm/ADT/iterator.h:365: use_after_move: "Range" is used after it has been already moved.
#  363|   make_pointer_range(RangeT &&Range) {
#  364|     using PointerIteratorT = pointer_iterator<WrappedIteratorT>;
#  365|->   return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),
#  366|                       PointerIteratorT(std::end(std::forward<RangeT>(Range))));
#  367|   }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ADT/iterator_range.h:56: move: "c" is moved (indicated by "std::forward(c)").
llvm-17.0.6.src/include/llvm/ADT/iterator_range.h:57: use_after_move: "c" is used after it has been already moved.
#   55|     iterator_range(Container &&c)
#   56|         : begin_iterator(adl_begin(std::forward<Container>(c))),
#   57|->         end_iterator(adl_end(std::forward<Container>(c))) {
#   58|     }
#   59|     iterator_range(IteratorT begin_iterator, IteratorT end_iterator)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Analysis/LoopNestAnalysis.h:123: var_decl: Declaring variable "Result".
llvm-17.0.6.src/include/llvm/Analysis/LoopNestAnalysis.h:131: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  129|           break;
#  130|       }
#  131|->     return Result;
#  132|     }
#  133|   

Error: USE_AFTER_FREE (CWE-416):
llvm-17.0.6.src/include/llvm/Analysis/MemorySSA.h:563: freed_arg: "growOperands" frees "this".
llvm-17.0.6.src/include/llvm/Analysis/MemorySSA.h:565: deref_arg: Calling "getNumOperands" dereferences freed pointer "this".
#  563|         growOperands(); // Get more space!
#  564|       // Initialize some new operands.
#  565|->     setNumHungOffUseOperands(getNumOperands() + 1);
#  566|       setIncomingValue(getNumOperands() - 1, V);
#  567|       setIncomingBlock(getNumOperands() - 1, BB);

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/Analysis/ScalarEvolution.h:1632: move: "CR" is moved (indicated by "std::move(CR)").
llvm-17.0.6.src/include/llvm/Analysis/ScalarEvolution.h:1634: use_after_move: "CR" is used after it has been already moved.
# 1632|       auto Pair = Cache.try_emplace(S, std::move(CR));
# 1633|       if (!Pair.second)
# 1634|->       Pair.first->second = std::move(CR);
# 1635|       return Pair.first->second;
# 1636|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Analysis/ValueLattice.h:204: var_decl: Declaring variable "Res".
llvm-17.0.6.src/include/llvm/Analysis/ValueLattice.h:209: uninit_use: Using uninitialized value "Res". Field "Res" is uninitialized.
#  207|       else
#  208|         Res.markConstant(C);
#  209|->     return Res;
#  210|     }
#  211|     static ValueLatticeElement getNot(Constant *C) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Analysis/ValueLattice.h:223: var_decl: Declaring variable "Res".
llvm-17.0.6.src/include/llvm/Analysis/ValueLattice.h:226: uninit_use: Using uninitialized value "Res". Field "Res" is uninitialized.
#  224|         if (MayIncludeUndef)
#  225|           Res.markUndef();
#  226|->       return Res;
#  227|       }
#  228|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Analysis/ValueLattice.h:235: var_decl: Declaring variable "Res".
llvm-17.0.6.src/include/llvm/Analysis/ValueLattice.h:237: uninit_use: Using uninitialized value "Res". Field "Res" is uninitialized.
#  235|       ValueLatticeElement Res;
#  236|       Res.markOverdefined();
#  237|->     return Res;
#  238|     }
#  239|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Analysis/VectorUtils.h:267: var_decl: Declaring variable "Ret".
llvm-17.0.6.src/include/llvm/Analysis/VectorUtils.h:274: uninit_use: Using uninitialized value "Ret". Field "Ret.InlineElts" is uninitialized.
#  272|       // Other non-VFABI variants should be retrieved here.
#  273|   
#  274|->     return Ret;
#  275|     }
#  276|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1199: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugAbbrev" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugAbbrev" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1197|   // TODO: Add Mach-O and COFF names.
# 1198|   // Official DWARF sections.
# 1199|-> HANDLE_DWARF_SECTION(DebugAbbrev, ".debug_abbrev", "debug-abbrev", BoolOption)
# 1200|   HANDLE_DWARF_SECTION(DebugAddr, ".debug_addr", "debug-addr", BoolOption)
# 1201|   HANDLE_DWARF_SECTION(DebugAranges, ".debug_aranges", "debug-aranges",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1200: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugAddr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugAddr" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1198|   // Official DWARF sections.
# 1199|   HANDLE_DWARF_SECTION(DebugAbbrev, ".debug_abbrev", "debug-abbrev", BoolOption)
# 1200|-> HANDLE_DWARF_SECTION(DebugAddr, ".debug_addr", "debug-addr", BoolOption)
# 1201|   HANDLE_DWARF_SECTION(DebugAranges, ".debug_aranges", "debug-aranges",
# 1202|                        BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1201: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugAranges" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugAranges" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1199|   HANDLE_DWARF_SECTION(DebugAbbrev, ".debug_abbrev", "debug-abbrev", BoolOption)
# 1200|   HANDLE_DWARF_SECTION(DebugAddr, ".debug_addr", "debug-addr", BoolOption)
# 1201|-> HANDLE_DWARF_SECTION(DebugAranges, ".debug_aranges", "debug-aranges",
# 1202|                        BoolOption)
# 1203|   HANDLE_DWARF_SECTION(DebugInfo, ".debug_info", "debug-info", OffsetOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1203: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugInfo" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugInfo" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1201|   HANDLE_DWARF_SECTION(DebugAranges, ".debug_aranges", "debug-aranges",
# 1202|                        BoolOption)
# 1203|-> HANDLE_DWARF_SECTION(DebugInfo, ".debug_info", "debug-info", OffsetOption)
# 1204|   HANDLE_DWARF_SECTION(DebugTypes, ".debug_types", "debug-types", OffsetOption)
# 1205|   HANDLE_DWARF_SECTION(DebugLine, ".debug_line", "debug-line", OffsetOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1204: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugTypes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugTypes" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1202|                        BoolOption)
# 1203|   HANDLE_DWARF_SECTION(DebugInfo, ".debug_info", "debug-info", OffsetOption)
# 1204|-> HANDLE_DWARF_SECTION(DebugTypes, ".debug_types", "debug-types", OffsetOption)
# 1205|   HANDLE_DWARF_SECTION(DebugLine, ".debug_line", "debug-line", OffsetOption)
# 1206|   HANDLE_DWARF_SECTION(DebugLineStr, ".debug_line_str", "debug-line-str",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1205: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugLine" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugLine" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1203|   HANDLE_DWARF_SECTION(DebugInfo, ".debug_info", "debug-info", OffsetOption)
# 1204|   HANDLE_DWARF_SECTION(DebugTypes, ".debug_types", "debug-types", OffsetOption)
# 1205|-> HANDLE_DWARF_SECTION(DebugLine, ".debug_line", "debug-line", OffsetOption)
# 1206|   HANDLE_DWARF_SECTION(DebugLineStr, ".debug_line_str", "debug-line-str",
# 1207|                        BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1206: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugLineStr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugLineStr" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1204|   HANDLE_DWARF_SECTION(DebugTypes, ".debug_types", "debug-types", OffsetOption)
# 1205|   HANDLE_DWARF_SECTION(DebugLine, ".debug_line", "debug-line", OffsetOption)
# 1206|-> HANDLE_DWARF_SECTION(DebugLineStr, ".debug_line_str", "debug-line-str",
# 1207|                        BoolOption)
# 1208|   HANDLE_DWARF_SECTION(DebugLoc, ".debug_loc", "debug-loc", OffsetOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1208: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugLoc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugLoc" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1206|   HANDLE_DWARF_SECTION(DebugLineStr, ".debug_line_str", "debug-line-str",
# 1207|                        BoolOption)
# 1208|-> HANDLE_DWARF_SECTION(DebugLoc, ".debug_loc", "debug-loc", OffsetOption)
# 1209|   HANDLE_DWARF_SECTION(DebugLoclists, ".debug_loclists", "debug-loclists",
# 1210|                        OffsetOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1209: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugLoclists" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugLoclists" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1207|                        BoolOption)
# 1208|   HANDLE_DWARF_SECTION(DebugLoc, ".debug_loc", "debug-loc", OffsetOption)
# 1209|-> HANDLE_DWARF_SECTION(DebugLoclists, ".debug_loclists", "debug-loclists",
# 1210|                        OffsetOption)
# 1211|   HANDLE_DWARF_SECTION(DebugFrame, ".debug_frame", "debug-frame", OffsetOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1211: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugFrame" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugFrame" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1209|   HANDLE_DWARF_SECTION(DebugLoclists, ".debug_loclists", "debug-loclists",
# 1210|                        OffsetOption)
# 1211|-> HANDLE_DWARF_SECTION(DebugFrame, ".debug_frame", "debug-frame", OffsetOption)
# 1212|   HANDLE_DWARF_SECTION(DebugMacro, ".debug_macro", "debug-macro", BoolOption)
# 1213|   HANDLE_DWARF_SECTION(DebugNames, ".debug_names", "debug-names", BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1212: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugMacro" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugMacro" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1210|                        OffsetOption)
# 1211|   HANDLE_DWARF_SECTION(DebugFrame, ".debug_frame", "debug-frame", OffsetOption)
# 1212|-> HANDLE_DWARF_SECTION(DebugMacro, ".debug_macro", "debug-macro", BoolOption)
# 1213|   HANDLE_DWARF_SECTION(DebugNames, ".debug_names", "debug-names", BoolOption)
# 1214|   HANDLE_DWARF_SECTION(DebugPubnames, ".debug_pubnames", "debug-pubnames",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1213: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugNames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugNames" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1211|   HANDLE_DWARF_SECTION(DebugFrame, ".debug_frame", "debug-frame", OffsetOption)
# 1212|   HANDLE_DWARF_SECTION(DebugMacro, ".debug_macro", "debug-macro", BoolOption)
# 1213|-> HANDLE_DWARF_SECTION(DebugNames, ".debug_names", "debug-names", BoolOption)
# 1214|   HANDLE_DWARF_SECTION(DebugPubnames, ".debug_pubnames", "debug-pubnames",
# 1215|                        BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1214: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugPubnames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugPubnames" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1212|   HANDLE_DWARF_SECTION(DebugMacro, ".debug_macro", "debug-macro", BoolOption)
# 1213|   HANDLE_DWARF_SECTION(DebugNames, ".debug_names", "debug-names", BoolOption)
# 1214|-> HANDLE_DWARF_SECTION(DebugPubnames, ".debug_pubnames", "debug-pubnames",
# 1215|                        BoolOption)
# 1216|   HANDLE_DWARF_SECTION(DebugPubtypes, ".debug_pubtypes", "debug-pubtypes",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1216: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugPubtypes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugPubtypes" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1214|   HANDLE_DWARF_SECTION(DebugPubnames, ".debug_pubnames", "debug-pubnames",
# 1215|                        BoolOption)
# 1216|-> HANDLE_DWARF_SECTION(DebugPubtypes, ".debug_pubtypes", "debug-pubtypes",
# 1217|                        BoolOption)
# 1218|   HANDLE_DWARF_SECTION(DebugGnuPubnames, ".debug_gnu_pubnames",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1218: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugGnuPubnames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugGnuPubnames" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1216|   HANDLE_DWARF_SECTION(DebugPubtypes, ".debug_pubtypes", "debug-pubtypes",
# 1217|                        BoolOption)
# 1218|-> HANDLE_DWARF_SECTION(DebugGnuPubnames, ".debug_gnu_pubnames",
# 1219|                        "debug-gnu-pubnames", BoolOption)
# 1220|   HANDLE_DWARF_SECTION(DebugGnuPubtypes, ".debug_gnu_pubtypes",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1220: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugGnuPubtypes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugGnuPubtypes" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1218|   HANDLE_DWARF_SECTION(DebugGnuPubnames, ".debug_gnu_pubnames",
# 1219|                        "debug-gnu-pubnames", BoolOption)
# 1220|-> HANDLE_DWARF_SECTION(DebugGnuPubtypes, ".debug_gnu_pubtypes",
# 1221|                        "debug-gnu-pubtypes", BoolOption)
# 1222|   HANDLE_DWARF_SECTION(DebugRanges, ".debug_ranges", "debug-ranges", BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1222: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugRanges" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugRanges" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1220|   HANDLE_DWARF_SECTION(DebugGnuPubtypes, ".debug_gnu_pubtypes",
# 1221|                        "debug-gnu-pubtypes", BoolOption)
# 1222|-> HANDLE_DWARF_SECTION(DebugRanges, ".debug_ranges", "debug-ranges", BoolOption)
# 1223|   HANDLE_DWARF_SECTION(DebugRnglists, ".debug_rnglists", "debug-rnglists",
# 1224|                        BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1223: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugRnglists" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugRnglists" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1221|                        "debug-gnu-pubtypes", BoolOption)
# 1222|   HANDLE_DWARF_SECTION(DebugRanges, ".debug_ranges", "debug-ranges", BoolOption)
# 1223|-> HANDLE_DWARF_SECTION(DebugRnglists, ".debug_rnglists", "debug-rnglists",
# 1224|                        BoolOption)
# 1225|   HANDLE_DWARF_SECTION(DebugStr, ".debug_str", "debug-str", BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1225: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugStr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugStr" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1223|   HANDLE_DWARF_SECTION(DebugRnglists, ".debug_rnglists", "debug-rnglists",
# 1224|                        BoolOption)
# 1225|-> HANDLE_DWARF_SECTION(DebugStr, ".debug_str", "debug-str", BoolOption)
# 1226|   HANDLE_DWARF_SECTION(DebugStrOffsets, ".debug_str_offsets", "debug-str-offsets",
# 1227|                        BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1226: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugStrOffsets" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugStrOffsets" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1224|                        BoolOption)
# 1225|   HANDLE_DWARF_SECTION(DebugStr, ".debug_str", "debug-str", BoolOption)
# 1226|-> HANDLE_DWARF_SECTION(DebugStrOffsets, ".debug_str_offsets", "debug-str-offsets",
# 1227|                        BoolOption)
# 1228|   HANDLE_DWARF_SECTION(DebugCUIndex, ".debug_cu_index", "debug-cu-index",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1228: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugCUIndex" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugCUIndex" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1226|   HANDLE_DWARF_SECTION(DebugStrOffsets, ".debug_str_offsets", "debug-str-offsets",
# 1227|                        BoolOption)
# 1228|-> HANDLE_DWARF_SECTION(DebugCUIndex, ".debug_cu_index", "debug-cu-index",
# 1229|                        BoolOption)
# 1230|   HANDLE_DWARF_SECTION(DebugTUIndex, ".debug_tu_index", "debug-tu-index",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1230: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpDebugTUIndex" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpDebugTUIndex" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1228|   HANDLE_DWARF_SECTION(DebugCUIndex, ".debug_cu_index", "debug-cu-index",
# 1229|                        BoolOption)
# 1230|-> HANDLE_DWARF_SECTION(DebugTUIndex, ".debug_tu_index", "debug-tu-index",
# 1231|                        BoolOption)
# 1232|   // Vendor extensions.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1233: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpAppleNames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpAppleNames" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1231|                        BoolOption)
# 1232|   // Vendor extensions.
# 1233|-> HANDLE_DWARF_SECTION(AppleNames, ".apple_names", "apple-names", BoolOption)
# 1234|   HANDLE_DWARF_SECTION(AppleTypes, ".apple_types", "apple-types", BoolOption)
# 1235|   HANDLE_DWARF_SECTION(AppleNamespaces, ".apple_namespaces", "apple-namespaces",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1234: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpAppleTypes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpAppleTypes" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1232|   // Vendor extensions.
# 1233|   HANDLE_DWARF_SECTION(AppleNames, ".apple_names", "apple-names", BoolOption)
# 1234|-> HANDLE_DWARF_SECTION(AppleTypes, ".apple_types", "apple-types", BoolOption)
# 1235|   HANDLE_DWARF_SECTION(AppleNamespaces, ".apple_namespaces", "apple-namespaces",
# 1236|                        BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1235: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpAppleNamespaces" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpAppleNamespaces" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1233|   HANDLE_DWARF_SECTION(AppleNames, ".apple_names", "apple-names", BoolOption)
# 1234|   HANDLE_DWARF_SECTION(AppleTypes, ".apple_types", "apple-types", BoolOption)
# 1235|-> HANDLE_DWARF_SECTION(AppleNamespaces, ".apple_namespaces", "apple-namespaces",
# 1236|                        BoolOption)
# 1237|   HANDLE_DWARF_SECTION(AppleObjC, ".apple_objc", "apple-objc", BoolOption)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1237: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpAppleObjC" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpAppleObjC" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1235|   HANDLE_DWARF_SECTION(AppleNamespaces, ".apple_namespaces", "apple-namespaces",
# 1236|                        BoolOption)
# 1237|-> HANDLE_DWARF_SECTION(AppleObjC, ".apple_objc", "apple-objc", BoolOption)
# 1238|   HANDLE_DWARF_SECTION(GdbIndex, ".gdb_index", "gdb-index", BoolOption)
# 1239|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/BinaryFormat/Dwarf.def:1238: constructor_uses_global_object: The constructor of global object "<unnamed>::DumpGdbIndex" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DumpGdbIndex" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1236|                        BoolOption)
# 1237|   HANDLE_DWARF_SECTION(AppleObjC, ".apple_objc", "apple-objc", BoolOption)
# 1238|-> HANDLE_DWARF_SECTION(GdbIndex, ".gdb_index", "gdb-index", BoolOption)
# 1239|   
# 1240|   HANDLE_DW_IDX(0x01, compile_unit)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/BinaryFormat/MsgPackDocument.h:309: var_decl: Declaring variable "N".
llvm-17.0.6.src/include/llvm/BinaryFormat/MsgPackDocument.h:310: uninit_use: Using uninitialized value "N". Field "N" is uninitialized.
#  308|     DocNode getEmptyNode() {
#  309|       auto N = DocNode(&KindAndDocs[size_t(Type::Empty)]);
#  310|->     return N;
#  311|     }
#  312|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/BinaryFormat/MsgPackDocument.h:315: var_decl: Declaring variable "N".
llvm-17.0.6.src/include/llvm/BinaryFormat/MsgPackDocument.h:316: uninit_use: Using uninitialized value "N". Field "N" is uninitialized.
#  314|     DocNode getNode() {
#  315|       auto N = DocNode(&KindAndDocs[size_t(Type::Nil)]);
#  316|->     return N;
#  317|     }
#  318|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/BinaryFormat/WasmTraits.h:24: var_decl: Declaring variable "Sig".
llvm-17.0.6.src/include/llvm/BinaryFormat/WasmTraits.h:26: uninit_use: Using uninitialized value "Sig". Field "Sig.Returns.InlineElts" is uninitialized.
#   24|       wasm::WasmSignature Sig;
#   25|       Sig.State = wasm::WasmSignature::Empty;
#   26|->     return Sig;
#   27|     }
#   28|     static wasm::WasmSignature getTombstoneKey() {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/BinaryFormat/WasmTraits.h:29: var_decl: Declaring variable "Sig".
llvm-17.0.6.src/include/llvm/BinaryFormat/WasmTraits.h:31: uninit_use: Using uninitialized value "Sig". Field "Sig.Returns.InlineElts" is uninitialized.
#   29|       wasm::WasmSignature Sig;
#   30|       Sig.State = wasm::WasmSignature::Tombstone;
#   31|->     return Sig;
#   32|     }
#   33|     static unsigned getHashValue(const wasm::WasmSignature &Sig) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Bitstream/BitstreamReader.h:337: var_decl: Declaring variable "E" without initializer.
llvm-17.0.6.src/include/llvm/Bitstream/BitstreamReader.h:337: uninit_use: Using uninitialized value "E". Field "E.ID" is uninitialized.
#  335|   
#  336|     static BitstreamEntry getError() {
#  337|->     BitstreamEntry E; E.Kind = Error; return E;
#  338|     }
#  339|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Bitstream/BitstreamReader.h:341: var_decl: Declaring variable "E" without initializer.
llvm-17.0.6.src/include/llvm/Bitstream/BitstreamReader.h:341: uninit_use: Using uninitialized value "E". Field "E.ID" is uninitialized.
#  339|   
#  340|     static BitstreamEntry getEndBlock() {
#  341|->     BitstreamEntry E; E.Kind = EndBlock; return E;
#  342|     }
#  343|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h:445: overrun-call: Overrunning callee's array of size 8 by passing argument "MMO->getMergedOrdering()" (which evaluates to 15) in call to "isAtLeastOrStrongerThan".
#  443|   
#  444|         for (const auto &MMO : State.MIs[InsnID]->memoperands())
#  445|->         if (!isAtLeastOrStrongerThan(MMO->getMergedOrdering(), Ordering))
#  446|             if (handleReject() == RejectAndGiveUp)
#  447|               return false;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:35: alloc_fn: Storage is returned from allocation function "createFastRegisterAllocator".
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:35: leaked_storage: Failing to save or free storage allocated by "llvm::createFastRegisterAllocator()" leaks it.
#   33|           return;
#   34|   
#   35|->       (void) llvm::createFastRegisterAllocator();
#   36|         (void) llvm::createBasicRegisterAllocator();
#   37|         (void) llvm::createGreedyRegisterAllocator();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:36: alloc_fn: Storage is returned from allocation function "createBasicRegisterAllocator".
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:36: leaked_storage: Failing to save or free storage allocated by "llvm::createBasicRegisterAllocator()" leaks it.
#   34|   
#   35|         (void) llvm::createFastRegisterAllocator();
#   36|->       (void) llvm::createBasicRegisterAllocator();
#   37|         (void) llvm::createGreedyRegisterAllocator();
#   38|         (void) llvm::createDefaultPBQPRegisterAllocator();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:37: alloc_fn: Storage is returned from allocation function "createGreedyRegisterAllocator".
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:37: leaked_storage: Failing to save or free storage allocated by "llvm::createGreedyRegisterAllocator()" leaks it.
#   35|         (void) llvm::createFastRegisterAllocator();
#   36|         (void) llvm::createBasicRegisterAllocator();
#   37|->       (void) llvm::createGreedyRegisterAllocator();
#   38|         (void) llvm::createDefaultPBQPRegisterAllocator();
#   39|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:38: alloc_fn: Storage is returned from allocation function "createDefaultPBQPRegisterAllocator".
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:38: leaked_storage: Failing to save or free storage allocated by "llvm::createDefaultPBQPRegisterAllocator()" leaks it.
#   36|         (void) llvm::createBasicRegisterAllocator();
#   37|         (void) llvm::createGreedyRegisterAllocator();
#   38|->       (void) llvm::createDefaultPBQPRegisterAllocator();
#   39|   
#   40|         (void) llvm::createBURRListDAGScheduler(nullptr,

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:46: alloc_fn: Storage is returned from allocation function "createFastDAGScheduler".
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:46: leaked_storage: Failing to save or free storage allocated by "llvm::createFastDAGScheduler(NULL, Default)" leaks it.
#   44|         (void) llvm::createHybridListDAGScheduler(nullptr,
#   45|                                                   llvm::CodeGenOpt::Default);
#   46|->       (void) llvm::createFastDAGScheduler(nullptr, llvm::CodeGenOpt::Default);
#   47|         (void) llvm::createDefaultScheduler(nullptr, llvm::CodeGenOpt::Default);
#   48|         (void) llvm::createVLIWDAGScheduler(nullptr, llvm::CodeGenOpt::Default);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:47: alloc_fn: Storage is returned from allocation function "createDefaultScheduler".
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:47: leaked_storage: Failing to save or free storage allocated by "llvm::createDefaultScheduler(NULL, Default)" leaks it.
#   45|                                                   llvm::CodeGenOpt::Default);
#   46|         (void) llvm::createFastDAGScheduler(nullptr, llvm::CodeGenOpt::Default);
#   47|->       (void) llvm::createDefaultScheduler(nullptr, llvm::CodeGenOpt::Default);
#   48|         (void) llvm::createVLIWDAGScheduler(nullptr, llvm::CodeGenOpt::Default);
#   49|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/CodeGen/LinkAllCodegenComponents.h:51: constructor_uses_global_object: The constructor of global object "<unnamed>::ForceCodegenLinking" itself makes use of global object "DisableSchedCycles" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForceCodegenLinking" might be created before "DisableSchedCycles" is available.
#   49|   
#   50|       }
#   51|->   } ForceCodegenLinking; // Force link by creating a global definition.
#   52|   }
#   53|   

Error: VIRTUAL_DTOR (CWE-772):
llvm-17.0.6.src/include/llvm/CodeGen/LiveInterval.h:157: no_virtual_dtor: Class "llvm::LiveRange" does not have a virtual destructor.
llvm-17.0.6.src/include/llvm/CodeGen/LiveInterval.h:724: dtor_in_derived: Class "llvm::LiveInterval" has a destructor and a pointer to it is upcast to class "llvm::LiveRange" which doesn't have a virtual destructor.
/usr/include/c++/14/bits/stl_pair.h:882: upcast: Example 1: Casting from a pointer to "llvm::LiveInterval" to a pointer to "llvm::LiveRange" in "std::forward(__x)".
llvm-17.0.6.src/include/llvm/CodeGen/LiveIntervals.h:411: delete: Example 1: Deletion of type "llvm::LiveRange".
llvm-17.0.6.src/lib/CodeGen/LiveIntervals.cpp:184: alloc: Example 1: Allocated an object of type "llvm::LiveInterval".
#  155|     /// where a new value is defined or different values reach a CFG join a new
#  156|     /// segment with a new value number is used.
#  157|->   class LiveRange {
#  158|     public:
#  159|       /// This represents a simple continuous liveness interval for a value.

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/include/llvm/CodeGen/MachineInstr.h:167: new_object: Calling single-object form of 'new': "new (Allocator->Allocate(llvm::TrailingObjects<llvm::MachineInstr::ExtraInfo, llvm::MachineMemOperand *, llvm::MCSymbol *, llvm::MDNode *, unsigned int>::totalSizeToAlloc(MMOs.size(), HasPreInstrSymbol + HasPostInstrSymbol, HasHeapAllocMarker + HasPCSections, HasCFIType), 8UL)) llvm::MachineInstr::ExtraInfo(MMOs.size(), HasPreInstrSymbol, HasPostInstrSymbol, HasHeapAllocMarker, HasPCSections, HasCFIType)".
llvm-17.0.6.src/include/llvm/CodeGen/MachineInstr.h:167: assign: Assigning: "Result" = "new (Allocator->Allocate(llvm::TrailingObjects<llvm::MachineInstr::ExtraInfo, llvm::MachineMemOperand *, llvm::MCSymbol *, llvm::MDNode *, unsigned int>::totalSizeToAlloc(MMOs.size(), HasPreInstrSymbol + HasPostInstrSymbol, HasHeapAllocMarker + HasPCSections, HasCFIType), 8UL)) llvm::MachineInstr::ExtraInfo(MMOs.size(), HasPreInstrSymbol, HasPostInstrSymbol, HasHeapAllocMarker, HasPCSections, HasCFIType)".
llvm-17.0.6.src/include/llvm/CodeGen/MachineInstr.h:176: callee_ptr_arith: Passing "Result" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  174|   
#  175|         // Copy the actual data into the trailing objects.
#  176|->       std::copy(MMOs.begin(), MMOs.end(),
#  177|                   Result->getTrailingObjects<MachineMemOperand *>());
#  178|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineInstr.h:573: var_decl: Declaring variable "UsedRegs".
llvm-17.0.6.src/include/llvm/CodeGen/MachineInstr.h:577: uninit_use: Using uninitialized value "UsedRegs". Field "UsedRegs.Vector.InlineElts" is uninitialized.
#  575|         if (MO.isReg() && MO.getReg())
#  576|           UsedRegs.insert(MO.getReg());
#  577|->     return UsedRegs;
#  578|     }
#  579|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/CodeGen/MachineMemOperand.h:285: overrun-call: Overrunning callee's array of size 8 by passing argument "this->getSuccessOrdering()" (which evaluates to 15) in call to "getMergedAtomicOrdering".
#  283|     /// other than cmpxchg, this is equivalent to getSuccessOrdering().)
#  284|     AtomicOrdering getMergedOrdering() const {
#  285|->     return getMergedAtomicOrdering(getSuccessOrdering(), getFailureOrdering());
#  286|     }
#  287|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:816: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:818: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  816|       MachineOperand Op(MachineOperand::MO_Immediate);
#  817|       Op.setImm(Val);
#  818|->     return Op;
#  819|     }
#  820|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:822: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:824: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  822|       MachineOperand Op(MachineOperand::MO_CImmediate);
#  823|       Op.Contents.CI = CI;
#  824|->     return Op;
#  825|     }
#  826|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:828: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:830: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  828|       MachineOperand Op(MachineOperand::MO_FPImmediate);
#  829|       Op.Contents.CFP = CFP;
#  830|->     return Op;
#  831|     }
#  832|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:860: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:863: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  861|       Op.setMBB(MBB);
#  862|       Op.setTargetFlags(TargetFlags);
#  863|->     return Op;
#  864|     }
#  865|     static MachineOperand CreateFI(int Idx) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:866: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:868: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  866|       MachineOperand Op(MachineOperand::MO_FrameIndex);
#  867|       Op.setIndex(Idx);
#  868|->     return Op;
#  869|     }
#  870|     static MachineOperand CreateCPI(unsigned Idx, int Offset,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:872: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:876: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  874|       Op.setOffset(Offset);
#  875|       Op.setTargetFlags(TargetFlags);
#  876|->     return Op;
#  877|     }
#  878|     static MachineOperand CreateTargetIndex(unsigned Idx, int64_t Offset,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:880: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:884: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  882|       Op.setOffset(Offset);
#  883|       Op.setTargetFlags(TargetFlags);
#  884|->     return Op;
#  885|     }
#  886|     static MachineOperand CreateJTI(unsigned Idx, unsigned TargetFlags = 0) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:887: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:890: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  888|       Op.setIndex(Idx);
#  889|       Op.setTargetFlags(TargetFlags);
#  890|->     return Op;
#  891|     }
#  892|     static MachineOperand CreateGA(const GlobalValue *GV, int64_t Offset,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:894: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:898: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  896|       Op.setOffset(Offset);
#  897|       Op.setTargetFlags(TargetFlags);
#  898|->     return Op;
#  899|     }
#  900|     static MachineOperand CreateES(const char *SymName,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:902: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:906: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  904|       Op.setOffset(0); // Offset is always 0.
#  905|       Op.setTargetFlags(TargetFlags);
#  906|->     return Op;
#  907|     }
#  908|     static MachineOperand CreateBA(const BlockAddress *BA, int64_t Offset,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:910: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:914: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  912|       Op.setOffset(Offset);
#  913|       Op.setTargetFlags(TargetFlags);
#  914|->     return Op;
#  915|     }
#  916|     /// CreateRegMask - Creates a register mask operand referencing Mask.  The

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:930: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:932: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  930|       MachineOperand Op(MachineOperand::MO_RegisterMask);
#  931|       Op.Contents.RegMask = Mask;
#  932|->     return Op;
#  933|     }
#  934|     static MachineOperand CreateRegLiveOut(const uint32_t *Mask) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:936: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:938: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  936|       MachineOperand Op(MachineOperand::MO_RegisterLiveOut);
#  937|       Op.Contents.RegMask = Mask;
#  938|->     return Op;
#  939|     }
#  940|     static MachineOperand CreateMetadata(const MDNode *Meta) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:941: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:943: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  941|       MachineOperand Op(MachineOperand::MO_Metadata);
#  942|       Op.Contents.MD = Meta;
#  943|->     return Op;
#  944|     }
#  945|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:948: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:952: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  950|       Op.setOffset(0);
#  951|       Op.setTargetFlags(TargetFlags);
#  952|->     return Op;
#  953|     }
#  954|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:956: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:959: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  957|       Op.Contents.InstrRef.InstrIdx = InstrIdx;
#  958|       Op.Contents.InstrRef.OpIdx = OpIdx;
#  959|->     return Op;
#  960|     }
#  961|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:963: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:965: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  963|       MachineOperand Op(MachineOperand::MO_CFIIndex);
#  964|       Op.Contents.CFIIndex = CFIIndex;
#  965|->     return Op;
#  966|     }
#  967|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:969: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:971: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  969|       MachineOperand Op(MachineOperand::MO_IntrinsicID);
#  970|       Op.Contents.IntrinsicID = ID;
#  971|->     return Op;
#  972|     }
#  973|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:975: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:977: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  975|       MachineOperand Op(MachineOperand::MO_Predicate);
#  976|       Op.Contents.Pred = Pred;
#  977|->     return Op;
#  978|     }
#  979|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:981: var_decl: Declaring variable "Op".
llvm-17.0.6.src/include/llvm/CodeGen/MachineOperand.h:983: uninit_use: Using uninitialized value "Op". Field "Op.TiedTo" is uninitialized.
#  981|       MachineOperand Op(MachineOperand::MO_ShuffleMask);
#  982|       Op.Contents.ShuffleMask = Mask;
#  983|->     return Op;
#  984|     }
#  985|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/RDFGraph.h:947: var_decl: Declaring variable "MM".
llvm-17.0.6.src/include/llvm/CodeGen/RDFGraph.h:950: uninit_use: Using uninitialized value "MM". Field "MM.InlineElts" is uninitialized.
#  948|     auto M = getFirstMember(G);
#  949|     if (M.Id == 0)
#  950|->     return MM;
#  951|   
#  952|     while (M.Addr != this) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/CodeGen/RDFGraph.h:947: var_decl: Declaring variable "MM".
llvm-17.0.6.src/include/llvm/CodeGen/RDFGraph.h:957: uninit_use: Using uninitialized value "MM". Field "MM.InlineElts" is uninitialized.
#  955|       M = G.addr<NodeBase *>(M.Addr->getNext());
#  956|     }
#  957|->   return MM;
#  958|   }
#  959|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/DebugInfo/CodeView/CodeViewRecordIO.h:189: var_decl: Declaring variable "Field".
llvm-17.0.6.src/include/llvm/DebugInfo/CodeView/CodeViewRecordIO.h:194: uninit_use_in_call: Using uninitialized value "Field". Field "Field.Kind" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  192|           if (auto EC = Mapper(*this, Field))
#  193|             return EC;
#  194|->         Items.push_back(Field);
#  195|         }
#  196|       }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/include/llvm/DebugInfo/LogicalView/Core/LVOptions.h:504: overrun-local: Overrunning array of 16 bytes at byte offset 23 by dereferencing pointer "Iter->second". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  502|         typename U::const_iterator Iter = Dispatch.find(Entry);
#  503|         if (Iter != Dispatch.end())
#  504|->         Request.push_back(Iter->second);
#  505|       }
#  506|     }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/DebugInfo/LogicalView/Core/LVStringPool.h:63: move: "Value" is moved (indicated by "std::move(Value)").
llvm-17.0.6.src/include/llvm/DebugInfo/LogicalView/Core/LVStringPool.h:66: use_after_move: "Value" is used after it has been already moved.
#   64|       StringTable.insert(Entry);
#   65|       Entries.push_back(Entry);
#   66|->     return Value;
#   67|     }
#   68|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:507: move: "RetVal" is moved (indicated by "std::move(RetVal)").
llvm-17.0.6.src/include/llvm/ExecutionEngine/Orc/Shared/WrapperFunctionUtils.h:509: use_after_move: "RetVal" is used after it has been already moved.
#  507|           SDR(std::move(Err), std::move(RetVal));
#  508|   
#  509|->       SDR(Error::success(), std::move(RetVal));
#  510|       };
#  511|   

Error: USE_AFTER_FREE (CWE-416):
llvm-17.0.6.src/include/llvm/IR/Instructions.h:2870: freed_arg: "growOperands" frees "this".
llvm-17.0.6.src/include/llvm/IR/Instructions.h:2872: deref_arg: Calling "getNumOperands" dereferences freed pointer "this".
# 2870|         growOperands();  // Get more space!
# 2871|       // Initialize some new operands.
# 2872|->     setNumHungOffUseOperands(getNumOperands() + 1);
# 2873|       setIncomingValue(getNumOperands() - 1, V);
# 2874|       setIncomingBlock(getNumOperands() - 1, BB);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/IR/Instructions.h:4198: var_decl: Declaring variable "IndirectDests".
llvm-17.0.6.src/include/llvm/IR/Instructions.h:4201: uninit_use: Using uninitialized value "IndirectDests". Field "IndirectDests.InlineElts" is uninitialized.
# 4199|       for (unsigned i = 0, e = getNumIndirectDests(); i < e; ++i)
# 4200|         IndirectDests.push_back(getIndirectDest(i));
# 4201|->     return IndirectDests;
# 4202|     }
# 4203|     void setDefaultDest(BasicBlock *B) {

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllIR.h:49: alloc_fn: Storage is returned from allocation function "createVerifierPass".
llvm-17.0.6.src/include/llvm/LinkAllIR.h:49: leaked_storage: Failing to save or free storage allocated by "llvm::createVerifierPass(true)" leaks it.
#   47|         (void)new llvm::Module("", Context);
#   48|         (void)new llvm::UnreachableInst(Context);
#   49|->       (void)    llvm::createVerifierPass();
#   50|       }
#   51|     } ForceVMCoreLinking;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllIR.h:51: constructor_uses_global_object: The constructor of global object "<unnamed>::ForceVMCoreLinking" itself makes use of global object "DisableI2pP2iOpt" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForceVMCoreLinking" might be created before "DisableI2pP2iOpt" is available.
#   49|         (void)    llvm::createVerifierPass();
#   50|       }
#   51|->   } ForceVMCoreLinking;
#   52|   }
#   53|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllIR.h:51: constructor_uses_global_object: The constructor of global object "<unnamed>::ForceVMCoreLinking" itself makes use of global object "ScalableErrorAsWarning" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForceVMCoreLinking" might be created before "ScalableErrorAsWarning" is available.
#   49|         (void)    llvm::createVerifierPass();
#   50|       }
#   51|->   } ForceVMCoreLinking;
#   52|   }
#   53|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:71: alloc_fn: Storage is returned from allocation function "createAAEvalPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:71: leaked_storage: Failing to save or free storage allocated by "llvm::createAAEvalPass()" leaks it.
#   69|           return;
#   70|   
#   71|->       (void) llvm::createAAEvalPass();
#   72|         (void) llvm::createBasicAAWrapperPass();
#   73|         (void) llvm::createSCEVAAWrapperPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:72: alloc_fn: Storage is returned from allocation function "createBasicAAWrapperPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:72: leaked_storage: Failing to save or free storage allocated by "llvm::createBasicAAWrapperPass()" leaks it.
#   70|   
#   71|         (void) llvm::createAAEvalPass();
#   72|->       (void) llvm::createBasicAAWrapperPass();
#   73|         (void) llvm::createSCEVAAWrapperPass();
#   74|         (void) llvm::createTypeBasedAAWrapperPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:73: alloc_fn: Storage is returned from allocation function "createSCEVAAWrapperPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:73: leaked_storage: Failing to save or free storage allocated by "llvm::createSCEVAAWrapperPass()" leaks it.
#   71|         (void) llvm::createAAEvalPass();
#   72|         (void) llvm::createBasicAAWrapperPass();
#   73|->       (void) llvm::createSCEVAAWrapperPass();
#   74|         (void) llvm::createTypeBasedAAWrapperPass();
#   75|         (void) llvm::createScopedNoAliasAAWrapperPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:74: alloc_fn: Storage is returned from allocation function "createTypeBasedAAWrapperPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:74: leaked_storage: Failing to save or free storage allocated by "llvm::createTypeBasedAAWrapperPass()" leaks it.
#   72|         (void) llvm::createBasicAAWrapperPass();
#   73|         (void) llvm::createSCEVAAWrapperPass();
#   74|->       (void) llvm::createTypeBasedAAWrapperPass();
#   75|         (void) llvm::createScopedNoAliasAAWrapperPass();
#   76|         (void) llvm::createBreakCriticalEdgesPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:75: alloc_fn: Storage is returned from allocation function "createScopedNoAliasAAWrapperPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:75: leaked_storage: Failing to save or free storage allocated by "llvm::createScopedNoAliasAAWrapperPass()" leaks it.
#   73|         (void) llvm::createSCEVAAWrapperPass();
#   74|         (void) llvm::createTypeBasedAAWrapperPass();
#   75|->       (void) llvm::createScopedNoAliasAAWrapperPass();
#   76|         (void) llvm::createBreakCriticalEdgesPass();
#   77|         (void) llvm::createCallGraphDOTPrinterPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:76: alloc_fn: Storage is returned from allocation function "createBreakCriticalEdgesPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:76: leaked_storage: Failing to save or free storage allocated by "llvm::createBreakCriticalEdgesPass()" leaks it.
#   74|         (void) llvm::createTypeBasedAAWrapperPass();
#   75|         (void) llvm::createScopedNoAliasAAWrapperPass();
#   76|->       (void) llvm::createBreakCriticalEdgesPass();
#   77|         (void) llvm::createCallGraphDOTPrinterPass();
#   78|         (void) llvm::createCallGraphViewerPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:77: alloc_fn: Storage is returned from allocation function "createCallGraphDOTPrinterPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:77: leaked_storage: Failing to save or free storage allocated by "llvm::createCallGraphDOTPrinterPass()" leaks it.
#   75|         (void) llvm::createScopedNoAliasAAWrapperPass();
#   76|         (void) llvm::createBreakCriticalEdgesPass();
#   77|->       (void) llvm::createCallGraphDOTPrinterPass();
#   78|         (void) llvm::createCallGraphViewerPass();
#   79|         (void) llvm::createCFGSimplificationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:78: alloc_fn: Storage is returned from allocation function "createCallGraphViewerPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:78: leaked_storage: Failing to save or free storage allocated by "llvm::createCallGraphViewerPass()" leaks it.
#   76|         (void) llvm::createBreakCriticalEdgesPass();
#   77|         (void) llvm::createCallGraphDOTPrinterPass();
#   78|->       (void) llvm::createCallGraphViewerPass();
#   79|         (void) llvm::createCFGSimplificationPass();
#   80|         (void) llvm::createStructurizeCFGPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:79: alloc_fn: Storage is returned from allocation function "createCFGSimplificationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:79: leaked_storage: Failing to save or free storage allocated by "llvm::createCFGSimplificationPass(llvm::SimplifyCFGOptions(), std::function<bool (llvm::Function const &)>(std::nullptr_t()))" leaks it.
#   77|         (void) llvm::createCallGraphDOTPrinterPass();
#   78|         (void) llvm::createCallGraphViewerPass();
#   79|->       (void) llvm::createCFGSimplificationPass();
#   80|         (void) llvm::createStructurizeCFGPass();
#   81|         (void) llvm::createCostModelAnalysisPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:80: alloc_fn: Storage is returned from allocation function "createStructurizeCFGPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:80: leaked_storage: Failing to save or free storage allocated by "llvm::createStructurizeCFGPass(false)" leaks it.
#   78|         (void) llvm::createCallGraphViewerPass();
#   79|         (void) llvm::createCFGSimplificationPass();
#   80|->       (void) llvm::createStructurizeCFGPass();
#   81|         (void) llvm::createCostModelAnalysisPass();
#   82|         (void) llvm::createDeadArgEliminationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:81: alloc_fn: Storage is returned from allocation function "createCostModelAnalysisPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:81: leaked_storage: Failing to save or free storage allocated by "llvm::createCostModelAnalysisPass()" leaks it.
#   79|         (void) llvm::createCFGSimplificationPass();
#   80|         (void) llvm::createStructurizeCFGPass();
#   81|->       (void) llvm::createCostModelAnalysisPass();
#   82|         (void) llvm::createDeadArgEliminationPass();
#   83|         (void) llvm::createDeadCodeEliminationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:82: alloc_fn: Storage is returned from allocation function "createDeadArgEliminationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:82: leaked_storage: Failing to save or free storage allocated by "llvm::createDeadArgEliminationPass()" leaks it.
#   80|         (void) llvm::createStructurizeCFGPass();
#   81|         (void) llvm::createCostModelAnalysisPass();
#   82|->       (void) llvm::createDeadArgEliminationPass();
#   83|         (void) llvm::createDeadCodeEliminationPass();
#   84|         (void) llvm::createDependenceAnalysisWrapperPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:83: alloc_fn: Storage is returned from allocation function "createDeadCodeEliminationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:83: leaked_storage: Failing to save or free storage allocated by "llvm::createDeadCodeEliminationPass()" leaks it.
#   81|         (void) llvm::createCostModelAnalysisPass();
#   82|         (void) llvm::createDeadArgEliminationPass();
#   83|->       (void) llvm::createDeadCodeEliminationPass();
#   84|         (void) llvm::createDependenceAnalysisWrapperPass();
#   85|         (void) llvm::createDomOnlyPrinterWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:84: alloc_fn: Storage is returned from allocation function "createDependenceAnalysisWrapperPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:84: leaked_storage: Failing to save or free storage allocated by "llvm::createDependenceAnalysisWrapperPass()" leaks it.
#   82|         (void) llvm::createDeadArgEliminationPass();
#   83|         (void) llvm::createDeadCodeEliminationPass();
#   84|->       (void) llvm::createDependenceAnalysisWrapperPass();
#   85|         (void) llvm::createDomOnlyPrinterWrapperPassPass();
#   86|         (void) llvm::createDomPrinterWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:85: alloc_fn: Storage is returned from allocation function "createDomOnlyPrinterWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:85: leaked_storage: Failing to save or free storage allocated by "llvm::createDomOnlyPrinterWrapperPassPass()" leaks it.
#   83|         (void) llvm::createDeadCodeEliminationPass();
#   84|         (void) llvm::createDependenceAnalysisWrapperPass();
#   85|->       (void) llvm::createDomOnlyPrinterWrapperPassPass();
#   86|         (void) llvm::createDomPrinterWrapperPassPass();
#   87|         (void) llvm::createDomOnlyViewerWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:86: alloc_fn: Storage is returned from allocation function "createDomPrinterWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:86: leaked_storage: Failing to save or free storage allocated by "llvm::createDomPrinterWrapperPassPass()" leaks it.
#   84|         (void) llvm::createDependenceAnalysisWrapperPass();
#   85|         (void) llvm::createDomOnlyPrinterWrapperPassPass();
#   86|->       (void) llvm::createDomPrinterWrapperPassPass();
#   87|         (void) llvm::createDomOnlyViewerWrapperPassPass();
#   88|         (void) llvm::createDomViewerWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:87: alloc_fn: Storage is returned from allocation function "createDomOnlyViewerWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:87: leaked_storage: Failing to save or free storage allocated by "llvm::createDomOnlyViewerWrapperPassPass()" leaks it.
#   85|         (void) llvm::createDomOnlyPrinterWrapperPassPass();
#   86|         (void) llvm::createDomPrinterWrapperPassPass();
#   87|->       (void) llvm::createDomOnlyViewerWrapperPassPass();
#   88|         (void) llvm::createDomViewerWrapperPassPass();
#   89|         (void) llvm::createAlwaysInlinerLegacyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:88: alloc_fn: Storage is returned from allocation function "createDomViewerWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:88: leaked_storage: Failing to save or free storage allocated by "llvm::createDomViewerWrapperPassPass()" leaks it.
#   86|         (void) llvm::createDomPrinterWrapperPassPass();
#   87|         (void) llvm::createDomOnlyViewerWrapperPassPass();
#   88|->       (void) llvm::createDomViewerWrapperPassPass();
#   89|         (void) llvm::createAlwaysInlinerLegacyPass();
#   90|         (void) llvm::createGlobalsAAWrapperPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:89: alloc_fn: Storage is returned from allocation function "createAlwaysInlinerLegacyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:89: leaked_storage: Failing to save or free storage allocated by "llvm::createAlwaysInlinerLegacyPass(true)" leaks it.
#   87|         (void) llvm::createDomOnlyViewerWrapperPassPass();
#   88|         (void) llvm::createDomViewerWrapperPassPass();
#   89|->       (void) llvm::createAlwaysInlinerLegacyPass();
#   90|         (void) llvm::createGlobalsAAWrapperPass();
#   91|         (void) llvm::createGuardWideningPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:90: alloc_fn: Storage is returned from allocation function "createGlobalsAAWrapperPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:90: leaked_storage: Failing to save or free storage allocated by "llvm::createGlobalsAAWrapperPass()" leaks it.
#   88|         (void) llvm::createDomViewerWrapperPassPass();
#   89|         (void) llvm::createAlwaysInlinerLegacyPass();
#   90|->       (void) llvm::createGlobalsAAWrapperPass();
#   91|         (void) llvm::createGuardWideningPass();
#   92|         (void) llvm::createLoopGuardWideningPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:91: alloc_fn: Storage is returned from allocation function "createGuardWideningPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:91: leaked_storage: Failing to save or free storage allocated by "llvm::createGuardWideningPass()" leaks it.
#   89|         (void) llvm::createAlwaysInlinerLegacyPass();
#   90|         (void) llvm::createGlobalsAAWrapperPass();
#   91|->       (void) llvm::createGuardWideningPass();
#   92|         (void) llvm::createLoopGuardWideningPass();
#   93|         (void) llvm::createInstSimplifyLegacyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:92: alloc_fn: Storage is returned from allocation function "createLoopGuardWideningPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:92: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopGuardWideningPass()" leaks it.
#   90|         (void) llvm::createGlobalsAAWrapperPass();
#   91|         (void) llvm::createGuardWideningPass();
#   92|->       (void) llvm::createLoopGuardWideningPass();
#   93|         (void) llvm::createInstSimplifyLegacyPass();
#   94|         (void) llvm::createInstructionCombiningPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:93: alloc_fn: Storage is returned from allocation function "createInstSimplifyLegacyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:93: leaked_storage: Failing to save or free storage allocated by "llvm::createInstSimplifyLegacyPass()" leaks it.
#   91|         (void) llvm::createGuardWideningPass();
#   92|         (void) llvm::createLoopGuardWideningPass();
#   93|->       (void) llvm::createInstSimplifyLegacyPass();
#   94|         (void) llvm::createInstructionCombiningPass();
#   95|         (void) llvm::createJMCInstrumenterPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:94: alloc_fn: Storage is returned from allocation function "createInstructionCombiningPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:94: leaked_storage: Failing to save or free storage allocated by "llvm::createInstructionCombiningPass()" leaks it.
#   92|         (void) llvm::createLoopGuardWideningPass();
#   93|         (void) llvm::createInstSimplifyLegacyPass();
#   94|->       (void) llvm::createInstructionCombiningPass();
#   95|         (void) llvm::createJMCInstrumenterPass();
#   96|         (void) llvm::createKCFIPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:95: alloc_fn: Storage is returned from allocation function "createJMCInstrumenterPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:95: leaked_storage: Failing to save or free storage allocated by "llvm::createJMCInstrumenterPass()" leaks it.
#   93|         (void) llvm::createInstSimplifyLegacyPass();
#   94|         (void) llvm::createInstructionCombiningPass();
#   95|->       (void) llvm::createJMCInstrumenterPass();
#   96|         (void) llvm::createKCFIPass();
#   97|         (void) llvm::createLCSSAPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:96: alloc_fn: Storage is returned from allocation function "createKCFIPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:96: leaked_storage: Failing to save or free storage allocated by "llvm::createKCFIPass()" leaks it.
#   94|         (void) llvm::createInstructionCombiningPass();
#   95|         (void) llvm::createJMCInstrumenterPass();
#   96|->       (void) llvm::createKCFIPass();
#   97|         (void) llvm::createLCSSAPass();
#   98|         (void) llvm::createLICMPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:97: alloc_fn: Storage is returned from allocation function "createLCSSAPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:97: leaked_storage: Failing to save or free storage allocated by "llvm::createLCSSAPass()" leaks it.
#   95|         (void) llvm::createJMCInstrumenterPass();
#   96|         (void) llvm::createKCFIPass();
#   97|->       (void) llvm::createLCSSAPass();
#   98|         (void) llvm::createLICMPass();
#   99|         (void) llvm::createLoopSinkPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:98: alloc_fn: Storage is returned from allocation function "createLICMPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:98: leaked_storage: Failing to save or free storage allocated by "llvm::createLICMPass()" leaks it.
#   96|         (void) llvm::createKCFIPass();
#   97|         (void) llvm::createLCSSAPass();
#   98|->       (void) llvm::createLICMPass();
#   99|         (void) llvm::createLoopSinkPass();
#  100|         (void) llvm::createLazyValueInfoPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:99: alloc_fn: Storage is returned from allocation function "createLoopSinkPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:99: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopSinkPass()" leaks it.
#   97|         (void) llvm::createLCSSAPass();
#   98|         (void) llvm::createLICMPass();
#   99|->       (void) llvm::createLoopSinkPass();
#  100|         (void) llvm::createLazyValueInfoPass();
#  101|         (void) llvm::createLoopExtractorPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:100: alloc_fn: Storage is returned from allocation function "createLazyValueInfoPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:100: leaked_storage: Failing to save or free storage allocated by "llvm::createLazyValueInfoPass()" leaks it.
#   98|         (void) llvm::createLICMPass();
#   99|         (void) llvm::createLoopSinkPass();
#  100|->       (void) llvm::createLazyValueInfoPass();
#  101|         (void) llvm::createLoopExtractorPass();
#  102|         (void) llvm::createLoopPredicationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:101: alloc_fn: Storage is returned from allocation function "createLoopExtractorPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:101: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopExtractorPass()" leaks it.
#   99|         (void) llvm::createLoopSinkPass();
#  100|         (void) llvm::createLazyValueInfoPass();
#  101|->       (void) llvm::createLoopExtractorPass();
#  102|         (void) llvm::createLoopPredicationPass();
#  103|         (void) llvm::createLoopSimplifyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:102: alloc_fn: Storage is returned from allocation function "createLoopPredicationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:102: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopPredicationPass()" leaks it.
#  100|         (void) llvm::createLazyValueInfoPass();
#  101|         (void) llvm::createLoopExtractorPass();
#  102|->       (void) llvm::createLoopPredicationPass();
#  103|         (void) llvm::createLoopSimplifyPass();
#  104|         (void) llvm::createLoopSimplifyCFGPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:103: alloc_fn: Storage is returned from allocation function "createLoopSimplifyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:103: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopSimplifyPass()" leaks it.
#  101|         (void) llvm::createLoopExtractorPass();
#  102|         (void) llvm::createLoopPredicationPass();
#  103|->       (void) llvm::createLoopSimplifyPass();
#  104|         (void) llvm::createLoopSimplifyCFGPass();
#  105|         (void) llvm::createLoopStrengthReducePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:104: alloc_fn: Storage is returned from allocation function "createLoopSimplifyCFGPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:104: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopSimplifyCFGPass()" leaks it.
#  102|         (void) llvm::createLoopPredicationPass();
#  103|         (void) llvm::createLoopSimplifyPass();
#  104|->       (void) llvm::createLoopSimplifyCFGPass();
#  105|         (void) llvm::createLoopStrengthReducePass();
#  106|         (void) llvm::createLoopUnrollPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:105: alloc_fn: Storage is returned from allocation function "createLoopStrengthReducePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:105: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopStrengthReducePass()" leaks it.
#  103|         (void) llvm::createLoopSimplifyPass();
#  104|         (void) llvm::createLoopSimplifyCFGPass();
#  105|->       (void) llvm::createLoopStrengthReducePass();
#  106|         (void) llvm::createLoopUnrollPass();
#  107|         (void) llvm::createLoopRotatePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:106: alloc_fn: Storage is returned from allocation function "createLoopUnrollPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:106: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopUnrollPass(2, false, false, -1, -1, -1, -1, -1, -1)" leaks it.
#  104|         (void) llvm::createLoopSimplifyCFGPass();
#  105|         (void) llvm::createLoopStrengthReducePass();
#  106|->       (void) llvm::createLoopUnrollPass();
#  107|         (void) llvm::createLoopRotatePass();
#  108|         (void) llvm::createLowerConstantIntrinsicsPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:107: alloc_fn: Storage is returned from allocation function "createLoopRotatePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:107: leaked_storage: Failing to save or free storage allocated by "llvm::createLoopRotatePass(-1, false)" leaks it.
#  105|         (void) llvm::createLoopStrengthReducePass();
#  106|         (void) llvm::createLoopUnrollPass();
#  107|->       (void) llvm::createLoopRotatePass();
#  108|         (void) llvm::createLowerConstantIntrinsicsPass();
#  109|         (void) llvm::createLowerExpectIntrinsicPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:108: alloc_fn: Storage is returned from allocation function "createLowerConstantIntrinsicsPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:108: leaked_storage: Failing to save or free storage allocated by "llvm::createLowerConstantIntrinsicsPass()" leaks it.
#  106|         (void) llvm::createLoopUnrollPass();
#  107|         (void) llvm::createLoopRotatePass();
#  108|->       (void) llvm::createLowerConstantIntrinsicsPass();
#  109|         (void) llvm::createLowerExpectIntrinsicPass();
#  110|         (void) llvm::createLowerGlobalDtorsLegacyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:109: alloc_fn: Storage is returned from allocation function "createLowerExpectIntrinsicPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:109: leaked_storage: Failing to save or free storage allocated by "llvm::createLowerExpectIntrinsicPass()" leaks it.
#  107|         (void) llvm::createLoopRotatePass();
#  108|         (void) llvm::createLowerConstantIntrinsicsPass();
#  109|->       (void) llvm::createLowerExpectIntrinsicPass();
#  110|         (void) llvm::createLowerGlobalDtorsLegacyPass();
#  111|         (void) llvm::createLowerInvokePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:110: alloc_fn: Storage is returned from allocation function "createLowerGlobalDtorsLegacyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:110: leaked_storage: Failing to save or free storage allocated by "llvm::createLowerGlobalDtorsLegacyPass()" leaks it.
#  108|         (void) llvm::createLowerConstantIntrinsicsPass();
#  109|         (void) llvm::createLowerExpectIntrinsicPass();
#  110|->       (void) llvm::createLowerGlobalDtorsLegacyPass();
#  111|         (void) llvm::createLowerInvokePass();
#  112|         (void) llvm::createLowerSwitchPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:111: alloc_fn: Storage is returned from allocation function "createLowerInvokePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:111: leaked_storage: Failing to save or free storage allocated by "llvm::createLowerInvokePass()" leaks it.
#  109|         (void) llvm::createLowerExpectIntrinsicPass();
#  110|         (void) llvm::createLowerGlobalDtorsLegacyPass();
#  111|->       (void) llvm::createLowerInvokePass();
#  112|         (void) llvm::createLowerSwitchPass();
#  113|         (void) llvm::createNaryReassociatePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:112: alloc_fn: Storage is returned from allocation function "createLowerSwitchPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:112: leaked_storage: Failing to save or free storage allocated by "llvm::createLowerSwitchPass()" leaks it.
#  110|         (void) llvm::createLowerGlobalDtorsLegacyPass();
#  111|         (void) llvm::createLowerInvokePass();
#  112|->       (void) llvm::createLowerSwitchPass();
#  113|         (void) llvm::createNaryReassociatePass();
#  114|         (void) llvm::createObjCARCContractPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:113: alloc_fn: Storage is returned from allocation function "createNaryReassociatePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:113: leaked_storage: Failing to save or free storage allocated by "llvm::createNaryReassociatePass()" leaks it.
#  111|         (void) llvm::createLowerInvokePass();
#  112|         (void) llvm::createLowerSwitchPass();
#  113|->       (void) llvm::createNaryReassociatePass();
#  114|         (void) llvm::createObjCARCContractPass();
#  115|         (void) llvm::createPromoteMemoryToRegisterPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:114: alloc_fn: Storage is returned from allocation function "createObjCARCContractPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:114: leaked_storage: Failing to save or free storage allocated by "llvm::createObjCARCContractPass()" leaks it.
#  112|         (void) llvm::createLowerSwitchPass();
#  113|         (void) llvm::createNaryReassociatePass();
#  114|->       (void) llvm::createObjCARCContractPass();
#  115|         (void) llvm::createPromoteMemoryToRegisterPass();
#  116|         (void) llvm::createDemoteRegisterToMemoryPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:115: alloc_fn: Storage is returned from allocation function "createPromoteMemoryToRegisterPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:115: leaked_storage: Failing to save or free storage allocated by "llvm::createPromoteMemoryToRegisterPass(false)" leaks it.
#  113|         (void) llvm::createNaryReassociatePass();
#  114|         (void) llvm::createObjCARCContractPass();
#  115|->       (void) llvm::createPromoteMemoryToRegisterPass();
#  116|         (void) llvm::createDemoteRegisterToMemoryPass();
#  117|         (void)llvm::createPostDomOnlyPrinterWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:116: alloc_fn: Storage is returned from allocation function "createDemoteRegisterToMemoryPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:116: leaked_storage: Failing to save or free storage allocated by "llvm::createDemoteRegisterToMemoryPass()" leaks it.
#  114|         (void) llvm::createObjCARCContractPass();
#  115|         (void) llvm::createPromoteMemoryToRegisterPass();
#  116|->       (void) llvm::createDemoteRegisterToMemoryPass();
#  117|         (void)llvm::createPostDomOnlyPrinterWrapperPassPass();
#  118|         (void)llvm::createPostDomPrinterWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:117: alloc_fn: Storage is returned from allocation function "createPostDomOnlyPrinterWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:117: leaked_storage: Failing to save or free storage allocated by "llvm::createPostDomOnlyPrinterWrapperPassPass()" leaks it.
#  115|         (void) llvm::createPromoteMemoryToRegisterPass();
#  116|         (void) llvm::createDemoteRegisterToMemoryPass();
#  117|->       (void)llvm::createPostDomOnlyPrinterWrapperPassPass();
#  118|         (void)llvm::createPostDomPrinterWrapperPassPass();
#  119|         (void)llvm::createPostDomOnlyViewerWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:118: alloc_fn: Storage is returned from allocation function "createPostDomPrinterWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:118: leaked_storage: Failing to save or free storage allocated by "llvm::createPostDomPrinterWrapperPassPass()" leaks it.
#  116|         (void) llvm::createDemoteRegisterToMemoryPass();
#  117|         (void)llvm::createPostDomOnlyPrinterWrapperPassPass();
#  118|->       (void)llvm::createPostDomPrinterWrapperPassPass();
#  119|         (void)llvm::createPostDomOnlyViewerWrapperPassPass();
#  120|         (void)llvm::createPostDomViewerWrapperPassPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:119: alloc_fn: Storage is returned from allocation function "createPostDomOnlyViewerWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:119: leaked_storage: Failing to save or free storage allocated by "llvm::createPostDomOnlyViewerWrapperPassPass()" leaks it.
#  117|         (void)llvm::createPostDomOnlyPrinterWrapperPassPass();
#  118|         (void)llvm::createPostDomPrinterWrapperPassPass();
#  119|->       (void)llvm::createPostDomOnlyViewerWrapperPassPass();
#  120|         (void)llvm::createPostDomViewerWrapperPassPass();
#  121|         (void) llvm::createReassociatePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:120: alloc_fn: Storage is returned from allocation function "createPostDomViewerWrapperPassPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:120: leaked_storage: Failing to save or free storage allocated by "llvm::createPostDomViewerWrapperPassPass()" leaks it.
#  118|         (void)llvm::createPostDomPrinterWrapperPassPass();
#  119|         (void)llvm::createPostDomOnlyViewerWrapperPassPass();
#  120|->       (void)llvm::createPostDomViewerWrapperPassPass();
#  121|         (void) llvm::createReassociatePass();
#  122|         (void) llvm::createRedundantDbgInstEliminationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:121: alloc_fn: Storage is returned from allocation function "createReassociatePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:121: leaked_storage: Failing to save or free storage allocated by "llvm::createReassociatePass()" leaks it.
#  119|         (void)llvm::createPostDomOnlyViewerWrapperPassPass();
#  120|         (void)llvm::createPostDomViewerWrapperPassPass();
#  121|->       (void) llvm::createReassociatePass();
#  122|         (void) llvm::createRedundantDbgInstEliminationPass();
#  123|         (void) llvm::createRegionInfoPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:122: alloc_fn: Storage is returned from allocation function "createRedundantDbgInstEliminationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:122: leaked_storage: Failing to save or free storage allocated by "llvm::createRedundantDbgInstEliminationPass()" leaks it.
#  120|         (void)llvm::createPostDomViewerWrapperPassPass();
#  121|         (void) llvm::createReassociatePass();
#  122|->       (void) llvm::createRedundantDbgInstEliminationPass();
#  123|         (void) llvm::createRegionInfoPass();
#  124|         (void) llvm::createRegionOnlyPrinterPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:123: alloc_fn: Storage is returned from allocation function "createRegionInfoPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:123: leaked_storage: Failing to save or free storage allocated by "llvm::createRegionInfoPass()" leaks it.
#  121|         (void) llvm::createReassociatePass();
#  122|         (void) llvm::createRedundantDbgInstEliminationPass();
#  123|->       (void) llvm::createRegionInfoPass();
#  124|         (void) llvm::createRegionOnlyPrinterPass();
#  125|         (void) llvm::createRegionOnlyViewerPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:124: alloc_fn: Storage is returned from allocation function "createRegionOnlyPrinterPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:124: leaked_storage: Failing to save or free storage allocated by "llvm::createRegionOnlyPrinterPass()" leaks it.
#  122|         (void) llvm::createRedundantDbgInstEliminationPass();
#  123|         (void) llvm::createRegionInfoPass();
#  124|->       (void) llvm::createRegionOnlyPrinterPass();
#  125|         (void) llvm::createRegionOnlyViewerPass();
#  126|         (void) llvm::createRegionPrinterPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:125: alloc_fn: Storage is returned from allocation function "createRegionOnlyViewerPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:125: leaked_storage: Failing to save or free storage allocated by "llvm::createRegionOnlyViewerPass()" leaks it.
#  123|         (void) llvm::createRegionInfoPass();
#  124|         (void) llvm::createRegionOnlyPrinterPass();
#  125|->       (void) llvm::createRegionOnlyViewerPass();
#  126|         (void) llvm::createRegionPrinterPass();
#  127|         (void) llvm::createRegionViewerPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:126: alloc_fn: Storage is returned from allocation function "createRegionPrinterPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:126: leaked_storage: Failing to save or free storage allocated by "llvm::createRegionPrinterPass()" leaks it.
#  124|         (void) llvm::createRegionOnlyPrinterPass();
#  125|         (void) llvm::createRegionOnlyViewerPass();
#  126|->       (void) llvm::createRegionPrinterPass();
#  127|         (void) llvm::createRegionViewerPass();
#  128|         (void) llvm::createSafeStackPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:127: alloc_fn: Storage is returned from allocation function "createRegionViewerPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:127: leaked_storage: Failing to save or free storage allocated by "llvm::createRegionViewerPass()" leaks it.
#  125|         (void) llvm::createRegionOnlyViewerPass();
#  126|         (void) llvm::createRegionPrinterPass();
#  127|->       (void) llvm::createRegionViewerPass();
#  128|         (void) llvm::createSafeStackPass();
#  129|         (void) llvm::createSROAPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:128: alloc_fn: Storage is returned from allocation function "createSafeStackPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:128: leaked_storage: Failing to save or free storage allocated by "llvm::createSafeStackPass()" leaks it.
#  126|         (void) llvm::createRegionPrinterPass();
#  127|         (void) llvm::createRegionViewerPass();
#  128|->       (void) llvm::createSafeStackPass();
#  129|         (void) llvm::createSROAPass();
#  130|         (void) llvm::createSingleLoopExtractorPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:129: alloc_fn: Storage is returned from allocation function "createSROAPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:129: leaked_storage: Failing to save or free storage allocated by "llvm::createSROAPass(true)" leaks it.
#  127|         (void) llvm::createRegionViewerPass();
#  128|         (void) llvm::createSafeStackPass();
#  129|->       (void) llvm::createSROAPass();
#  130|         (void) llvm::createSingleLoopExtractorPass();
#  131|         (void) llvm::createTailCallEliminationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:130: alloc_fn: Storage is returned from allocation function "createSingleLoopExtractorPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:130: leaked_storage: Failing to save or free storage allocated by "llvm::createSingleLoopExtractorPass()" leaks it.
#  128|         (void) llvm::createSafeStackPass();
#  129|         (void) llvm::createSROAPass();
#  130|->       (void) llvm::createSingleLoopExtractorPass();
#  131|         (void) llvm::createTailCallEliminationPass();
#  132|         (void)llvm::createTLSVariableHoistPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:131: alloc_fn: Storage is returned from allocation function "createTailCallEliminationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:131: leaked_storage: Failing to save or free storage allocated by "llvm::createTailCallEliminationPass()" leaks it.
#  129|         (void) llvm::createSROAPass();
#  130|         (void) llvm::createSingleLoopExtractorPass();
#  131|->       (void) llvm::createTailCallEliminationPass();
#  132|         (void)llvm::createTLSVariableHoistPass();
#  133|         (void) llvm::createUnifyFunctionExitNodesPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:132: alloc_fn: Storage is returned from allocation function "createTLSVariableHoistPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:132: leaked_storage: Failing to save or free storage allocated by "llvm::createTLSVariableHoistPass()" leaks it.
#  130|         (void) llvm::createSingleLoopExtractorPass();
#  131|         (void) llvm::createTailCallEliminationPass();
#  132|->       (void)llvm::createTLSVariableHoistPass();
#  133|         (void) llvm::createUnifyFunctionExitNodesPass();
#  134|         (void) llvm::createInstCountPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:133: alloc_fn: Storage is returned from allocation function "createUnifyFunctionExitNodesPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:133: leaked_storage: Failing to save or free storage allocated by "llvm::createUnifyFunctionExitNodesPass()" leaks it.
#  131|         (void) llvm::createTailCallEliminationPass();
#  132|         (void)llvm::createTLSVariableHoistPass();
#  133|->       (void) llvm::createUnifyFunctionExitNodesPass();
#  134|         (void) llvm::createInstCountPass();
#  135|         (void) llvm::createConstantHoistingPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:134: alloc_fn: Storage is returned from allocation function "createInstCountPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:134: leaked_storage: Failing to save or free storage allocated by "llvm::createInstCountPass()" leaks it.
#  132|         (void)llvm::createTLSVariableHoistPass();
#  133|         (void) llvm::createUnifyFunctionExitNodesPass();
#  134|->       (void) llvm::createInstCountPass();
#  135|         (void) llvm::createConstantHoistingPass();
#  136|         (void) llvm::createCodeGenPreparePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:135: alloc_fn: Storage is returned from allocation function "createConstantHoistingPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:135: leaked_storage: Failing to save or free storage allocated by "llvm::createConstantHoistingPass()" leaks it.
#  133|         (void) llvm::createUnifyFunctionExitNodesPass();
#  134|         (void) llvm::createInstCountPass();
#  135|->       (void) llvm::createConstantHoistingPass();
#  136|         (void) llvm::createCodeGenPreparePass();
#  137|         (void) llvm::createEarlyCSEPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:136: alloc_fn: Storage is returned from allocation function "createCodeGenPreparePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:136: leaked_storage: Failing to save or free storage allocated by "llvm::createCodeGenPreparePass()" leaks it.
#  134|         (void) llvm::createInstCountPass();
#  135|         (void) llvm::createConstantHoistingPass();
#  136|->       (void) llvm::createCodeGenPreparePass();
#  137|         (void) llvm::createEarlyCSEPass();
#  138|         (void) llvm::createMergedLoadStoreMotionPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:137: alloc_fn: Storage is returned from allocation function "createEarlyCSEPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:137: leaked_storage: Failing to save or free storage allocated by "llvm::createEarlyCSEPass(false)" leaks it.
#  135|         (void) llvm::createConstantHoistingPass();
#  136|         (void) llvm::createCodeGenPreparePass();
#  137|->       (void) llvm::createEarlyCSEPass();
#  138|         (void) llvm::createMergedLoadStoreMotionPass();
#  139|         (void) llvm::createGVNPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:138: alloc_fn: Storage is returned from allocation function "createMergedLoadStoreMotionPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:138: leaked_storage: Failing to save or free storage allocated by "llvm::createMergedLoadStoreMotionPass(false)" leaks it.
#  136|         (void) llvm::createCodeGenPreparePass();
#  137|         (void) llvm::createEarlyCSEPass();
#  138|->       (void) llvm::createMergedLoadStoreMotionPass();
#  139|         (void) llvm::createGVNPass();
#  140|         (void) llvm::createPostDomTree();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:139: alloc_fn: Storage is returned from allocation function "createGVNPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:139: leaked_storage: Failing to save or free storage allocated by "llvm::createGVNPass(false)" leaks it.
#  137|         (void) llvm::createEarlyCSEPass();
#  138|         (void) llvm::createMergedLoadStoreMotionPass();
#  139|->       (void) llvm::createGVNPass();
#  140|         (void) llvm::createPostDomTree();
#  141|         (void) llvm::createMergeICmpsLegacyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:140: alloc_fn: Storage is returned from allocation function "createPostDomTree".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:140: leaked_storage: Failing to save or free storage allocated by "llvm::createPostDomTree()" leaks it.
#  138|         (void) llvm::createMergedLoadStoreMotionPass();
#  139|         (void) llvm::createGVNPass();
#  140|->       (void) llvm::createPostDomTree();
#  141|         (void) llvm::createMergeICmpsLegacyPass();
#  142|         (void) llvm::createExpandLargeDivRemPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:141: alloc_fn: Storage is returned from allocation function "createMergeICmpsLegacyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:141: leaked_storage: Failing to save or free storage allocated by "llvm::createMergeICmpsLegacyPass()" leaks it.
#  139|         (void) llvm::createGVNPass();
#  140|         (void) llvm::createPostDomTree();
#  141|->       (void) llvm::createMergeICmpsLegacyPass();
#  142|         (void) llvm::createExpandLargeDivRemPass();
#  143|         (void) llvm::createExpandMemCmpPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:142: alloc_fn: Storage is returned from allocation function "createExpandLargeDivRemPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:142: leaked_storage: Failing to save or free storage allocated by "llvm::createExpandLargeDivRemPass()" leaks it.
#  140|         (void) llvm::createPostDomTree();
#  141|         (void) llvm::createMergeICmpsLegacyPass();
#  142|->       (void) llvm::createExpandLargeDivRemPass();
#  143|         (void) llvm::createExpandMemCmpPass();
#  144|         (void) llvm::createExpandVectorPredicationPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:143: alloc_fn: Storage is returned from allocation function "createExpandMemCmpPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:143: leaked_storage: Failing to save or free storage allocated by "llvm::createExpandMemCmpPass()" leaks it.
#  141|         (void) llvm::createMergeICmpsLegacyPass();
#  142|         (void) llvm::createExpandLargeDivRemPass();
#  143|->       (void) llvm::createExpandMemCmpPass();
#  144|         (void) llvm::createExpandVectorPredicationPass();
#  145|         std::string buf;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:144: alloc_fn: Storage is returned from allocation function "createExpandVectorPredicationPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:144: leaked_storage: Failing to save or free storage allocated by "llvm::createExpandVectorPredicationPass()" leaks it.
#  142|         (void) llvm::createExpandLargeDivRemPass();
#  143|         (void) llvm::createExpandMemCmpPass();
#  144|->       (void) llvm::createExpandVectorPredicationPass();
#  145|         std::string buf;
#  146|         llvm::raw_string_ostream os(buf);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:147: alloc_fn: Storage is returned from allocation function "createPrintModulePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:147: leaked_storage: Failing to save or free storage allocated by "llvm::createPrintModulePass(os, std::string const("", std::allocator<char>()), false)" leaks it.
#  145|         std::string buf;
#  146|         llvm::raw_string_ostream os(buf);
#  147|->       (void) llvm::createPrintModulePass(os);
#  148|         (void) llvm::createPrintFunctionPass(os);
#  149|         (void) llvm::createSinkingPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:148: alloc_fn: Storage is returned from allocation function "createPrintFunctionPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:148: leaked_storage: Failing to save or free storage allocated by "llvm::createPrintFunctionPass(os, std::string const("", std::allocator<char>()))" leaks it.
#  146|         llvm::raw_string_ostream os(buf);
#  147|         (void) llvm::createPrintModulePass(os);
#  148|->       (void) llvm::createPrintFunctionPass(os);
#  149|         (void) llvm::createSinkingPass();
#  150|         (void) llvm::createLowerAtomicPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:149: alloc_fn: Storage is returned from allocation function "createSinkingPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:149: leaked_storage: Failing to save or free storage allocated by "llvm::createSinkingPass()" leaks it.
#  147|         (void) llvm::createPrintModulePass(os);
#  148|         (void) llvm::createPrintFunctionPass(os);
#  149|->       (void) llvm::createSinkingPass();
#  150|         (void) llvm::createLowerAtomicPass();
#  151|         (void) llvm::createLoadStoreVectorizerPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:150: alloc_fn: Storage is returned from allocation function "createLowerAtomicPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:150: leaked_storage: Failing to save or free storage allocated by "llvm::createLowerAtomicPass()" leaks it.
#  148|         (void) llvm::createPrintFunctionPass(os);
#  149|         (void) llvm::createSinkingPass();
#  150|->       (void) llvm::createLowerAtomicPass();
#  151|         (void) llvm::createLoadStoreVectorizerPass();
#  152|         (void) llvm::createPartiallyInlineLibCallsPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:151: alloc_fn: Storage is returned from allocation function "createLoadStoreVectorizerPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:151: leaked_storage: Failing to save or free storage allocated by "llvm::createLoadStoreVectorizerPass()" leaks it.
#  149|         (void) llvm::createSinkingPass();
#  150|         (void) llvm::createLowerAtomicPass();
#  151|->       (void) llvm::createLoadStoreVectorizerPass();
#  152|         (void) llvm::createPartiallyInlineLibCallsPass();
#  153|         (void) llvm::createScalarizerPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:152: alloc_fn: Storage is returned from allocation function "createPartiallyInlineLibCallsPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:152: leaked_storage: Failing to save or free storage allocated by "llvm::createPartiallyInlineLibCallsPass()" leaks it.
#  150|         (void) llvm::createLowerAtomicPass();
#  151|         (void) llvm::createLoadStoreVectorizerPass();
#  152|->       (void) llvm::createPartiallyInlineLibCallsPass();
#  153|         (void) llvm::createScalarizerPass();
#  154|         (void) llvm::createSeparateConstOffsetFromGEPPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:153: alloc_fn: Storage is returned from allocation function "createScalarizerPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:153: leaked_storage: Failing to save or free storage allocated by "llvm::createScalarizerPass()" leaks it.
#  151|         (void) llvm::createLoadStoreVectorizerPass();
#  152|         (void) llvm::createPartiallyInlineLibCallsPass();
#  153|->       (void) llvm::createScalarizerPass();
#  154|         (void) llvm::createSeparateConstOffsetFromGEPPass();
#  155|         (void) llvm::createSpeculativeExecutionPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:154: alloc_fn: Storage is returned from allocation function "createSeparateConstOffsetFromGEPPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:154: leaked_storage: Failing to save or free storage allocated by "llvm::createSeparateConstOffsetFromGEPPass(false)" leaks it.
#  152|         (void) llvm::createPartiallyInlineLibCallsPass();
#  153|         (void) llvm::createScalarizerPass();
#  154|->       (void) llvm::createSeparateConstOffsetFromGEPPass();
#  155|         (void) llvm::createSpeculativeExecutionPass();
#  156|         (void) llvm::createSpeculativeExecutionIfHasBranchDivergencePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:155: alloc_fn: Storage is returned from allocation function "createSpeculativeExecutionPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:155: leaked_storage: Failing to save or free storage allocated by "llvm::createSpeculativeExecutionPass()" leaks it.
#  153|         (void) llvm::createScalarizerPass();
#  154|         (void) llvm::createSeparateConstOffsetFromGEPPass();
#  155|->       (void) llvm::createSpeculativeExecutionPass();
#  156|         (void) llvm::createSpeculativeExecutionIfHasBranchDivergencePass();
#  157|         (void) llvm::createStraightLineStrengthReducePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:156: alloc_fn: Storage is returned from allocation function "createSpeculativeExecutionIfHasBranchDivergencePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:156: leaked_storage: Failing to save or free storage allocated by "llvm::createSpeculativeExecutionIfHasBranchDivergencePass()" leaks it.
#  154|         (void) llvm::createSeparateConstOffsetFromGEPPass();
#  155|         (void) llvm::createSpeculativeExecutionPass();
#  156|->       (void) llvm::createSpeculativeExecutionIfHasBranchDivergencePass();
#  157|         (void) llvm::createStraightLineStrengthReducePass();
#  158|         (void)llvm::createScalarizeMaskedMemIntrinLegacyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:157: alloc_fn: Storage is returned from allocation function "createStraightLineStrengthReducePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:157: leaked_storage: Failing to save or free storage allocated by "llvm::createStraightLineStrengthReducePass()" leaks it.
#  155|         (void) llvm::createSpeculativeExecutionPass();
#  156|         (void) llvm::createSpeculativeExecutionIfHasBranchDivergencePass();
#  157|->       (void) llvm::createStraightLineStrengthReducePass();
#  158|         (void)llvm::createScalarizeMaskedMemIntrinLegacyPass();
#  159|         (void) llvm::createHardwareLoopsLegacyPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:158: alloc_fn: Storage is returned from allocation function "createScalarizeMaskedMemIntrinLegacyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:158: leaked_storage: Failing to save or free storage allocated by "llvm::createScalarizeMaskedMemIntrinLegacyPass()" leaks it.
#  156|         (void) llvm::createSpeculativeExecutionIfHasBranchDivergencePass();
#  157|         (void) llvm::createStraightLineStrengthReducePass();
#  158|->       (void)llvm::createScalarizeMaskedMemIntrinLegacyPass();
#  159|         (void) llvm::createHardwareLoopsLegacyPass();
#  160|         (void) llvm::createUnifyLoopExitsPass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:159: alloc_fn: Storage is returned from allocation function "createHardwareLoopsLegacyPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:159: leaked_storage: Failing to save or free storage allocated by "llvm::createHardwareLoopsLegacyPass()" leaks it.
#  157|         (void) llvm::createStraightLineStrengthReducePass();
#  158|         (void)llvm::createScalarizeMaskedMemIntrinLegacyPass();
#  159|->       (void) llvm::createHardwareLoopsLegacyPass();
#  160|         (void) llvm::createUnifyLoopExitsPass();
#  161|         (void) llvm::createFixIrreduciblePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:160: alloc_fn: Storage is returned from allocation function "createUnifyLoopExitsPass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:160: leaked_storage: Failing to save or free storage allocated by "llvm::createUnifyLoopExitsPass()" leaks it.
#  158|         (void)llvm::createScalarizeMaskedMemIntrinLegacyPass();
#  159|         (void) llvm::createHardwareLoopsLegacyPass();
#  160|->       (void) llvm::createUnifyLoopExitsPass();
#  161|         (void) llvm::createFixIrreduciblePass();
#  162|         (void)llvm::createSelectOptimizePass();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:161: alloc_fn: Storage is returned from allocation function "createFixIrreduciblePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:161: leaked_storage: Failing to save or free storage allocated by "llvm::createFixIrreduciblePass()" leaks it.
#  159|         (void) llvm::createHardwareLoopsLegacyPass();
#  160|         (void) llvm::createUnifyLoopExitsPass();
#  161|->       (void) llvm::createFixIrreduciblePass();
#  162|         (void)llvm::createSelectOptimizePass();
#  163|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:162: alloc_fn: Storage is returned from allocation function "createSelectOptimizePass".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:162: leaked_storage: Failing to save or free storage allocated by "llvm::createSelectOptimizePass()" leaks it.
#  160|         (void) llvm::createUnifyLoopExitsPass();
#  161|         (void) llvm::createFixIrreduciblePass();
#  162|->       (void)llvm::createSelectOptimizePass();
#  163|   
#  164|         (void)new llvm::IntervalPartition();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:164: alloc_fn: Storage is returned from allocation function "operator new".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:164: leaked_storage: Failing to save or free storage allocated by "new llvm::IntervalPartition" leaks it.
#  162|         (void)llvm::createSelectOptimizePass();
#  163|   
#  164|->       (void)new llvm::IntervalPartition();
#  165|         (void)new llvm::ScalarEvolutionWrapperPass();
#  166|         llvm::Function::Create(nullptr, llvm::GlobalValue::ExternalLinkage)->viewCFGOnly();

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:165: alloc_fn: Storage is returned from allocation function "operator new".
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:165: leaked_storage: Failing to save or free storage allocated by "new llvm::ScalarEvolutionWrapperPass" leaks it.
#  163|   
#  164|         (void)new llvm::IntervalPartition();
#  165|->       (void)new llvm::ScalarEvolutionWrapperPass();
#  166|         llvm::Function::Create(nullptr, llvm::GlobalValue::ExternalLinkage)->viewCFGOnly();
#  167|         llvm::RGPassManager RGM;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:178: constructor_uses_global_object: The constructor of global object "<unnamed>::ForcePassLinking" itself makes use of global object "<unnamed>::ForceSkipUniformRegions" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForcePassLinking" might be created before "<unnamed>::ForceSkipUniformRegions" is available.
#  176|         (void) llvm::sys::RunningOnValgrind();
#  177|       }
#  178|->   } ForcePassLinking; // Force link by creating a global definition.
#  179|   }
#  180|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:178: constructor_uses_global_object: The constructor of global object "<unnamed>::ForcePassLinking" itself makes use of global object "CFGFuncName[abi:cxx11]" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForcePassLinking" might be created before "CFGFuncName[abi:cxx11]" is available.
#  176|         (void) llvm::sys::RunningOnValgrind();
#  177|       }
#  178|->   } ForcePassLinking; // Force link by creating a global definition.
#  179|   }
#  180|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:178: constructor_uses_global_object: The constructor of global object "<unnamed>::ForcePassLinking" itself makes use of global object "DefaultRotationThreshold" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForcePassLinking" might be created before "DefaultRotationThreshold" is available.
#  176|         (void) llvm::sys::RunningOnValgrind();
#  177|       }
#  178|->   } ForcePassLinking; // Force link by creating a global definition.
#  179|   }
#  180|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:178: constructor_uses_global_object: The constructor of global object "<unnamed>::ForcePassLinking" itself makes use of global object "UserBonusInstThreshold" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForcePassLinking" might be created before "UserBonusInstThreshold" is available.
#  176|         (void) llvm::sys::RunningOnValgrind();
#  177|       }
#  178|->   } ForcePassLinking; // Force link by creating a global definition.
#  179|   }
#  180|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/LinkAllPasses.h:178: constructor_uses_global_object: The constructor of global object "<unnamed>::ForcePassLinking" itself makes use of global object "llvm::SetLicmMssaOptCap" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForcePassLinking" might be created before "llvm::SetLicmMssaOptCap" is available.
#  176|         (void) llvm::sys::RunningOnValgrind();
#  177|       }
#  178|->   } ForcePassLinking; // Force link by creating a global definition.
#  179|   }
#  180|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/ProfileData/MemProf.h:103: var_decl: Declaring variable "List".
llvm-17.0.6.src/include/llvm/ProfileData/MemProf.h:107: uninit_use: Using uninitialized value "List". Field "List.InlineElts" is uninitialized.
#  105|   #include "llvm/ProfileData/MIBEntryDef.inc"
#  106|   #undef MIBEntryDef
#  107|->     return List;
#  108|     }
#  109|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/Support/Errno.h:37: open_fn: Returning handle opened by "operator ()".
llvm-17.0.6.src/include/llvm/Support/Errno.h:37: var_assign: Assigning: "Res" = handle returned from "F()".
llvm-17.0.6.src/include/llvm/Support/Errno.h:37: overwrite_var: Overwriting handle "Res" in "Res = F()" leaks the handle.
#   35|     do {
#   36|       errno = 0;
#   37|->     Res = F(As...);
#   38|     } while (Res == Fail && errno == EINTR);
#   39|     return Res;

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/include/llvm/Support/Error.h:951: move: "Hs" is moved (indicated by "std::forward(Hs)").
llvm-17.0.6.src/include/llvm/Support/Error.h:951: use_after_move: "Hs" is used after it has been already moved.
#  949|       Error R;
#  950|       for (auto &P : List.Payloads)
#  951|->       R = ErrorList::join(
#  952|             std::move(R),
#  953|             handleErrorImpl(std::move(P), std::forward<HandlerTs>(Hs)...));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Support/FormatVariadic.h:117: var_decl: Declaring variable "Result".
llvm-17.0.6.src/include/llvm/Support/FormatVariadic.h:120: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  118|       raw_svector_ostream Stream(Result);
#  119|       Stream << *this;
#  120|->     return Result;
#  121|     }
#  122|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Support/GenericDomTreeConstruction.h:353: var_decl: Declaring variable "Roots".
llvm-17.0.6.src/include/llvm/Support/GenericDomTreeConstruction.h:358: uninit_use: Using uninitialized value "Roots". Field "Roots.InlineElts" is uninitialized.
#  356|       if (!IsPostDom) {
#  357|         Roots.push_back(GetEntryNode(DT));
#  358|->       return Roots;
#  359|       }
#  360|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Support/GenericDomTreeConstruction.h:353: var_decl: Declaring variable "Roots".
llvm-17.0.6.src/include/llvm/Support/GenericDomTreeConstruction.h:496: uninit_use: Using uninitialized value "Roots". Field "Roots.InlineElts" is uninitialized.
#  494|       LLVM_DEBUG(dbgs() << "\n");
#  495|   
#  496|->     return Roots;
#  497|     }
#  498|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Support/GenericLoopInfo.h:371: var_decl: Declaring variable "PreOrderLoops".
llvm-17.0.6.src/include/llvm/Support/GenericLoopInfo.h:375: uninit_use: Using uninitialized value "PreOrderLoops". Field "PreOrderLoops.InlineElts" is uninitialized.
#  373|       PreOrderLoops.push_back(CurLoop);
#  374|       getInnerLoopsInPreorder(*CurLoop, PreOrderLoops);
#  375|->     return PreOrderLoops;
#  376|     }
#  377|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/include/llvm/Support/PluginLoader.h:35: constructor_uses_global_object: The constructor of global object "llvm::LoadOpt[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::LoadOpt[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|     // This causes operator= above to be invoked for every -load option.
#   34|     static cl::opt<PluginLoader, false, cl::parser<std::string>>
#   35|->       LoadOpt("load", cl::value_desc("pluginfilename"),
#   36|                 cl::desc("Load the specified plugin"));
#   37|   #endif

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/include/llvm/Support/thread.h:134: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/include/llvm/Support/thread.h:134: leaked_storage: Ignoring storage allocated by "Callee.release()" leaks it.
#  132|                                          StackSizeInBytes);
#  133|     if (Thread != native_handle_type())
#  134|->     Callee.release();
#  135|   }
#  136|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:200: var_decl: Declaring variable "Result".
llvm-17.0.6.src/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:216: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  214|       }
#  215|   
#  216|->     return Result;
#  217|     }
#  218|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysis.cpp:66: constructor_uses_global_object: The constructor of global object "llvm::DisableBasicAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DisableBasicAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   64|   /// Allow disabling BasicAA from the AA results. This is particularly useful
#   65|   /// when testing to isolate a single AA implementation.
#   66|-> cl::opt<bool> DisableBasicAA("disable-basic-aa", cl::Hidden, cl::init(false));
#   67|   } // namespace llvm
#   68|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:23: constructor_uses_global_object: The constructor of global object "PrintAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   using namespace llvm;
#   22|   
#   23|-> static cl::opt<bool> PrintAll("print-all-alias-modref-info", cl::ReallyHidden);
#   24|   
#   25|   static cl::opt<bool> PrintNoAlias("print-no-aliases", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:25: constructor_uses_global_object: The constructor of global object "PrintNoAlias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintNoAlias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   23|   static cl::opt<bool> PrintAll("print-all-alias-modref-info", cl::ReallyHidden);
#   24|   
#   25|-> static cl::opt<bool> PrintNoAlias("print-no-aliases", cl::ReallyHidden);
#   26|   static cl::opt<bool> PrintMayAlias("print-may-aliases", cl::ReallyHidden);
#   27|   static cl::opt<bool> PrintPartialAlias("print-partial-aliases", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:26: constructor_uses_global_object: The constructor of global object "PrintMayAlias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintMayAlias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   
#   25|   static cl::opt<bool> PrintNoAlias("print-no-aliases", cl::ReallyHidden);
#   26|-> static cl::opt<bool> PrintMayAlias("print-may-aliases", cl::ReallyHidden);
#   27|   static cl::opt<bool> PrintPartialAlias("print-partial-aliases", cl::ReallyHidden);
#   28|   static cl::opt<bool> PrintMustAlias("print-must-aliases", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:27: constructor_uses_global_object: The constructor of global object "PrintPartialAlias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintPartialAlias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   static cl::opt<bool> PrintNoAlias("print-no-aliases", cl::ReallyHidden);
#   26|   static cl::opt<bool> PrintMayAlias("print-may-aliases", cl::ReallyHidden);
#   27|-> static cl::opt<bool> PrintPartialAlias("print-partial-aliases", cl::ReallyHidden);
#   28|   static cl::opt<bool> PrintMustAlias("print-must-aliases", cl::ReallyHidden);
#   29|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:28: constructor_uses_global_object: The constructor of global object "PrintMustAlias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintMustAlias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   static cl::opt<bool> PrintMayAlias("print-may-aliases", cl::ReallyHidden);
#   27|   static cl::opt<bool> PrintPartialAlias("print-partial-aliases", cl::ReallyHidden);
#   28|-> static cl::opt<bool> PrintMustAlias("print-must-aliases", cl::ReallyHidden);
#   29|   
#   30|   static cl::opt<bool> PrintNoModRef("print-no-modref", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:30: constructor_uses_global_object: The constructor of global object "PrintNoModRef" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintNoModRef" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   static cl::opt<bool> PrintMustAlias("print-must-aliases", cl::ReallyHidden);
#   29|   
#   30|-> static cl::opt<bool> PrintNoModRef("print-no-modref", cl::ReallyHidden);
#   31|   static cl::opt<bool> PrintRef("print-ref", cl::ReallyHidden);
#   32|   static cl::opt<bool> PrintMod("print-mod", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:31: constructor_uses_global_object: The constructor of global object "PrintRef" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintRef" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   
#   30|   static cl::opt<bool> PrintNoModRef("print-no-modref", cl::ReallyHidden);
#   31|-> static cl::opt<bool> PrintRef("print-ref", cl::ReallyHidden);
#   32|   static cl::opt<bool> PrintMod("print-mod", cl::ReallyHidden);
#   33|   static cl::opt<bool> PrintModRef("print-modref", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:32: constructor_uses_global_object: The constructor of global object "PrintMod" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintMod" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   static cl::opt<bool> PrintNoModRef("print-no-modref", cl::ReallyHidden);
#   31|   static cl::opt<bool> PrintRef("print-ref", cl::ReallyHidden);
#   32|-> static cl::opt<bool> PrintMod("print-mod", cl::ReallyHidden);
#   33|   static cl::opt<bool> PrintModRef("print-modref", cl::ReallyHidden);
#   34|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:33: constructor_uses_global_object: The constructor of global object "PrintModRef" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintModRef" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   static cl::opt<bool> PrintRef("print-ref", cl::ReallyHidden);
#   32|   static cl::opt<bool> PrintMod("print-mod", cl::ReallyHidden);
#   33|-> static cl::opt<bool> PrintModRef("print-modref", cl::ReallyHidden);
#   34|   
#   35|   static cl::opt<bool> EvalAAMD("evaluate-aa-metadata", cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasAnalysisEvaluator.cpp:35: constructor_uses_global_object: The constructor of global object "EvalAAMD" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EvalAAMD" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   static cl::opt<bool> PrintModRef("print-modref", cl::ReallyHidden);
#   34|   
#   35|-> static cl::opt<bool> EvalAAMD("evaluate-aa-metadata", cl::ReallyHidden);
#   36|   
#   37|   static void PrintResults(AliasResult AR, bool P,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AliasSetTracker.cpp:38: constructor_uses_global_object: The constructor of global object "SaturationThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SaturationThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   
#   37|   static cl::opt<unsigned>
#   38|->     SaturationThreshold("alias-set-saturation-threshold", cl::Hidden,
#   39|                           cl::init(250),
#   40|                           cl::desc("The maximum number of pointers may-alias "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/AssumptionCache.cpp:40: constructor_uses_global_object: The constructor of global object "VerifyAssumptionCache" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyAssumptionCache" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   
#   39|   static cl::opt<bool>
#   40|->     VerifyAssumptionCache("verify-assumption-cache", cl::Hidden,
#   41|                             cl::desc("Enable verification of assumption cache"),
#   42|                             cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:68: constructor_uses_global_object: The constructor of global object "EnableRecPhiAnalysis" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRecPhiAnalysis" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|   
#   67|   /// Enable analysis of recursive PHI nodes.
#   68|-> static cl::opt<bool> EnableRecPhiAnalysis("basic-aa-recphi", cl::Hidden,
#   69|                                             cl::init(true));
#   70|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:71: constructor_uses_global_object: The constructor of global object "EnableSeparateStorageAnalysis" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSeparateStorageAnalysis" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|                                             cl::init(true));
#   70|   
#   71|-> static cl::opt<bool> EnableSeparateStorageAnalysis("basic-aa-separate-storage",
#   72|                                                      cl::Hidden, cl::init(false));
#   73|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:538: var_decl: Declaring variable "Decomposed".
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:552: uninit_use: Using uninitialized value "Decomposed". Field "Decomposed.VarIndices.InlineElts" is uninitialized.
#  550|         }
#  551|         Decomposed.Base = V;
#  552|->       return Decomposed;
#  553|       }
#  554|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:538: var_decl: Declaring variable "Decomposed".
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:586: uninit_use: Using uninitialized value "Decomposed". Field "Decomposed.VarIndices.InlineElts" is uninitialized.
#  584|   
#  585|         Decomposed.Base = V;
#  586|->       return Decomposed;
#  587|       }
#  588|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:538: var_decl: Declaring variable "Decomposed".
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:627: uninit_use: Using uninitialized value "Decomposed". Field "Decomposed.VarIndices.InlineElts" is uninitialized.
#  625|           if (AllocTypeSize.isScalable()) {
#  626|             Decomposed.Base = V;
#  627|->           return Decomposed;
#  628|           }
#  629|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:538: var_decl: Declaring variable "Decomposed".
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:638: uninit_use: Using uninitialized value "Decomposed". Field "Decomposed.VarIndices.InlineElts" is uninitialized.
#  636|         if (AllocTypeSize.isScalable()) {
#  637|           Decomposed.Base = V;
#  638|->         return Decomposed;
#  639|         }
#  640|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:538: var_decl: Declaring variable "Decomposed".
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:692: uninit_use: Using uninitialized value "Decomposed". Field "Decomposed.VarIndices.InlineElts" is uninitialized.
#  690|     Decomposed.Base = V;
#  691|     SearchLimitReached++;
#  692|->   return Decomposed;
#  693|   }
#  694|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:1058: tainted_data_return: Called function "V2Size.getValue()", and a possible return value is known to be less than zero.
llvm-17.0.6.src/lib/Analysis/BasicAliasAnalysis.cpp:1058: underflow: The cast of "V2Size.getValue()" to a signed type could result in a negative number.
# 1056|     // If an inbounds GEP would have to start from an out of bounds address
# 1057|     // for the two to alias, then we can assume noalias.
# 1058|->   if (*DecompGEP1.InBounds && DecompGEP1.VarIndices.empty() &&
# 1059|         V2Size.hasValue() && DecompGEP1.Offset.sge(V2Size.getValue()) &&
# 1060|         isBaseOfObject(DecompGEP2.Base))

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfo.cpp:35: constructor_uses_global_object: The constructor of global object "ViewBlockFreqPropagationDAG" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ViewBlockFreqPropagationDAG" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   #define DEBUG_TYPE "block-freq"
#   34|   
#   35|-> static cl::opt<GVDAGType> ViewBlockFreqPropagationDAG(
#   36|       "view-block-freq-propagation-dags", cl::Hidden,
#   37|       cl::desc("Pop up a window to show a dag displaying how block "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfo.cpp:51: constructor_uses_global_object: The constructor of global object "llvm::ViewBlockFreqFuncName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ViewBlockFreqFuncName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|   namespace llvm {
#   50|   cl::opt<std::string>
#   51|->     ViewBlockFreqFuncName("view-bfi-func-name", cl::Hidden,
#   52|                             cl::desc("The option to specify "
#   53|                                      "the name of the function "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfo.cpp:57: constructor_uses_global_object: The constructor of global object "llvm::ViewHotFreqPercent" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ViewHotFreqPercent" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|   
#   56|   cl::opt<unsigned>
#   57|->     ViewHotFreqPercent("view-hot-freq-percent", cl::init(10), cl::Hidden,
#   58|                          cl::desc("An integer in percent used to specify "
#   59|                                   "the hot blocks/edges to be displayed "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfo.cpp:65: constructor_uses_global_object: The constructor of global object "llvm::PGOViewCounts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PGOViewCounts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   
#   64|   // Command line option to turn on CFG dot or text dump after profile annotation.
#   65|-> cl::opt<PGOViewCountsType> PGOViewCounts(
#   66|       "pgo-view-counts", cl::Hidden,
#   67|       cl::desc("A boolean option to show CFG dag or text with "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfo.cpp:81: constructor_uses_global_object: The constructor of global object "llvm::PrintBlockFreq" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PrintBlockFreq" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   79|                  clEnumValN(PGOVCT_Text, "text", "show in text.")));
#   80|   
#   81|-> static cl::opt<bool> PrintBlockFreq(
#   82|       "print-bfi", cl::init(false), cl::Hidden,
#   83|       cl::desc("Print the block frequency info."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfo.cpp:85: constructor_uses_global_object: The constructor of global object "llvm::PrintBlockFreqFuncName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PrintBlockFreqFuncName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|       cl::desc("Print the block frequency info."));
#   84|   
#   85|-> cl::opt<std::string> PrintBlockFreqFuncName(
#   86|       "print-bfi-func-name", cl::Hidden,
#   87|       cl::desc("The option to specify the name of the function "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfoImpl.cpp:44: constructor_uses_global_object: The constructor of global object "llvm::CheckBFIUnknownBlockQueries" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::CheckBFIUnknownBlockQueries" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   
#   43|   namespace llvm {
#   44|-> cl::opt<bool> CheckBFIUnknownBlockQueries(
#   45|       "check-bfi-unknown-block-queries",
#   46|       cl::init(false), cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfoImpl.cpp:50: constructor_uses_global_object: The constructor of global object "llvm::UseIterativeBFIInference" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::UseIterativeBFIInference" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|                "for debugging missed BFI updates"));
#   49|   
#   50|-> cl::opt<bool> UseIterativeBFIInference(
#   51|       "use-iterative-bfi-inference", cl::Hidden,
#   52|       cl::desc("Apply an iterative post-processing to infer correct BFI counts"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfoImpl.cpp:54: constructor_uses_global_object: The constructor of global object "llvm::IterativeBFIMaxIterationsPerBlock" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::IterativeBFIMaxIterationsPerBlock" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|       cl::desc("Apply an iterative post-processing to infer correct BFI counts"));
#   53|   
#   54|-> cl::opt<unsigned> IterativeBFIMaxIterationsPerBlock(
#   55|       "iterative-bfi-max-iterations-per-block", cl::init(1000), cl::Hidden,
#   56|       cl::desc("Iterative inference: maximum number of update iterations "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BlockFrequencyInfoImpl.cpp:59: constructor_uses_global_object: The constructor of global object "llvm::IterativeBFIPrecision" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::IterativeBFIPrecision" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|                "per block"));
#   58|   
#   59|-> cl::opt<double> IterativeBFIPrecision(
#   60|       "iterative-bfi-precision", cl::init(1e-12), cl::Hidden,
#   61|       cl::desc("Iterative inference: delta convergence precision; smaller values "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BranchProbabilityInfo.cpp:54: constructor_uses_global_object: The constructor of global object "PrintBranchProb" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintBranchProb" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   #define DEBUG_TYPE "branch-prob"
#   53|   
#   54|-> static cl::opt<bool> PrintBranchProb(
#   55|       "print-bpi", cl::init(false), cl::Hidden,
#   56|       cl::desc("Print the branch probability info."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/BranchProbabilityInfo.cpp:58: constructor_uses_global_object: The constructor of global object "PrintBranchProbFuncName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintBranchProbFuncName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|       cl::desc("Print the branch probability info."));
#   57|   
#   58|-> cl::opt<std::string> PrintBranchProbFuncName(
#   59|       "print-bpi-func-name", cl::Hidden,
#   60|       cl::desc("The option to specify the name of the function "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFG.cpp:24: constructor_uses_global_object: The constructor of global object "DefaultMaxBBsToExplore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DefaultMaxBBsToExplore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   22|   // two basic blocks. This is kept reasonably small to limit compile time when
#   23|   // repeatedly used by clients of this analysis (such as captureTracking).
#   24|-> static cl::opt<unsigned> DefaultMaxBBsToExplore(
#   25|       "dom-tree-reachability-max-bbs-to-explore", cl::Hidden,
#   26|       cl::desc("Max number of BBs to explore for reachability analysis"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:31: constructor_uses_global_object: The constructor of global object "CFGFuncName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CFGFuncName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   
#   30|   static cl::opt<std::string>
#   31|->     CFGFuncName("cfg-func-name", cl::Hidden,
#   32|                   cl::desc("The name of a function (or its substring)"
#   33|                            " whose CFG is viewed/printed."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:35: constructor_uses_global_object: The constructor of global object "CFGDotFilenamePrefix[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CFGDotFilenamePrefix[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|                            " whose CFG is viewed/printed."));
#   34|   
#   35|-> static cl::opt<std::string> CFGDotFilenamePrefix(
#   36|       "cfg-dot-filename-prefix", cl::Hidden,
#   37|       cl::desc("The prefix used for the CFG dot file names."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:39: constructor_uses_global_object: The constructor of global object "HideUnreachablePaths" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HideUnreachablePaths" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|       cl::desc("The prefix used for the CFG dot file names."));
#   38|   
#   39|-> static cl::opt<bool> HideUnreachablePaths("cfg-hide-unreachable-paths",
#   40|                                             cl::init(false));
#   41|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:42: constructor_uses_global_object: The constructor of global object "HideDeoptimizePaths" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HideDeoptimizePaths" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|                                             cl::init(false));
#   41|   
#   42|-> static cl::opt<bool> HideDeoptimizePaths("cfg-hide-deoptimize-paths",
#   43|                                            cl::init(false));
#   44|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:45: constructor_uses_global_object: The constructor of global object "HideColdPaths" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HideColdPaths" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|                                            cl::init(false));
#   44|   
#   45|-> static cl::opt<double> HideColdPaths(
#   46|       "cfg-hide-cold-paths", cl::init(0.0),
#   47|       cl::desc("Hide blocks with relative frequency below the given value"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:49: constructor_uses_global_object: The constructor of global object "ShowHeatColors" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ShowHeatColors" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|       cl::desc("Hide blocks with relative frequency below the given value"));
#   48|   
#   49|-> static cl::opt<bool> ShowHeatColors("cfg-heat-colors", cl::init(true),
#   50|                                       cl::Hidden,
#   51|                                       cl::desc("Show heat colors in CFG"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:53: constructor_uses_global_object: The constructor of global object "UseRawEdgeWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseRawEdgeWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|                                       cl::desc("Show heat colors in CFG"));
#   52|   
#   53|-> static cl::opt<bool> UseRawEdgeWeight("cfg-raw-weights", cl::init(false),
#   54|                                         cl::Hidden,
#   55|                                         cl::desc("Use raw weights for labels. "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CFGPrinter.cpp:59: constructor_uses_global_object: The constructor of global object "ShowEdgeWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ShowEdgeWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|   
#   58|   static cl::opt<bool>
#   59|->     ShowEdgeWeight("cfg-weights", cl::init(false), cl::Hidden,
#   60|                      cl::desc("Show edges labeled with weights"));
#   61|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CGSCCPassManager.cpp:41: constructor_uses_global_object: The constructor of global object "llvm::AbortOnMaxDevirtIterationsReached" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::AbortOnMaxDevirtIterationsReached" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   // template typedefs.
#   40|   namespace llvm {
#   41|-> static cl::opt<bool> AbortOnMaxDevirtIterationsReached(
#   42|       "abort-on-max-devirt-iterations-reached",
#   43|       cl::desc("Abort when the max iterations for devirtualization CGSCC repeat "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/CGSCCPassManager.cpp:377: var_decl: Declaring variable "CallCounts".
llvm-17.0.6.src/lib/Analysis/CGSCCPassManager.cpp:394: uninit_use: Using uninitialized value "CallCounts". Field "CallCounts.NumEntries" is uninitialized.
#  392|       }
#  393|   
#  394|->     return CallCounts;
#  395|     };
#  396|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CallGraphSCCPass.cpp:47: constructor_uses_global_object: The constructor of global object "llvm::MaxDevirtIterations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::MaxDevirtIterations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   
#   46|   namespace llvm {
#   47|-> cl::opt<unsigned> MaxDevirtIterations("max-devirt-iterations", cl::ReallyHidden,
#   48|                                         cl::init(4));
#   49|   }

Error: USE_AFTER_FREE (CWE-416):
llvm-17.0.6.src/lib/Analysis/CallGraphSCCPass.cpp:638: assign: Assigning: "P" = "CGP".
llvm-17.0.6.src/lib/Analysis/CallGraphSCCPass.cpp:639: freed_arg: "schedulePass" frees "P".
llvm-17.0.6.src/lib/Analysis/CallGraphSCCPass.cpp:642: deref_arg: Calling "push" dereferences freed pointer "CGP".
#  640|   
#  641|       // [4] Push new manager into PMS
#  642|->     PMS.push(CGP);
#  643|     }
#  644|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CallPrinter.cpp:37: constructor_uses_global_object: The constructor of global object "ShowHeatColors" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ShowHeatColors" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|   // FIXME:
#   36|   // Need to show real counts when profile data is available
#   37|-> static cl::opt<bool> ShowHeatColors("callgraph-heat-colors", cl::init(false),
#   38|                                       cl::Hidden,
#   39|                                       cl::desc("Show heat colors in call-graph"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CallPrinter.cpp:42: constructor_uses_global_object: The constructor of global object "ShowEdgeWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ShowEdgeWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|   
#   41|   static cl::opt<bool>
#   42|->     ShowEdgeWeight("callgraph-show-weights", cl::init(false), cl::Hidden,
#   43|                          cl::desc("Show edges labeled with weights"));
#   44|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CallPrinter.cpp:46: constructor_uses_global_object: The constructor of global object "CallMultiGraph" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CallMultiGraph" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   
#   45|   static cl::opt<bool>
#   46|->     CallMultiGraph("callgraph-multigraph", cl::init(false), cl::Hidden,
#   47|               cl::desc("Show call-multigraph (do not remove parallel edges)"));
#   48|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CallPrinter.cpp:49: constructor_uses_global_object: The constructor of global object "CallGraphDotFilenamePrefix[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CallGraphDotFilenamePrefix[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|               cl::desc("Show call-multigraph (do not remove parallel edges)"));
#   48|   
#   49|-> static cl::opt<std::string> CallGraphDotFilenamePrefix(
#   50|       "callgraph-dot-filename-prefix", cl::Hidden,
#   51|       cl::desc("The prefix used for the CallGraph dot file names."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CaptureTracking.cpp:48: constructor_uses_global_object: The constructor of global object "DefaultMaxUsesToExplore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DefaultMaxUsesToExplore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   /// don't have this cap at all.
#   47|   static cl::opt<unsigned>
#   48|->     DefaultMaxUsesToExplore("capture-tracking-max-uses-to-explore", cl::Hidden,
#   49|                               cl::desc("Maximal number of uses to explore."),
#   50|                               cl::init(100));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:1748: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(V)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:1748: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1746|     }
# 1747|     if (Ty->isDoubleTy())
# 1748|->     return ConstantFP::get(Ty->getContext(), APFloat(V));
# 1749|     llvm_unreachable("Can only constant fold half/float/double");
# 1750|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:2151: var_decl: Declaring variable "AlmostOne".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:2152: uninit_use_in_call: Using uninitialized value "AlmostOne.U" when calling "next".
# 2150|         APFloat FractU(U - FloorU);
# 2151|         APFloat AlmostOne(U.getSemantics(), 1);
# 2152|->       AlmostOne.next(/*nextDown*/ true);
# 2153|         return ConstantFP::get(Ty->getContext(), minimum(FractU, AlmostOne));
# 2154|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:2229: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(2.)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:2229: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2227|         case Intrinsic::exp2:
# 2228|           // Fold exp2(x) as pow(2, x), in case the host lacks a C99 library.
# 2229|->         return ConstantFoldBinaryFP(pow, APFloat(2.0), APF, Ty);
# 2230|         case Intrinsic::sin:
# 2231|           return ConstantFoldFP(sin, APF, Ty);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:2321: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(2.)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:2321: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2319|         if (TLI->has(Func))
# 2320|           // Fold exp2(x) as pow(2, x), in case the host lacks a C99 library.
# 2321|->         return ConstantFoldBinaryFP(pow, APFloat(2.0), APF, Ty);
# 2322|         break;
# 2323|       case LibFunc_fabs:

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3038: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0f)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3038: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3036|               // It's tempting to just return C3 here, but that would give the
# 3037|               // wrong result if C3 was -0.0.
# 3038|->             return ConstantFP::get(Ty->getContext(), APFloat(0.0f) + C3);
# 3039|             }
# 3040|             [[fallthrough]];

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3423: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(709.)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3423: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3421|           // FIXME: These boundaries are slightly conservative.
# 3422|           if (OpC->getType()->isDoubleTy())
# 3423|->           return !(Op < APFloat(-745.0) || Op > APFloat(709.0));
# 3424|           if (OpC->getType()->isFloatTy())
# 3425|             return !(Op < APFloat(-103.0f) || Op > APFloat(88.0f));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3425: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(88f)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3425: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3423|             return !(Op < APFloat(-745.0) || Op > APFloat(709.0));
# 3424|           if (OpC->getType()->isFloatTy())
# 3425|->           return !(Op < APFloat(-103.0f) || Op > APFloat(88.0f));
# 3426|           break;
# 3427|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3433: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1023.)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3433: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3431|           // FIXME: These boundaries are slightly conservative.
# 3432|           if (OpC->getType()->isDoubleTy())
# 3433|->           return !(Op < APFloat(-1074.0) || Op > APFloat(1023.0));
# 3434|           if (OpC->getType()->isFloatTy())
# 3435|             return !(Op < APFloat(-149.0f) || Op > APFloat(127.0f));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3435: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(127f)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3435: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3433|             return !(Op < APFloat(-1074.0) || Op > APFloat(1023.0));
# 3434|           if (OpC->getType()->isFloatTy())
# 3435|->           return !(Op < APFloat(-149.0f) || Op > APFloat(127.0f));
# 3436|           break;
# 3437|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3481: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(710.)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3481: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3479|           // FIXME: These boundaries are slightly conservative.
# 3480|           if (OpC->getType()->isDoubleTy())
# 3481|->           return !(Op < APFloat(-710.0) || Op > APFloat(710.0));
# 3482|           if (OpC->getType()->isFloatTy())
# 3483|             return !(Op < APFloat(-89.0f) || Op > APFloat(89.0f));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3483: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(89f)".
llvm-17.0.6.src/lib/Analysis/ConstantFolding.cpp:3483: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3481|             return !(Op < APFloat(-710.0) || Op > APFloat(710.0));
# 3482|           if (OpC->getType()->isFloatTy())
# 3483|->           return !(Op < APFloat(-89.0f) || Op > APFloat(89.0f));
# 3484|           break;
# 3485|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CostModel.cpp:31: constructor_uses_global_object: The constructor of global object "CostKind" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CostKind" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   using namespace llvm;
#   30|   
#   31|-> static cl::opt<TargetTransformInfo::TargetCostKind> CostKind(
#   32|       "cost-kind", cl::desc("Target cost kind"),
#   33|       cl::init(TargetTransformInfo::TCK_RecipThroughput),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/CostModel.cpp:43: constructor_uses_global_object: The constructor of global object "TypeBasedIntrinsicCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TypeBasedIntrinsicCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|                             "size-latency", "Code size and latency")));
#   42|   
#   43|-> static cl::opt<bool> TypeBasedIntrinsicCost("type-based-intrinsic-cost",
#   44|       cl::desc("Calculate intrinsics cost based only on argument types"),
#   45|       cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DDG.cpp:19: constructor_uses_global_object: The constructor of global object "SimplifyDDG" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SimplifyDDG" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   17|   using namespace llvm;
#   18|   
#   19|-> static cl::opt<bool> SimplifyDDG(
#   20|       "ddg-simplify", cl::init(true), cl::Hidden,
#   21|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DDG.cpp:24: constructor_uses_global_object: The constructor of global object "CreatePiBlocks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CreatePiBlocks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   22|           "Simplify DDG by merging nodes that have less interesting edges."));
#   23|   
#   24|-> static cl::opt<bool> CreatePiBlocks("ddg-pi-blocks", cl::init(true), cl::Hidden,
#   25|                                       cl::desc("Create pi-block nodes."));
#   26|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/DDG.cpp:310: var_decl: Declaring variable "DI".
llvm-17.0.6.src/lib/Analysis/DDG.cpp:311: uninit_use_in_call: Using uninitialized value "DI". Field "DI.CommonLevels" is uninitialized when calling "make_unique".
#  309|     Function *F = L.getHeader()->getParent();
#  310|     DependenceInfo DI(F, &AR.AA, &AR.SE, &AR.LI);
#  311|->   return std::make_unique<DataDependenceGraph>(L, AR.LI, DI);
#  312|   }
#  313|   AnalysisKey DDGAnalysis::Key;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DDGPrinter.cpp:21: constructor_uses_global_object: The constructor of global object "DotOnly" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DotOnly" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   19|   using namespace llvm;
#   20|   
#   21|-> static cl::opt<bool> DotOnly("dot-ddg-only", cl::Hidden,
#   22|                                cl::desc("simple ddg dot graph"));
#   23|   static cl::opt<std::string> DDGDotFilenamePrefix(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DDGPrinter.cpp:23: constructor_uses_global_object: The constructor of global object "DDGDotFilenamePrefix[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DDGDotFilenamePrefix[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   static cl::opt<bool> DotOnly("dot-ddg-only", cl::Hidden,
#   22|                                cl::desc("simple ddg dot graph"));
#   23|-> static cl::opt<std::string> DDGDotFilenamePrefix(
#   24|       "dot-ddg-filename-prefix", cl::init("ddg"), cl::Hidden,
#   25|       cl::desc("The prefix used for the DDG dot file names."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DependenceAnalysis.cpp:109: constructor_uses_global_object: The constructor of global object "Delinearize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Delinearize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  107|   
#  108|   static cl::opt<bool>
#  109|->     Delinearize("da-delinearize", cl::init(true), cl::Hidden,
#  110|                   cl::desc("Try to delinearize array references."));
#  111|   static cl::opt<bool> DisableDelinearizationChecks(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DependenceAnalysis.cpp:111: constructor_uses_global_object: The constructor of global object "DisableDelinearizationChecks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableDelinearizationChecks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  109|       Delinearize("da-delinearize", cl::init(true), cl::Hidden,
#  110|                   cl::desc("Try to delinearize array references."));
#  111|-> static cl::opt<bool> DisableDelinearizationChecks(
#  112|       "da-disable-delinearization-checks", cl::Hidden,
#  113|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/DependenceAnalysis.cpp:119: constructor_uses_global_object: The constructor of global object "MIVMaxLevelThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MIVMaxLevelThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|           "dimension to underflow or overflow into another dimension."));
#  118|   
#  119|-> static cl::opt<unsigned> MIVMaxLevelThreshold(
#  120|       "da-miv-max-level-threshold", cl::init(7), cl::Hidden,
#  121|       cl::desc("Maximum depth allowed for the recursive algorithm used to "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/GlobalsModRef.cpp:54: constructor_uses_global_object: The constructor of global object "EnableUnsafeGlobalsModRefAliasResults" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableUnsafeGlobalsModRefAliasResults" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   // sensitivity and no known issues. The option also makes it easy to evaluate
#   53|   // the performance impact of these results.
#   54|-> static cl::opt<bool> EnableUnsafeGlobalsModRefAliasResults(
#   55|       "enable-unsafe-globalsmodref-alias-results", cl::init(false), cl::Hidden);
#   56|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IRSimilarityIdentifier.cpp:29: constructor_uses_global_object: The constructor of global object "llvm::DisableBranches" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DisableBranches" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|   namespace llvm {
#   28|   cl::opt<bool>
#   29|->     DisableBranches("no-ir-sim-branch-matching", cl::init(false),
#   30|                       cl::ReallyHidden,
#   31|                       cl::desc("disable similarity matching, and outlining, "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IRSimilarityIdentifier.cpp:35: constructor_uses_global_object: The constructor of global object "llvm::DisableIndirectCalls" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DisableIndirectCalls" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   cl::opt<bool>
#   35|->     DisableIndirectCalls("no-ir-sim-indirect-calls", cl::init(false),
#   36|                            cl::ReallyHidden,
#   37|                            cl::desc("disable outlining indirect calls."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IRSimilarityIdentifier.cpp:40: constructor_uses_global_object: The constructor of global object "llvm::MatchCallsByName" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::MatchCallsByName" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   
#   39|   cl::opt<bool>
#   40|->     MatchCallsByName("ir-sim-calls-by-name", cl::init(false), cl::ReallyHidden,
#   41|                        cl::desc("only allow matching call instructions if the "
#   42|                                 "name and type signature match."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IRSimilarityIdentifier.cpp:45: constructor_uses_global_object: The constructor of global object "llvm::DisableIntrinsics" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DisableIntrinsics" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|   
#   44|   cl::opt<bool>
#   45|->     DisableIntrinsics("no-ir-sim-intrinsics", cl::init(false), cl::ReallyHidden,
#   46|                         cl::desc("Don't match or outline intrinsics"));
#   47|   } // namespace llvm

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/IRSimilarityIdentifier.cpp:1030: var_decl: Declaring variable "ResultGVN" without initializer.
llvm-17.0.6.src/lib/Analysis/IRSimilarityIdentifier.cpp:1062: uninit_use_in_call: Using uninitialized value "ResultGVN" when calling "insert".
# 1060|   
# 1061|       // Whatever GVN is found, we mark it as used.
# 1062|->     UsedGVNs.insert(ResultGVN);
# 1063|   
# 1064|       unsigned CanonNum = *SourceCand.getCanonicalNum(ResultGVN);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ImportedFunctionsInliningStatistics.cpp:27: constructor_uses_global_object: The constructor of global object "llvm::InlinerFunctionImportStats" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::InlinerFunctionImportStats" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   
#   26|   namespace llvm {
#   27|-> cl::opt<InlinerFunctionImportStatsOpts> InlinerFunctionImportStats(
#   28|       "inliner-function-import-stats",
#   29|       cl::init(InlinerFunctionImportStatsOpts::No),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IndirectCallPromotionAnalysis.cpp:28: constructor_uses_global_object: The constructor of global object "ICPRemainingPercentThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ICPRemainingPercentThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   // The percent threshold for the direct-call target (this call site vs the
#   27|   // remaining call count) for it to be considered as the promotion target.
#   28|-> static cl::opt<unsigned> ICPRemainingPercentThreshold(
#   29|       "icp-remaining-percent-threshold", cl::init(30), cl::Hidden,
#   30|       cl::desc("The percentage threshold against remaining unpromoted indirect "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IndirectCallPromotionAnalysis.cpp:36: constructor_uses_global_object: The constructor of global object "ICPTotalPercentThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ICPTotalPercentThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   // total call count) for it to be considered as the promotion target.
#   35|   static cl::opt<unsigned>
#   36|->     ICPTotalPercentThreshold("icp-total-percent-threshold", cl::init(5),
#   37|                                cl::Hidden,
#   38|                                cl::desc("The percentage threshold against total "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/IndirectCallPromotionAnalysis.cpp:44: constructor_uses_global_object: The constructor of global object "MaxNumPromotions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxNumPromotions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   // callsite.
#   43|   static cl::opt<unsigned>
#   44|->     MaxNumPromotions("icp-max-prom", cl::init(3), cl::Hidden,
#   45|                        cl::desc("Max number of promotions for a single indirect "
#   46|                                 "call callsite"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineAdvisor.cpp:43: constructor_uses_global_object: The constructor of global object "InlineRemarkAttribute" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineRemarkAttribute" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   /// Flag to add inline messages as callsite attributes 'inline-remark'.
#   42|   static cl::opt<bool>
#   43|->     InlineRemarkAttribute("inline-remark-attribute", cl::init(false),
#   44|                             cl::Hidden,
#   45|                             cl::desc("Enable adding inline-remark attribute to"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineAdvisor.cpp:49: constructor_uses_global_object: The constructor of global object "EnableInlineDeferral" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableInlineDeferral" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|                                      " to be not inlined"));
#   48|   
#   49|-> static cl::opt<bool> EnableInlineDeferral("inline-deferral", cl::init(false),
#   50|                                             cl::Hidden,
#   51|                                             cl::desc("Enable deferred inlining"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineAdvisor.cpp:56: constructor_uses_global_object: The constructor of global object "InlineDeferralScale" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineDeferralScale" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   // number tells shouldBeDeferred to only take the secondary cost into account.
#   55|   static cl::opt<int>
#   56|->     InlineDeferralScale("inline-deferral-scale",
#   57|                           cl::desc("Scale to limit the cost of inline deferral"),
#   58|                           cl::init(2), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineAdvisor.cpp:61: constructor_uses_global_object: The constructor of global object "AnnotateInlinePhase" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AnnotateInlinePhase" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   59|   
#   60|   static cl::opt<bool>
#   61|->     AnnotateInlinePhase("annotate-inline-phase", cl::Hidden, cl::init(false),
#   62|                           cl::desc("If true, annotate inline advisor remarks "
#   63|                                    "with LTO and pass information."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:57: constructor_uses_global_object: The constructor of global object "DefaultThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DefaultThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|   
#   56|   static cl::opt<int>
#   57|->     DefaultThreshold("inlinedefault-threshold", cl::Hidden, cl::init(225),
#   58|                        cl::desc("Default amount of inlining to perform"));
#   59|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:65: constructor_uses_global_object: The constructor of global object "IgnoreTTIInlineCompatible" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IgnoreTTIInlineCompatible" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   // some use cases. If we avoid adding the attribute, we need an option to avoid
#   64|   // checking these attributes.
#   65|-> static cl::opt<bool> IgnoreTTIInlineCompatible(
#   66|       "ignore-tti-inline-compatible", cl::Hidden, cl::init(false),
#   67|       cl::desc("Ignore TTI attributes compatibility check between callee/caller "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:70: constructor_uses_global_object: The constructor of global object "PrintInstructionComments" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintInstructionComments" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|                "during inline cost calculation"));
#   69|   
#   70|-> static cl::opt<bool> PrintInstructionComments(
#   71|       "print-instruction-comments", cl::Hidden, cl::init(false),
#   72|       cl::desc("Prints comments for instruction based on inline cost analysis"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:74: constructor_uses_global_object: The constructor of global object "InlineThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|       cl::desc("Prints comments for instruction based on inline cost analysis"));
#   73|   
#   74|-> static cl::opt<int> InlineThreshold(
#   75|       "inline-threshold", cl::Hidden, cl::init(225),
#   76|       cl::desc("Control the amount of inlining to perform (default = 225)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:78: constructor_uses_global_object: The constructor of global object "HintThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HintThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|       cl::desc("Control the amount of inlining to perform (default = 225)"));
#   77|   
#   78|-> static cl::opt<int> HintThreshold(
#   79|       "inlinehint-threshold", cl::Hidden, cl::init(325),
#   80|       cl::desc("Threshold for inlining functions with inline hint"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:83: constructor_uses_global_object: The constructor of global object "ColdCallSiteThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ColdCallSiteThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   81|   
#   82|   static cl::opt<int>
#   83|->     ColdCallSiteThreshold("inline-cold-callsite-threshold", cl::Hidden,
#   84|                             cl::init(45),
#   85|                             cl::desc("Threshold for inlining cold callsites"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:87: constructor_uses_global_object: The constructor of global object "InlineEnableCostBenefitAnalysis" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineEnableCostBenefitAnalysis" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   85|                             cl::desc("Threshold for inlining cold callsites"));
#   86|   
#   87|-> static cl::opt<bool> InlineEnableCostBenefitAnalysis(
#   88|       "inline-enable-cost-benefit-analysis", cl::Hidden, cl::init(false),
#   89|       cl::desc("Enable the cost-benefit analysis for the inliner"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:91: constructor_uses_global_object: The constructor of global object "InlineSavingsMultiplier" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineSavingsMultiplier" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   89|       cl::desc("Enable the cost-benefit analysis for the inliner"));
#   90|   
#   91|-> static cl::opt<int> InlineSavingsMultiplier(
#   92|       "inline-savings-multiplier", cl::Hidden, cl::init(8),
#   93|       cl::desc("Multiplier to multiply cycle savings by during inlining"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:96: constructor_uses_global_object: The constructor of global object "InlineSizeAllowance" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineSizeAllowance" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   94|   
#   95|   static cl::opt<int>
#   96|->     InlineSizeAllowance("inline-size-allowance", cl::Hidden, cl::init(100),
#   97|                           cl::desc("The maximum size of a callee that get's "
#   98|                                    "inlined without sufficient cycle savings"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:103: constructor_uses_global_object: The constructor of global object "ColdThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ColdThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  101|   // PGO before we actually hook up inliner with analysis passes such as BPI and
#  102|   // BFI.
#  103|-> static cl::opt<int> ColdThreshold(
#  104|       "inlinecold-threshold", cl::Hidden, cl::init(45),
#  105|       cl::desc("Threshold for inlining functions with cold attribute"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:108: constructor_uses_global_object: The constructor of global object "HotCallSiteThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HotCallSiteThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|   
#  107|   static cl::opt<int>
#  108|->     HotCallSiteThreshold("hot-callsite-threshold", cl::Hidden, cl::init(3000),
#  109|                            cl::desc("Threshold for hot callsites "));
#  110|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:111: constructor_uses_global_object: The constructor of global object "LocallyHotCallSiteThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LocallyHotCallSiteThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  109|                            cl::desc("Threshold for hot callsites "));
#  110|   
#  111|-> static cl::opt<int> LocallyHotCallSiteThreshold(
#  112|       "locally-hot-callsite-threshold", cl::Hidden, cl::init(525),
#  113|       cl::desc("Threshold for locally hot callsites "));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:115: constructor_uses_global_object: The constructor of global object "ColdCallSiteRelFreq" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ColdCallSiteRelFreq" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  113|       cl::desc("Threshold for locally hot callsites "));
#  114|   
#  115|-> static cl::opt<int> ColdCallSiteRelFreq(
#  116|       "cold-callsite-rel-freq", cl::Hidden, cl::init(2),
#  117|       cl::desc("Maximum block frequency, expressed as a percentage of caller's "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:121: constructor_uses_global_object: The constructor of global object "HotCallSiteRelFreq" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HotCallSiteRelFreq" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  119|                "profile information."));
#  120|   
#  121|-> static cl::opt<int> HotCallSiteRelFreq(
#  122|       "hot-callsite-rel-freq", cl::Hidden, cl::init(60),
#  123|       cl::desc("Minimum block frequency, expressed as a multiple of caller's "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:128: constructor_uses_global_object: The constructor of global object "InstrCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InstrCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|   
#  127|   static cl::opt<int>
#  128|->     InstrCost("inline-instr-cost", cl::Hidden, cl::init(5),
#  129|                 cl::desc("Cost of a single instruction when inlining"));
#  130|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:132: constructor_uses_global_object: The constructor of global object "MemAccessCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemAccessCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  130|   
#  131|   static cl::opt<int>
#  132|->     MemAccessCost("inline-memaccess-cost", cl::Hidden, cl::init(0),
#  133|                     cl::desc("Cost of load/store instruction when inlining"));
#  134|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:135: constructor_uses_global_object: The constructor of global object "CallPenalty" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CallPenalty" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|                     cl::desc("Cost of load/store instruction when inlining"));
#  134|   
#  135|-> static cl::opt<int> CallPenalty(
#  136|       "inline-call-penalty", cl::Hidden, cl::init(25),
#  137|       cl::desc("Call penalty that is applied per callsite when inlining"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:140: constructor_uses_global_object: The constructor of global object "StackSizeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackSizeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|   
#  139|   static cl::opt<size_t>
#  140|->     StackSizeThreshold("inline-max-stacksize", cl::Hidden,
#  141|                          cl::init(std::numeric_limits<size_t>::max()),
#  142|                          cl::desc("Do not inline functions with a stack size "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:145: constructor_uses_global_object: The constructor of global object "RecurStackSizeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RecurStackSizeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  143|                                   "that exceeds the specified limit"));
#  144|   
#  145|-> static cl::opt<size_t> RecurStackSizeThreshold(
#  146|       "recursive-inline-max-stacksize", cl::Hidden,
#  147|       cl::init(InlineConstants::TotalAllocaSizeRecursiveCaller),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:151: constructor_uses_global_object: The constructor of global object "OptComputeFullInlineCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptComputeFullInlineCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  149|                "size that exceeds the specified limit"));
#  150|   
#  151|-> static cl::opt<bool> OptComputeFullInlineCost(
#  152|       "inline-cost-full", cl::Hidden,
#  153|       cl::desc("Compute the full inline cost of a call site even when the cost "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:156: constructor_uses_global_object: The constructor of global object "InlineCallerSupersetNoBuiltin" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineCallerSupersetNoBuiltin" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  154|                "exceeds the threshold."));
#  155|   
#  156|-> static cl::opt<bool> InlineCallerSupersetNoBuiltin(
#  157|       "inline-caller-superset-nobuiltin", cl::Hidden, cl::init(true),
#  158|       cl::desc("Allow inlining when caller has a superset of callee's nobuiltin "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineCost.cpp:161: constructor_uses_global_object: The constructor of global object "DisableGEPConstOperand" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableGEPConstOperand" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  159|                "attributes."));
#  160|   
#  161|-> static cl::opt<bool> DisableGEPConstOperand(
#  162|       "disable-gep-const-evaluation", cl::Hidden, cl::init(false),
#  163|       cl::desc("Disables evaluation of GetElementPtr with constant operands"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineOrder.cpp:27: constructor_uses_global_object: The constructor of global object "UseInlinePriority" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseInlinePriority" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   enum class InlinePriorityMode : int { Size, Cost, CostBenefit, ML };
#   26|   
#   27|-> static cl::opt<InlinePriorityMode> UseInlinePriority(
#   28|       "inline-priority-mode", cl::init(InlinePriorityMode::Size), cl::Hidden,
#   29|       cl::desc("Choose the priority mode to use in module inline"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InlineOrder.cpp:38: constructor_uses_global_object: The constructor of global object "ModuleInlinerTopPriorityThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ModuleInlinerTopPriorityThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|                  clEnumValN(InlinePriorityMode::ML, "ml", "Use ML.")));
#   37|   
#   38|-> static cl::opt<int> ModuleInlinerTopPriorityThreshold(
#   39|       "moudle-inliner-top-priority-threshold", cl::Hidden, cl::init(0),
#   40|       cl::desc("The cost threshold for call sites that get inlined without the "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/InteractiveModelRunner.cpp:21: constructor_uses_global_object: The constructor of global object "DebugReply" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugReply" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   19|   using namespace llvm;
#   20|   
#   21|-> static cl::opt<bool> DebugReply(
#   22|       "interactive-model-runner-echo-reply", cl::init(false), cl::Hidden,
#   23|       cl::desc("The InteractiveModelRunner will echo back to stderr "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1005: var_decl: Declaring variable "DeletedRefSCCs".
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1134: uninit_use: Using uninitialized value "DeletedRefSCCs". Field "DeletedRefSCCs.InlineElts" is uninitialized.
# 1132|     // SCCs are no longer in an interesting state (they are totally empty) but
# 1133|     // the pointers will remain stable for the life of the graph itself.
# 1134|->   return DeletedRefSCCs;
# 1135|   }
# 1136|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1158: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1186: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1184|     if (llvm::all_of(TargetNs,
# 1185|                      [&](Node *TargetN) { return &SourceN == TargetN; }))
# 1186|->     return Result;
# 1187|   
# 1188|     // If all targets are in the same SCC as the source, because no call edges

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1158: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1194: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1192|           return G->lookupSCC(*TargetN) == &SourceC;
# 1193|         }))
# 1194|->     return Result;
# 1195|   
# 1196|     // We build somewhat synthetic new RefSCCs by providing a postorder mapping

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1158: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Analysis/LazyCallGraph.cpp:1319: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1317|             N->LowLink = -1;
# 1318|           // Return the empty result immediately.
# 1319|->         return Result;
# 1320|         }
# 1321|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LazyValueInfo.cpp:672: var_decl: Declaring variable "NonNullPointers".
llvm-17.0.6.src/lib/Analysis/LazyValueInfo.cpp:675: uninit_use: Using uninitialized value "NonNullPointers". Field "NonNullPointers.TheMap.NumEntries" is uninitialized.
#  673|       for (Instruction &I : *BB)
#  674|         AddNonNullPointersByInstruction(&I, NonNullPointers);
#  675|->     return NonNullPointers;
#  676|     });
#  677|   }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/Loads.cpp:448: constructor_uses_global_object: The constructor of global object "llvm::DefMaxInstsToScan" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DefMaxInstsToScan" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  446|   /// without documented explanation.
#  447|   cl::opt<unsigned>
#  448|-> llvm::DefMaxInstsToScan("available-load-scan-limit", cl::init(6), cl::Hidden,
#  449|     cl::desc("Use this to specify the default maximum number of instructions "
#  450|              "to scan backward from a given instruction, when searching for "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:76: constructor_uses_global_object: The constructor of global object "VectorizationFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VectorizationFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   74|   
#   75|   static cl::opt<unsigned, true>
#   76|-> VectorizationFactor("force-vector-width", cl::Hidden,
#   77|                       cl::desc("Sets the SIMD width. Zero is autoselect."),
#   78|                       cl::location(VectorizerParams::VectorizationFactor));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:82: constructor_uses_global_object: The constructor of global object "VectorizationInterleave" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VectorizationInterleave" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   
#   81|   static cl::opt<unsigned, true>
#   82|-> VectorizationInterleave("force-vector-interleave", cl::Hidden,
#   83|                           cl::desc("Sets the vectorization interleave count. "
#   84|                                    "Zero is autoselect."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:89: constructor_uses_global_object: The constructor of global object "RuntimeMemoryCheckThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RuntimeMemoryCheckThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   87|   unsigned VectorizerParams::VectorizationInterleave;
#   88|   
#   89|-> static cl::opt<unsigned, true> RuntimeMemoryCheckThreshold(
#   90|       "runtime-memory-check-threshold", cl::Hidden,
#   91|       cl::desc("When performing memory disambiguation checks at runtime do not "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:97: constructor_uses_global_object: The constructor of global object "MemoryCheckMergeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemoryCheckMergeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   95|   
#   96|   /// The maximum iterations used to merge memory checks
#   97|-> static cl::opt<unsigned> MemoryCheckMergeThreshold(
#   98|       "memory-check-merge-threshold", cl::Hidden,
#   99|       cl::desc("Maximum number of comparisons done when trying to merge "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:108: constructor_uses_global_object: The constructor of global object "MaxDependences" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxDependences" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|   /// We collect dependences up to this threshold.
#  107|   static cl::opt<unsigned>
#  108|->     MaxDependences("max-dependences", cl::Hidden,
#  109|                      cl::desc("Maximum number of dependences collected by "
#  110|                               "loop-access analysis (default = 100)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:124: constructor_uses_global_object: The constructor of global object "EnableMemAccessVersioning" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMemAccessVersioning" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  122|   ///    } else
#  123|   ///      ...
#  124|-> static cl::opt<bool> EnableMemAccessVersioning(
#  125|       "enable-mem-access-versioning", cl::init(true), cl::Hidden,
#  126|       cl::desc("Enable symbolic stride memory access versioning"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:130: constructor_uses_global_object: The constructor of global object "EnableForwardingConflictDetection" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableForwardingConflictDetection" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|   /// Enable store-to-load forwarding conflict detection. This option can
#  129|   /// be disabled for correctness testing.
#  130|-> static cl::opt<bool> EnableForwardingConflictDetection(
#  131|       "store-to-load-forwarding-conflict-detection", cl::Hidden,
#  132|       cl::desc("Enable conflict detection in loop-access analysis"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:135: constructor_uses_global_object: The constructor of global object "MaxForkedSCEVDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxForkedSCEVDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|       cl::init(true));
#  134|   
#  135|-> static cl::opt<unsigned> MaxForkedSCEVDepth(
#  136|       "max-forked-scev-depth", cl::Hidden,
#  137|       cl::desc("Maximum recursion depth when finding forked SCEVs (default = 5)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopAccessAnalysis.cpp:140: constructor_uses_global_object: The constructor of global object "SpeculateUnitStride" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SpeculateUnitStride" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|       cl::init(5));
#  139|   
#  140|-> static cl::opt<bool> SpeculateUnitStride(
#  141|       "laa-speculate-unit-stride", cl::Hidden,
#  142|       cl::desc("Speculate that non-constant strides are unit in LAA"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopCacheAnalysis.cpp:45: constructor_uses_global_object: The constructor of global object "DefaultTripCount" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DefaultTripCount" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|   #define DEBUG_TYPE "loop-cache-cost"
#   44|   
#   45|-> static cl::opt<unsigned> DefaultTripCount(
#   46|       "default-trip-count", cl::init(100), cl::Hidden,
#   47|       cl::desc("Use this to specify the default trip count of a loop"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopCacheAnalysis.cpp:52: constructor_uses_global_object: The constructor of global object "TemporalReuseThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TemporalReuseThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|   // reuse if they access either the same memory location, or a memory location
#   51|   // with distance smaller than a configurable threshold.
#   52|-> static cl::opt<unsigned> TemporalReuseThreshold(
#   53|       "temporal-reuse-threshold", cl::init(2), cl::Hidden,
#   54|       cl::desc("Use this to specify the max. distance between array elements "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/LoopInfo.cpp:53: constructor_uses_global_object: The constructor of global object "VerifyLoopInfoX" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyLoopInfoX" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|   #endif
#   52|   static cl::opt<bool, true>
#   53|->     VerifyLoopInfoX("verify-loop-info", cl::location(VerifyLoopInfo),
#   54|                       cl::Hidden, cl::desc("Verify loop info (time consuming)"));
#   55|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:183: var_decl: Declaring variable "Instr".
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:188: uninit_use: Using uninitialized value "Instr". Field "Instr.InlineElts" is uninitialized.
#  186|       LLVM_DEBUG(dbgs() << "The loop Nest is Perfect, returning empty "
#  187|                            "instruction vector. \n";);
#  188|->     return Instr;
#  189|   
#  190|     case InvalidLoopStructure:

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:183: var_decl: Declaring variable "Instr".
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:193: uninit_use: Using uninitialized value "Instr". Field "Instr.InlineElts" is uninitialized.
#  191|       LLVM_DEBUG(dbgs() << "Not perfectly nested: invalid loop structure. "
#  192|                            "Instruction vector is empty.\n";);
#  193|->     return Instr;
#  194|   
#  195|     case OuterLoopLowerBoundUnknown:

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:183: var_decl: Declaring variable "Instr".
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:198: uninit_use: Using uninitialized value "Instr". Field "Instr.InlineElts" is uninitialized.
#  196|       LLVM_DEBUG(dbgs() << "Cannot compute loop bounds of OuterLoop: "
#  197|                         << OuterLoop << "\nInstruction vector is empty.\n";);
#  198|->     return Instr;
#  199|   
#  200|     case ImperfectLoopNest:

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:242: var_decl: Declaring variable "LV".
llvm-17.0.6.src/lib/Analysis/LoopNestAnalysis.cpp:258: uninit_use: Using uninitialized value "LV". Field "LV.InlineElts" is uninitialized.
#  256|     }
#  257|   
#  258|->   return LV;
#  259|   }
#  260|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MLInlineAdvisor.cpp:35: constructor_uses_global_object: The constructor of global object "InteractiveChannelBaseName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InteractiveChannelBaseName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   using namespace llvm;
#   34|   
#   35|-> static cl::opt<std::string> InteractiveChannelBaseName(
#   36|       "inliner-interactive-channel-base", cl::Hidden,
#   37|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MLInlineAdvisor.cpp:46: constructor_uses_global_object: The constructor of global object "InteractiveIncludeDefault" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InteractiveIncludeDefault" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|           .str();
#   45|   static cl::opt<bool>
#   46|->     InteractiveIncludeDefault("inliner-interactive-include-default", cl::Hidden,
#   47|                                 cl::desc(InclDefaultMsg));
#   48|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MLInlineAdvisor.cpp:82: constructor_uses_global_object: The constructor of global object "SizeIncreaseThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SizeIncreaseThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   #define DEBUG_TYPE "inline-ml"
#   81|   
#   82|-> static cl::opt<float> SizeIncreaseThreshold(
#   83|       "ml-advisor-size-increase-threshold", cl::Hidden,
#   84|       cl::desc("Maximum factor by which expected native size may increase before "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MLInlineAdvisor.cpp:88: constructor_uses_global_object: The constructor of global object "KeepFPICache" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "KeepFPICache" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   86|       cl::init(2.0));
#   87|   
#   88|-> static cl::opt<bool> KeepFPICache(
#   89|       "ml-advisor-keep-fpi-cache", cl::Hidden,
#   90|       cl::desc(

Error: RETURN_LOCAL (CWE-562):
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:980: identity_transfer: Passing "llvm::APInt(getSizeWithOverflow(LHS)).slt(llvm::APInt(getSizeWithOverflow(RHS))) ? LHS : RHS" as argument 1 to constructor for class "pair", which sets "<temporary>" to that argument.
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:980: return_local_addr_alias: Returning pointer "<temporary>" which points to local variable "LHS".
#  978|     switch (Options.EvalMode) {
#  979|     case ObjectSizeOpts::Mode::Min:
#  980|->     return (getSizeWithOverflow(LHS).slt(getSizeWithOverflow(RHS))) ? LHS : RHS;
#  981|     case ObjectSizeOpts::Mode::Max:
#  982|       return (getSizeWithOverflow(LHS).sgt(getSizeWithOverflow(RHS))) ? LHS : RHS;

Error: RETURN_LOCAL (CWE-562):
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:980: identity_transfer: Passing "llvm::APInt(getSizeWithOverflow(LHS)).slt(llvm::APInt(getSizeWithOverflow(RHS))) ? LHS : RHS" as argument 1 to constructor for class "pair", which sets "<temporary>" to that argument.
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:980: return_local_addr_alias: Returning pointer "<temporary>" which points to local variable "RHS".
#  978|     switch (Options.EvalMode) {
#  979|     case ObjectSizeOpts::Mode::Min:
#  980|->     return (getSizeWithOverflow(LHS).slt(getSizeWithOverflow(RHS))) ? LHS : RHS;
#  981|     case ObjectSizeOpts::Mode::Max:
#  982|       return (getSizeWithOverflow(LHS).sgt(getSizeWithOverflow(RHS))) ? LHS : RHS;

Error: RETURN_LOCAL (CWE-562):
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:982: identity_transfer: Passing "llvm::APInt(getSizeWithOverflow(LHS)).sgt(llvm::APInt(getSizeWithOverflow(RHS))) ? LHS : RHS" as argument 1 to constructor for class "pair", which sets "<temporary>" to that argument.
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:982: return_local_addr_alias: Returning pointer "<temporary>" which points to local variable "LHS".
#  980|       return (getSizeWithOverflow(LHS).slt(getSizeWithOverflow(RHS))) ? LHS : RHS;
#  981|     case ObjectSizeOpts::Mode::Max:
#  982|->     return (getSizeWithOverflow(LHS).sgt(getSizeWithOverflow(RHS))) ? LHS : RHS;
#  983|     case ObjectSizeOpts::Mode::ExactSizeFromOffset:
#  984|       return (getSizeWithOverflow(LHS).eq(getSizeWithOverflow(RHS))) ? LHS

Error: RETURN_LOCAL (CWE-562):
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:982: identity_transfer: Passing "llvm::APInt(getSizeWithOverflow(LHS)).sgt(llvm::APInt(getSizeWithOverflow(RHS))) ? LHS : RHS" as argument 1 to constructor for class "pair", which sets "<temporary>" to that argument.
llvm-17.0.6.src/lib/Analysis/MemoryBuiltins.cpp:982: return_local_addr_alias: Returning pointer "<temporary>" which points to local variable "RHS".
#  980|       return (getSizeWithOverflow(LHS).slt(getSizeWithOverflow(RHS))) ? LHS : RHS;
#  981|     case ObjectSizeOpts::Mode::Max:
#  982|->     return (getSizeWithOverflow(LHS).sgt(getSizeWithOverflow(RHS))) ? LHS : RHS;
#  983|     case ObjectSizeOpts::Mode::ExactSizeFromOffset:
#  984|       return (getSizeWithOverflow(LHS).eq(getSizeWithOverflow(RHS))) ? LHS

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemoryDependenceAnalysis.cpp:73: constructor_uses_global_object: The constructor of global object "BlockScanLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BlockScanLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   // Limit for the number of instructions to scan in a block.
#   72|   
#   73|-> static cl::opt<unsigned> BlockScanLimit(
#   74|       "memdep-block-scan-limit", cl::Hidden, cl::init(100),
#   75|       cl::desc("The number of instructions to scan in a block in memory "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemoryDependenceAnalysis.cpp:79: constructor_uses_global_object: The constructor of global object "BlockNumberLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BlockNumberLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   
#   78|   static cl::opt<unsigned>
#   79|->     BlockNumberLimit("memdep-block-number-limit", cl::Hidden, cl::init(200),
#   80|                        cl::desc("The number of blocks to scan during memory "
#   81|                                 "dependency analysis (default = 200)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemoryProfileInfo.cpp:23: constructor_uses_global_object: The constructor of global object "MemProfLifetimeAccessDensityColdThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemProfLifetimeAccessDensityColdThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   // Upper bound on lifetime access density (accesses per byte per lifetime sec)
#   22|   // for marking an allocation cold.
#   23|-> cl::opt<float> MemProfLifetimeAccessDensityColdThreshold(
#   24|       "memprof-lifetime-access-density-cold-threshold", cl::init(0.05),
#   25|       cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemoryProfileInfo.cpp:31: constructor_uses_global_object: The constructor of global object "MemProfAveLifetimeColdThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemProfAveLifetimeColdThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   // Lower bound on lifetime to mark an allocation cold (in addition to accesses
#   30|   // per byte per sec above). This is to avoid pessimizing short lived objects.
#   31|-> cl::opt<unsigned> MemProfAveLifetimeColdThreshold(
#   32|       "memprof-ave-lifetime-cold-threshold", cl::init(200), cl::Hidden,
#   33|       cl::desc("The average lifetime (s) for an allocation to be considered "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemoryProfileInfo.cpp:38: constructor_uses_global_object: The constructor of global object "MemProfMinAveLifetimeAccessDensityHotThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemProfMinAveLifetimeAccessDensityHotThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   // Lower bound on average lifetime accesses density (total life time access
#   37|   // density / alloc count) for marking an allocation hot.
#   38|-> cl::opt<unsigned> MemProfMinAveLifetimeAccessDensityHotThreshold(
#   39|       "memprof-min-ave-lifetime-access-density-hot-threshold", cl::init(1000),
#   40|       cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemorySSA.cpp:63: constructor_uses_global_object: The constructor of global object "DotCFGMSSA[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DotCFGMSSA[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   61|   
#   62|   static cl::opt<std::string>
#   63|->     DotCFGMSSA("dot-cfg-mssa",
#   64|                  cl::value_desc("file name for generated dot file"),
#   65|                  cl::desc("file name for generated dot file"), cl::init(""));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemorySSA.cpp:74: constructor_uses_global_object: The constructor of global object "MaxCheckLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxCheckLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|                       true)
#   73|   
#   74|-> static cl::opt<unsigned> MaxCheckLimit(
#   75|       "memssa-check-limit", cl::Hidden, cl::init(100),
#   76|       cl::desc("The maximum number of stores/phis MemorySSA"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/MemorySSA.cpp:87: constructor_uses_global_object: The constructor of global object "VerifyMemorySSAX" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyMemorySSAX" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   85|   
#   86|   static cl::opt<bool, true>
#   87|->     VerifyMemorySSAX("verify-memoryssa", cl::location(VerifyMemorySSA),
#   88|                        cl::Hidden, cl::desc("Enable verification of MemorySSA."));
#   89|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Analysis/MemorySSAUpdater.cpp:289: tainted_data_return: Called function "MP->getBasicBlockIndex(BB)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Analysis/MemorySSAUpdater.cpp:289: assign: Assigning: "i" = "MP->getBasicBlockIndex(BB)".
llvm-17.0.6.src/lib/Analysis/MemorySSAUpdater.cpp:296: overflow_sink: "i", which might have overflowed, is passed to "MP->setIncomingValue(i, NewDef)".
#  294|       if (BlockBB != BB)
#  295|         break;
#  296|->     MP->setIncomingValue(i, NewDef);
#  297|       ++i;
#  298|     }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ModuleSummaryAnalysis.cpp:71: constructor_uses_global_object: The constructor of global object "FSEC" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FSEC" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|   } // namespace llvm
#   70|   
#   71|-> static cl::opt<FunctionSummary::ForceSummaryHotnessType, true> FSEC(
#   72|       "force-summary-edges-cold", cl::Hidden, cl::location(ForceSummaryEdgesCold),
#   73|       cl::desc("Force all edges in the function summary to cold"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ModuleSummaryAnalysis.cpp:79: constructor_uses_global_object: The constructor of global object "ModuleSummaryDotFile[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ModuleSummaryDotFile[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|                  clEnumValN(FunctionSummary::FSHT_All, "all", "All edges.")));
#   78|   
#   79|-> static cl::opt<std::string> ModuleSummaryDotFile(
#   80|       "module-summary-dot-file", cl::Hidden, cl::value_desc("filename"),
#   81|       cl::desc("File to emit dot graph of new summary into"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ObjCARCAnalysisUtils.cpp:24: constructor_uses_global_object: The constructor of global object "EnableARCOptimizations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableARCOptimizations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   22|   /// A handy option to enable/disable all ARC Optimizations.
#   23|   bool llvm::objcarc::EnableARCOpts;
#   24|-> static cl::opt<bool, true> EnableARCOptimizations(
#   25|       "enable-objc-arc-opts", cl::desc("enable/disable all ARC Optimizations"),
#   26|       cl::location(EnableARCOpts), cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/PHITransAddr.cpp:24: constructor_uses_global_object: The constructor of global object "EnableAddPhiTranslation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAddPhiTranslation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   22|   using namespace llvm;
#   23|   
#   24|-> static cl::opt<bool> EnableAddPhiTranslation(
#   25|       "gvn-add-phi-translation", cl::init(false), cl::Hidden,
#   26|       cl::desc("Enable phi-translation of add instructions"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ProfileSummaryInfo.cpp:36: constructor_uses_global_object: The constructor of global object "PartialProfile" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PartialProfile" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   } // namespace llvm
#   35|   
#   36|-> static cl::opt<bool> PartialProfile(
#   37|       "partial-profile", cl::Hidden, cl::init(false),
#   38|       cl::desc("Specify the current profile is used as a partial profile."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ProfileSummaryInfo.cpp:40: constructor_uses_global_object: The constructor of global object "ScalePartialSampleProfileWorkingSetSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ScalePartialSampleProfileWorkingSetSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|       cl::desc("Specify the current profile is used as a partial profile."));
#   39|   
#   40|-> cl::opt<bool> ScalePartialSampleProfileWorkingSetSize(
#   41|       "scale-partial-sample-profile-working-set-size", cl::Hidden, cl::init(true),
#   42|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ProfileSummaryInfo.cpp:47: constructor_uses_global_object: The constructor of global object "PartialSampleProfileWorkingSetSizeScaleFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PartialSampleProfileWorkingSetSizeScaleFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|           "being compiled."));
#   46|   
#   47|-> static cl::opt<double> PartialSampleProfileWorkingSetSizeScaleFactor(
#   48|       "partial-sample-profile-working-set-size-scale-factor", cl::Hidden,
#   49|       cl::init(0.008),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/RegionInfo.cpp:42: constructor_uses_global_object: The constructor of global object "VerifyRegionInfoX" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyRegionInfoX" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|   
#   41|   static cl::opt<bool,true>
#   42|-> VerifyRegionInfoX(
#   43|     "verify-region-info",
#   44|     cl::location(RegionInfoBase<RegionTraits<Function>>::VerifyRegionInfo),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/RegionInfo.cpp:47: constructor_uses_global_object: The constructor of global object "printStyleX" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "printStyleX" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|     cl::desc("Verify region info (time consuming)"));
#   46|   
#   47|-> static cl::opt<Region::PrintStyle, true> printStyleX("print-region-style",
#   48|     cl::location(RegionInfo::printStyle),
#   49|     cl::Hidden,

Error: USE_AFTER_FREE (CWE-416):
llvm-17.0.6.src/lib/Analysis/RegionPass.cpp:264: freed_arg: "schedulePass" frees "RGPM".
llvm-17.0.6.src/lib/Analysis/RegionPass.cpp:267: deref_arg: Calling "push" dereferences freed pointer "RGPM".
#  265|   
#  266|       // [4] Push new manager into PMS
#  267|->     PMS.push(RGPM);
#  268|     }
#  269|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/RegionPrinter.cpp:28: constructor_uses_global_object: The constructor of global object "onlySimpleRegions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "onlySimpleRegions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   /// onlySimpleRegion - Show only the simple regions in the RegionViewer.
#   27|   static cl::opt<bool>
#   28|-> onlySimpleRegions("only-simple-regions",
#   29|                     cl::desc("Show only simple regions in the graphviz viewer"),
#   30|                     cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:153: constructor_uses_global_object: The constructor of global object "MaxBruteForceIterations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxBruteForceIterations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  151|   
#  152|   static cl::opt<unsigned>
#  153|->     MaxBruteForceIterations("scalar-evolution-max-iterations", cl::ReallyHidden,
#  154|                               cl::desc("Maximum number of iterations SCEV will "
#  155|                                        "symbolically execute a constant "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:159: constructor_uses_global_object: The constructor of global object "VerifySCEVOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifySCEVOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  157|                               cl::init(100));
#  158|   
#  159|-> static cl::opt<bool, true> VerifySCEVOpt(
#  160|       "verify-scev", cl::Hidden, cl::location(VerifySCEV),
#  161|       cl::desc("Verify ScalarEvolution's backedge taken counts (slow)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:162: constructor_uses_global_object: The constructor of global object "VerifySCEVStrict" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifySCEVStrict" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  160|       "verify-scev", cl::Hidden, cl::location(VerifySCEV),
#  161|       cl::desc("Verify ScalarEvolution's backedge taken counts (slow)"));
#  162|-> static cl::opt<bool> VerifySCEVStrict(
#  163|       "verify-scev-strict", cl::Hidden,
#  164|       cl::desc("Enable stricter verification with -verify-scev is passed"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:166: constructor_uses_global_object: The constructor of global object "VerifyIR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyIR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  164|       cl::desc("Enable stricter verification with -verify-scev is passed"));
#  165|   
#  166|-> static cl::opt<bool> VerifyIR(
#  167|       "scev-verify-ir", cl::Hidden,
#  168|       cl::desc("Verify IR correctness when making sensitive SCEV queries (slow)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:171: constructor_uses_global_object: The constructor of global object "MulOpsInlineThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MulOpsInlineThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  169|       cl::init(false));
#  170|   
#  171|-> static cl::opt<unsigned> MulOpsInlineThreshold(
#  172|       "scev-mulops-inline-threshold", cl::Hidden,
#  173|       cl::desc("Threshold for inlining multiplication operands into a SCEV"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:176: constructor_uses_global_object: The constructor of global object "AddOpsInlineThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddOpsInlineThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  174|       cl::init(32));
#  175|   
#  176|-> static cl::opt<unsigned> AddOpsInlineThreshold(
#  177|       "scev-addops-inline-threshold", cl::Hidden,
#  178|       cl::desc("Threshold for inlining addition operands into a SCEV"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:181: constructor_uses_global_object: The constructor of global object "MaxSCEVCompareDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxSCEVCompareDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  179|       cl::init(500));
#  180|   
#  181|-> static cl::opt<unsigned> MaxSCEVCompareDepth(
#  182|       "scalar-evolution-max-scev-compare-depth", cl::Hidden,
#  183|       cl::desc("Maximum depth of recursive SCEV complexity comparisons"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:186: constructor_uses_global_object: The constructor of global object "MaxSCEVOperationsImplicationDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxSCEVOperationsImplicationDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  184|       cl::init(32));
#  185|   
#  186|-> static cl::opt<unsigned> MaxSCEVOperationsImplicationDepth(
#  187|       "scalar-evolution-max-scev-operations-implication-depth", cl::Hidden,
#  188|       cl::desc("Maximum depth of recursive SCEV operations implication analysis"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:191: constructor_uses_global_object: The constructor of global object "MaxValueCompareDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxValueCompareDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  189|       cl::init(2));
#  190|   
#  191|-> static cl::opt<unsigned> MaxValueCompareDepth(
#  192|       "scalar-evolution-max-value-compare-depth", cl::Hidden,
#  193|       cl::desc("Maximum depth of recursive value complexity comparisons"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:197: constructor_uses_global_object: The constructor of global object "MaxArithDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxArithDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  195|   
#  196|   static cl::opt<unsigned>
#  197|->     MaxArithDepth("scalar-evolution-max-arith-depth", cl::Hidden,
#  198|                     cl::desc("Maximum depth of recursive arithmetics"),
#  199|                     cl::init(32));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:201: constructor_uses_global_object: The constructor of global object "MaxConstantEvolvingDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxConstantEvolvingDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  199|                     cl::init(32));
#  200|   
#  201|-> static cl::opt<unsigned> MaxConstantEvolvingDepth(
#  202|       "scalar-evolution-max-constant-evolving-depth", cl::Hidden,
#  203|       cl::desc("Maximum depth of recursive constant evolving"), cl::init(32));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:206: constructor_uses_global_object: The constructor of global object "MaxCastDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxCastDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  204|   
#  205|   static cl::opt<unsigned>
#  206|->     MaxCastDepth("scalar-evolution-max-cast-depth", cl::Hidden,
#  207|                    cl::desc("Maximum depth of recursive SExt/ZExt/Trunc"),
#  208|                    cl::init(8));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:211: constructor_uses_global_object: The constructor of global object "MaxAddRecSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxAddRecSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  209|   
#  210|   static cl::opt<unsigned>
#  211|->     MaxAddRecSize("scalar-evolution-max-add-rec-size", cl::Hidden,
#  212|                     cl::desc("Max coefficients in AddRec during evolving"),
#  213|                     cl::init(8));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:216: constructor_uses_global_object: The constructor of global object "HugeExprThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HugeExprThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  214|   
#  215|   static cl::opt<unsigned>
#  216|->     HugeExprThreshold("scalar-evolution-huge-expr-threshold", cl::Hidden,
#  217|                     cl::desc("Size of the expression which is considered huge"),
#  218|                     cl::init(4096));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:220: constructor_uses_global_object: The constructor of global object "RangeIterThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RangeIterThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  218|                     cl::init(4096));
#  219|   
#  220|-> static cl::opt<unsigned> RangeIterThreshold(
#  221|       "scev-range-iter-threshold", cl::Hidden,
#  222|       cl::desc("Threshold for switching to iteratively computing SCEV ranges"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:226: constructor_uses_global_object: The constructor of global object "ClassifyExpressions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClassifyExpressions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  224|   
#  225|   static cl::opt<bool>
#  226|-> ClassifyExpressions("scalar-evolution-classify-expressions",
#  227|       cl::Hidden, cl::init(true),
#  228|       cl::desc("When printing analysis, include information on every instruction"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:230: constructor_uses_global_object: The constructor of global object "UseExpensiveRangeSharpening" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseExpensiveRangeSharpening" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  228|       cl::desc("When printing analysis, include information on every instruction"));
#  229|   
#  230|-> static cl::opt<bool> UseExpensiveRangeSharpening(
#  231|       "scalar-evolution-use-expensive-range-sharpening", cl::Hidden,
#  232|       cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:236: constructor_uses_global_object: The constructor of global object "MaxPhiSCCAnalysisSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxPhiSCCAnalysisSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  234|                "be costly in terms of compile time"));
#  235|   
#  236|-> static cl::opt<unsigned> MaxPhiSCCAnalysisSize(
#  237|       "scalar-evolution-max-scc-analysis-depth", cl::Hidden,
#  238|       cl::desc("Maximum amount of nodes to process while searching SCEVUnknown "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:243: constructor_uses_global_object: The constructor of global object "EnableFiniteLoopControl" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFiniteLoopControl" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  241|   
#  242|   static cl::opt<bool>
#  243|->     EnableFiniteLoopControl("scalar-evolution-finite-loop", cl::Hidden,
#  244|                               cl::desc("Handle <= and >= in finite loops"),
#  245|                               cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:247: constructor_uses_global_object: The constructor of global object "UseContextForNoWrapFlagInference" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseContextForNoWrapFlagInference" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  245|                               cl::init(true));
#  246|   
#  247|-> static cl::opt<bool> UseContextForNoWrapFlagInference(
#  248|       "scalar-evolution-use-context-for-no-wrap-flag-strenghening", cl::Hidden,
#  249|       cl::desc("Infer nuw/nsw flags using context where suitable"),

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:3142: underflow: The decrement operator on the unsigned variable "Idx" might result in an underflow.
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:3224: overflow_sink: "Idx", which might have underflowed, is passed to "Ops[Idx]".
# 3222|   
# 3223|     // Skip over the add expression until we get to a multiply.
# 3224|->   while (Idx < Ops.size() && Ops[Idx]->getSCEVType() < scMulExpr)
# 3225|       ++Idx;
# 3226|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:3882: underflow: The decrement operator on the unsigned variable "Idx" might result in an underflow.
llvm-17.0.6.src/lib/Analysis/ScalarEvolution.cpp:3893: overflow_sink: "Idx", which might have underflowed, is passed to "Ops[Idx]".
# 3891|   
# 3892|     // Find the first operation of the same kind
# 3893|->   while (Idx < Ops.size() && Ops[Idx]->getSCEVType() < Kind)
# 3894|       ++Idx;
# 3895|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ScopedNoAliasAA.cpp:51: constructor_uses_global_object: The constructor of global object "EnableScopedNoAlias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableScopedNoAlias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|   // can also be achieved by stripping the associated metadata tags from IR, but
#   50|   // this option is sometimes more convenient.
#   51|-> static cl::opt<bool> EnableScopedNoAlias("enable-scoped-noalias",
#   52|                                            cl::init(true), cl::Hidden);
#   53|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/StackSafetyAnalysis.cpp:62: constructor_uses_global_object: The constructor of global object "StackSafetyMaxIterations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackSafetyMaxIterations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   
#   61|   
#   62|-> static cl::opt<int> StackSafetyMaxIterations("stack-safety-max-iterations",
#   63|                                                cl::init(20), cl::Hidden);
#   64|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/StackSafetyAnalysis.cpp:65: constructor_uses_global_object: The constructor of global object "StackSafetyPrint" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackSafetyPrint" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|                                                cl::init(20), cl::Hidden);
#   64|   
#   65|-> static cl::opt<bool> StackSafetyPrint("stack-safety-print", cl::init(false),
#   66|                                         cl::Hidden);
#   67|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/StackSafetyAnalysis.cpp:68: constructor_uses_global_object: The constructor of global object "StackSafetyRun" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackSafetyRun" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|                                         cl::Hidden);
#   67|   
#   68|-> static cl::opt<bool> StackSafetyRun("stack-safety-run", cl::init(false),
#   69|                                       cl::Hidden);
#   70|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/TargetLibraryInfo.cpp:20: constructor_uses_global_object: The constructor of global object "ClVectorLibrary" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClVectorLibrary" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   18|   using namespace llvm;
#   19|   
#   20|-> static cl::opt<TargetLibraryInfoImpl::VectorLibrary> ClVectorLibrary(
#   21|       "vector-library", cl::Hidden, cl::desc("Vector functions library"),
#   22|       cl::init(TargetLibraryInfoImpl::NoLibrary),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/TargetTransformInfo.cpp:31: constructor_uses_global_object: The constructor of global object "EnableReduxCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableReduxCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   #define DEBUG_TYPE "tti"
#   30|   
#   31|-> static cl::opt<bool> EnableReduxCost("costmodel-reduxcost", cl::init(false),
#   32|                                        cl::Hidden,
#   33|                                        cl::desc("Recognize reduction patterns."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/TargetTransformInfo.cpp:35: constructor_uses_global_object: The constructor of global object "CacheLineSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CacheLineSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|                                        cl::desc("Recognize reduction patterns."));
#   34|   
#   35|-> static cl::opt<unsigned> CacheLineSize(
#   36|       "cache-line-size", cl::init(0), cl::Hidden,
#   37|       cl::desc("Use this to override the target cache line size when "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/TargetTransformInfo.cpp:40: constructor_uses_global_object: The constructor of global object "PredictableBranchThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PredictableBranchThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|                "specified by the user."));
#   39|   
#   40|-> static cl::opt<unsigned> PredictableBranchThreshold(
#   41|       "predictable-branch-threshold", cl::init(99), cl::Hidden,
#   42|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/TrainingLogger.cpp:32: constructor_uses_global_object: The constructor of global object "UseSimpleLogger" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseSimpleLogger" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   // FIXME(mtrofin): remove the flag altogether
#   31|   static cl::opt<bool>
#   32|->     UseSimpleLogger("tfutils-use-simplelogger", cl::init(true), cl::Hidden,
#   33|                       cl::desc("Output simple (non-protobuf) log."));
#   34|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/TypeBasedAliasAnalysis.cpp:130: constructor_uses_global_object: The constructor of global object "EnableTBAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableTBAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|   // achieved by stripping the !tbaa tags from IR, but this option is sometimes
#  129|   // more convenient.
#  130|-> static cl::opt<bool> EnableTBAA("enable-tbaa", cl::init(true), cl::Hidden);
#  131|   
#  132|   namespace {

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/ValueTracking.cpp:85: constructor_uses_global_object: The constructor of global object "DomConditionsMaxUses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DomConditionsMaxUses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|   // Controls the number of uses of the value searched for possible
#   84|   // dominating comparisons.
#   85|-> static cl::opt<unsigned> DomConditionsMaxUses("dom-conditions-max-uses",
#   86|                                                 cl::Hidden, cl::init(20));
#   87|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:35: constructor_uses_global_object: The constructor of global object "MaxInterleaveGroupFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxInterleaveGroupFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   /// Maximum factor for an interleaved memory access.
#   35|-> static cl::opt<unsigned> MaxInterleaveGroupFactor(
#   36|       "max-interleave-group-factor", cl::Hidden,
#   37|       cl::desc("Maximum factor for an interleaved access group (default = 8)"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:846: var_decl: Declaring variable "MaskVec".
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:851: uninit_use: Using uninitialized value "MaskVec". Field "MaskVec.InlineElts" is uninitialized.
#  849|         MaskVec.push_back(i);
#  850|   
#  851|->   return MaskVec;
#  852|   }
#  853|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:856: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:861: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
#  859|         Mask.push_back(j * VF + i);
#  860|   
#  861|->   return Mask;
#  862|   }
#  863|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:866: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:870: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
#  868|       Mask.push_back(Start + i * Stride);
#  869|   
#  870|->   return Mask;
#  871|   }
#  872|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:876: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:883: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
#  881|       Mask.push_back(-1);
#  882|   
#  883|->   return Mask;
#  884|   }
#  885|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:894: var_decl: Declaring variable "UnaryMask".
llvm-17.0.6.src/lib/Analysis/VectorUtils.cpp:900: uninit_use: Using uninitialized value "UnaryMask". Field "UnaryMask.InlineElts" is uninitialized.
#  898|       UnaryMask.push_back(UnaryElt);
#  899|     }
#  900|->   return UnaryMask;
#  901|   }
#  902|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1011: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), llvm::APInt(64U, this->HexIntToVal(this->TokStart + 2, this->CurPtr), false))".
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1011: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1009|       // hexadecimal number for when exponential notation is not precise enough.
# 1010|       // Half, BFloat, Float, and double only.
# 1011|->     APFloatVal = APFloat(APFloat::IEEEdouble(),
# 1012|                            APInt(64, HexIntToVal(TokStart + 2, CurPtr)));
# 1013|       return lltok::APFloat;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1022: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::x87DoubleExtended(), llvm::APInt(80U, llvm::ArrayRef<unsigned long>(Pair)))".
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1022: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1020|       // F80HexFPConstant - x87 long double in hexadecimal format (10 bytes)
# 1021|       FP80HexToIntPair(TokStart+3, CurPtr, Pair);
# 1022|->     APFloatVal = APFloat(APFloat::x87DoubleExtended(), APInt(80, Pair));
# 1023|       return lltok::APFloat;
# 1024|     case 'L':

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1027: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEquad(), llvm::APInt(128U, llvm::ArrayRef<unsigned long>(Pair)))".
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1027: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1025|       // F128HexFPConstant - IEEE 128-bit in hexadecimal format (16 bytes)
# 1026|       HexToIntPair(TokStart+3, CurPtr, Pair);
# 1027|->     APFloatVal = APFloat(APFloat::IEEEquad(), APInt(128, Pair));
# 1028|       return lltok::APFloat;
# 1029|     case 'M':

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1032: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::PPCDoubleDouble(), llvm::APInt(128U, llvm::ArrayRef<unsigned long>(Pair)))".
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1032: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1030|       // PPC128HexFPConstant - PowerPC 128-bit in hexadecimal format (16 bytes)
# 1031|       HexToIntPair(TokStart+3, CurPtr, Pair);
# 1032|->     APFloatVal = APFloat(APFloat::PPCDoubleDouble(), APInt(128, Pair));
# 1033|       return lltok::APFloat;
# 1034|     case 'H':

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1035: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEhalf(), llvm::APInt(16U, this->HexIntToVal(this->TokStart + 3, this->CurPtr), false))".
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1035: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1033|       return lltok::APFloat;
# 1034|     case 'H':
# 1035|->     APFloatVal = APFloat(APFloat::IEEEhalf(),
# 1036|                            APInt(16,HexIntToVal(TokStart+3, CurPtr)));
# 1037|       return lltok::APFloat;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1040: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::BFloat(), llvm::APInt(16U, this->HexIntToVal(this->TokStart + 3, this->CurPtr), false))".
llvm-17.0.6.src/lib/AsmParser/LLLexer.cpp:1040: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1038|     case 'R':
# 1039|       // Brain floating point
# 1040|->     APFloatVal = APFloat(APFloat::BFloat(),
# 1041|                            APInt(16, HexIntToVal(TokStart + 3, CurPtr)));
# 1042|       return lltok::APFloat;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:3651: var_decl: Declaring variable "Fn".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:3659: uninit_use_in_call: Using uninitialized value "Fn.APFloatVal.U" when calling "~ValID".
# 3657|           parseValID(Label, PFS) ||
# 3658|           parseToken(lltok::rparen, "expected ')' in block address expression"))
# 3659|->       return true;
# 3660|   
# 3661|       if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:3651: var_decl: Declaring variable "Label".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:3659: uninit_use_in_call: Using uninitialized value "Label.APFloatVal.U" when calling "~ValID".
# 3657|           parseValID(Label, PFS) ||
# 3658|           parseToken(lltok::rparen, "expected ')' in block address expression"))
# 3659|->       return true;
# 3660|   
# 3661|       if (Fn.Kind != ValID::t_GlobalID && Fn.Kind != ValID::t_GlobalName)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:6736: var_decl: Declaring variable "CalleeID".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:6752: uninit_use_in_call: Using uninitialized value "CalleeID.APFloatVal.U" when calling "~ValID".
# 6750|         parseToken(lltok::kw_unwind, "expected 'unwind' in invoke") ||
# 6751|         parseTypeAndBasicBlock(UnwindBB, PFS))
# 6752|->     return true;
# 6753|   
# 6754|     // If RetType is a non-function pointer type, then this is the short syntax

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:7033: var_decl: Declaring variable "CalleeID".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:7047: uninit_use_in_call: Using uninitialized value "CalleeID.APFloatVal.U" when calling "~ValID".
# 7045|         parseTypeAndBasicBlock(DefaultDest, PFS) ||
# 7046|         parseToken(lltok::lsquare, "expected '[' in callbr"))
# 7047|->     return true;
# 7048|   
# 7049|     // parse the destination list.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:7439: var_decl: Declaring variable "CalleeID".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:7447: uninit_use_in_call: Using uninitialized value "CalleeID.APFloatVal.U" when calling "~ValID".
# 7445|         parseToken(lltok::kw_call,
# 7446|                    "expected 'tail call', 'musttail call', or 'notail call'"))
# 7447|->     return true;
# 7448|   
# 7449|     FastMathFlags FMF = EatFastMathFlagsIfPresent();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:7439: var_decl: Declaring variable "CalleeID".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:7459: uninit_use_in_call: Using uninitialized value "CalleeID.APFloatVal.U" when calling "~ValID".
# 7457|         parseFnAttributeValuePairs(FnAttrs, FwdRefAttrGrps, false, BuiltinLoc) ||
# 7458|         parseOptionalOperandBundles(BundleList, PFS))
# 7459|->     return true;
# 7460|   
# 7461|     // If RetType is a non-function pointer type, then this is the short syntax

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:8111: var_decl: Declaring variable "Label".
llvm-17.0.6.src/lib/AsmParser/LLParser.cpp:8118: uninit_use_in_call: Using uninitialized value "Label.APFloatVal.U" when calling "~ValID".
# 8116|         parseToken(lltok::comma, "expected comma in uselistorder_bb directive") ||
# 8117|         parseUseListOrderIndexes(Indexes))
# 8118|->     return true;
# 8119|   
# 8120|     // Check the function.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:32: temporary: Creating temporary of type "llvm::LLParser" in "llvm::LLParser(F.getBuffer(), SM, Err, M, Index, (M ? M->getContext() : OptContext.emplace()), Slots)".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:32: uninit_use_in_call: Using uninitialized value "<temporary>.Lex.APFloatVal.U" when calling "~LLParser".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:32: uninit_use_in_call: Using uninitialized value "<temporary>.OPLex.APFloatVal.U" when calling "~LLParser".
#   30|   
#   31|     std::optional<LLVMContext> OptContext;
#   32|->   return LLParser(F.getBuffer(), SM, Err, M, Index,
#   33|                     M ? M->getContext() : OptContext.emplace(), Slots)
#   34|         .Run(UpgradeDebugInfo, DataLayoutCallback);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:153: temporary: Creating temporary of type "llvm::LLParser" in "llvm::LLParser(F.getBuffer(), SM, Err, NULL, Index, unusedContext, NULL)".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:153: uninit_use_in_call: Using uninitialized value "<temporary>.Lex.APFloatVal.U" when calling "~LLParser".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:153: uninit_use_in_call: Using uninitialized value "<temporary>.OPLex.APFloatVal.U" when calling "~LLParser".
#  151|     // index, but we need to initialize it.
#  152|     LLVMContext unusedContext;
#  153|->   return LLParser(F.getBuffer(), SM, Err, nullptr, &Index, unusedContext)
#  154|         .Run(true, [](StringRef, StringRef) { return std::nullopt; });
#  155|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:193: temporary: Creating temporary of type "llvm::LLParser" in "llvm::LLParser(Asm, SM, Err, const_cast<llvm::Module *>(M), NULL, M->getContext(), NULL)".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:193: uninit_use_in_call: Using uninitialized value "<temporary>.Lex.APFloatVal.U" when calling "~LLParser".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:193: uninit_use_in_call: Using uninitialized value "<temporary>.OPLex.APFloatVal.U" when calling "~LLParser".
#  191|     SM.AddNewSourceBuffer(std::move(Buf), SMLoc());
#  192|     Constant *C;
#  193|->   if (LLParser(Asm, SM, Err, const_cast<Module *>(&M), nullptr, M.getContext())
#  194|             .parseStandaloneConstantValue(C, Slots))
#  195|       return nullptr;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:222: temporary: Creating temporary of type "llvm::LLParser" in "llvm::LLParser(Asm, SM, Err, const_cast<llvm::Module *>(M), NULL, M->getContext(), NULL)".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:222: uninit_use_in_call: Using uninitialized value "<temporary>.Lex.APFloatVal.U" when calling "~LLParser".
llvm-17.0.6.src/lib/AsmParser/Parser.cpp:222: uninit_use_in_call: Using uninitialized value "<temporary>.OPLex.APFloatVal.U" when calling "~LLParser".
#  220|     SM.AddNewSourceBuffer(std::move(Buf), SMLoc());
#  221|     Type *Ty;
#  222|->   if (LLParser(Asm, SM, Err, const_cast<Module *>(&M), nullptr, M.getContext())
#  223|             .parseTypeAtBeginning(Ty, Read, Slots))
#  224|       return nullptr;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/BinaryFormat/XCOFF.cpp:163: var_decl: Declaring variable "Res".
llvm-17.0.6.src/lib/BinaryFormat/XCOFF.cpp:184: uninit_use: Using uninitialized value "Res". Field "Res.InlineElts" is uninitialized.
#  182|     // Pop the last space.
#  183|     Res.pop_back();
#  184|->   return Res;
#  185|   }
#  186|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Bitcode/Reader/BitReader.cpp:86: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/Bitcode/Reader/BitReader.cpp:86: leaked_storage: Failing to save or free storage allocated by "Owner.release()" leaks it.
#   84|     // Release the buffer if we didn't take ownership of it since we never owned
#   85|     // it anyway.
#   86|->   (void)Owner.release();
#   87|   
#   88|     if (Error Err = ModuleOrErr.takeError()) {

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Bitcode/Reader/BitReader.cpp:112: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/Bitcode/Reader/BitReader.cpp:112: leaked_storage: Ignoring storage allocated by "Owner.release()" leaks it.
#  110|     ErrorOr<std::unique_ptr<Module>> ModuleOrErr = expectedToErrorOrAndEmitErrors(
#  111|         Ctx, getOwningLazyBitcodeModule(std::move(Owner), Ctx));
#  112|->   Owner.release();
#  113|   
#  114|     if (ModuleOrErr.getError()) {

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:93: constructor_uses_global_object: The constructor of global object "PrintSummaryGUIDs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintSummaryGUIDs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   91|   using namespace llvm;
#   92|   
#   93|-> static cl::opt<bool> PrintSummaryGUIDs(
#   94|       "print-summary-global-ids", cl::init(false), cl::Hidden,
#   95|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:98: constructor_uses_global_object: The constructor of global object "ExpandConstantExprs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExpandConstantExprs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   96|           "Print the global id for each value when reading the module summary"));
#   97|   
#   98|-> static cl::opt<bool> ExpandConstantExprs(
#   99|       "expand-constant-exprs", cl::Hidden,
#  100|       cl::desc(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3042: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEhalf(), llvm::APInt(16U, (uint16_t)Record[0UL], false))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3042: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3040|           return error("Invalid float const record");
# 3041|         if (CurTy->isHalfTy())
# 3042|->         V = ConstantFP::get(Context, APFloat(APFloat::IEEEhalf(),
# 3043|                                                APInt(16, (uint16_t)Record[0])));
# 3044|         else if (CurTy->isBFloatTy())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3045: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::BFloat(), llvm::APInt(16U, (uint32_t)Record[0UL], false))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3045: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3043|                                                APInt(16, (uint16_t)Record[0])));
# 3044|         else if (CurTy->isBFloatTy())
# 3045|->         V = ConstantFP::get(Context, APFloat(APFloat::BFloat(),
# 3046|                                                APInt(16, (uint32_t)Record[0])));
# 3047|         else if (CurTy->isFloatTy())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3048: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), llvm::APInt(32U, (uint32_t)Record[0UL], false))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3048: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3046|                                                APInt(16, (uint32_t)Record[0])));
# 3047|         else if (CurTy->isFloatTy())
# 3048|->         V = ConstantFP::get(Context, APFloat(APFloat::IEEEsingle(),
# 3049|                                                APInt(32, (uint32_t)Record[0])));
# 3050|         else if (CurTy->isDoubleTy())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3051: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), llvm::APInt(64U, Record[0UL], false))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3051: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3049|                                                APInt(32, (uint32_t)Record[0])));
# 3050|         else if (CurTy->isDoubleTy())
# 3051|->         V = ConstantFP::get(Context, APFloat(APFloat::IEEEdouble(),
# 3052|                                                APInt(64, Record[0])));
# 3053|         else if (CurTy->isX86_FP80Ty()) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3058: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::x87DoubleExtended(), llvm::APInt(80U, llvm::ArrayRef<unsigned long>(Rearrange)))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3058: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3056|           Rearrange[0] = (Record[1] & 0xffffLL) | (Record[0] << 16);
# 3057|           Rearrange[1] = Record[0] >> 48;
# 3058|->         V = ConstantFP::get(Context, APFloat(APFloat::x87DoubleExtended(),
# 3059|                                                APInt(80, Rearrange)));
# 3060|         } else if (CurTy->isFP128Ty())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3061: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEquad(), llvm::APInt(128U, llvm::ArrayRef<unsigned long>(Record)))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3061: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3059|                                                APInt(80, Rearrange)));
# 3060|         } else if (CurTy->isFP128Ty())
# 3061|->         V = ConstantFP::get(Context, APFloat(APFloat::IEEEquad(),
# 3062|                                                APInt(128, Record)));
# 3063|         else if (CurTy->isPPC_FP128Ty())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3064: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::PPCDoubleDouble(), llvm::APInt(128U, llvm::ArrayRef<unsigned long>(Record)))".
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:3064: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3062|                                                APInt(128, Record)));
# 3063|         else if (CurTy->isPPC_FP128Ty())
# 3064|->         V = ConstantFP::get(Context, APFloat(APFloat::PPCDoubleDouble(),
# 3065|                                                APInt(128, Record)));
# 3066|         else

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingAllocs" is moved (indicated by "std::move(PendingAllocs)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingAllocs" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingCallsites" is moved (indicated by "std::move(PendingCallsites)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingCallsites" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingParamAccesses" is moved (indicated by "std::move(PendingParamAccesses)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingParamAccesses" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeCheckedLoadConstVCalls" is moved (indicated by "std::move(PendingTypeCheckedLoadConstVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingTypeCheckedLoadConstVCalls" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeCheckedLoadVCalls" is moved (indicated by "std::move(PendingTypeCheckedLoadVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingTypeCheckedLoadVCalls" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeTestAssumeConstVCalls" is moved (indicated by "std::move(PendingTypeTestAssumeConstVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingTypeTestAssumeConstVCalls" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeTestAssumeVCalls" is moved (indicated by "std::move(PendingTypeTestAssumeVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingTypeTestAssumeVCalls" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeTests" is moved (indicated by "std::move(PendingTypeTests)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: use_after_move: "PendingTypeTests" is used after it has been already moved.
# 7284|           PendingAllocs.clear();
# 7285|         }
# 7286|->       auto FS = std::make_unique<FunctionSummary>(
# 7287|             Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,
# 7288|             std::move(Refs), std::move(Calls), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingAllocs" is moved (indicated by "std::move(PendingAllocs)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingAllocs" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingCallsites" is moved (indicated by "std::move(PendingCallsites)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingCallsites" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingParamAccesses" is moved (indicated by "std::move(PendingParamAccesses)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingParamAccesses" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeCheckedLoadConstVCalls" is moved (indicated by "std::move(PendingTypeCheckedLoadConstVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingTypeCheckedLoadConstVCalls" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeCheckedLoadVCalls" is moved (indicated by "std::move(PendingTypeCheckedLoadVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingTypeCheckedLoadVCalls" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeTestAssumeConstVCalls" is moved (indicated by "std::move(PendingTypeTestAssumeConstVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingTypeTestAssumeConstVCalls" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeTestAssumeVCalls" is moved (indicated by "std::move(PendingTypeTestAssumeVCalls)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingTypeTestAssumeVCalls" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7286: move: "PendingTypeTests" is moved (indicated by "std::move(PendingTypeTests)").
llvm-17.0.6.src/lib/Bitcode/Reader/BitcodeReader.cpp:7430: use_after_move: "PendingTypeTests" is used after it has been already moved.
# 7428|         ValueInfo VI = std::get<0>(getValueInfoFromValueId(ValueID));
# 7429|         setSpecialRefs(Refs, NumRORefs, NumWORefs);
# 7430|->       auto FS = std::make_unique<FunctionSummary>(
# 7431|             Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,
# 7432|             std::move(Refs), std::move(Edges), std::move(PendingTypeTests),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Reader/MetadataLoader.cpp:78: constructor_uses_global_object: The constructor of global object "ImportFullTypeDefinitions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ImportFullTypeDefinitions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   /// Flag whether we need to import full type definitions for ThinLTO.
#   77|   /// Currently needed for Darwin and LLDB.
#   78|-> static cl::opt<bool> ImportFullTypeDefinitions(
#   79|       "import-full-type-definitions", cl::init(false), cl::Hidden,
#   80|       cl::desc("Import full type definitions for ThinLTO."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Reader/MetadataLoader.cpp:82: constructor_uses_global_object: The constructor of global object "DisableLazyLoading" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLazyLoading" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|       cl::desc("Import full type definitions for ThinLTO."));
#   81|   
#   82|-> static cl::opt<bool> DisableLazyLoading(
#   83|       "disable-ondemand-mds-loading", cl::init(false), cl::Hidden,
#   84|       cl::desc("Force disable the lazy-loading on-demand of metadata when "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Writer/BitcodeWriter.cpp:87: constructor_uses_global_object: The constructor of global object "IndexThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IndexThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   85|   
#   86|   static cl::opt<unsigned>
#   87|->     IndexThreshold("bitcode-mdindex-threshold", cl::Hidden, cl::init(25),
#   88|                      cl::desc("Number of metadatas above which we emit an index "
#   89|                               "to enable lazy-loading"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Writer/BitcodeWriter.cpp:90: constructor_uses_global_object: The constructor of global object "FlushThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FlushThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   88|                      cl::desc("Number of metadatas above which we emit an index "
#   89|                               "to enable lazy-loading"));
#   90|-> static cl::opt<uint32_t> FlushThreshold(
#   91|       "bitcode-flush-threshold", cl::Hidden, cl::init(512),
#   92|       cl::desc("The threshold (unit M) for flushing LLVM bitcode."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Bitcode/Writer/BitcodeWriter.cpp:94: constructor_uses_global_object: The constructor of global object "WriteRelBFToSummary" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "WriteRelBFToSummary" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   92|       cl::desc("The threshold (unit M) for flushing LLVM bitcode."));
#   93|   
#   94|-> static cl::opt<bool> WriteRelBFToSummary(
#   95|       "write-relbf-to-summary", cl::Hidden, cl::init(false),
#   96|       cl::desc("Write relative block frequency to function summary "));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AggressiveAntiDepBreaker.cpp:45: constructor_uses_global_object: The constructor of global object "DebugDiv" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugDiv" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|   // If DebugDiv > 0 then only break antidep with (ID % DebugDiv) == DebugMod
#   44|   static cl::opt<int>
#   45|-> DebugDiv("agg-antidep-debugdiv",
#   46|            cl::desc("Debug control for aggressive anti-dep breaker"),
#   47|            cl::init(0), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AggressiveAntiDepBreaker.cpp:50: constructor_uses_global_object: The constructor of global object "DebugMod" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugMod" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|   
#   49|   static cl::opt<int>
#   50|-> DebugMod("agg-antidep-debugmod",
#   51|            cl::desc("Debug control for aggressive anti-dep breaker"),
#   52|            cl::init(0), cl::Hidden);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/AccelTable.cpp:408: var_decl: Declaring variable "UA".
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/AccelTable.cpp:415: uninit_use: Using uninitialized value "UA". Field "UA.InlineElts" is uninitialized.
#  413|     }
#  414|     UA.push_back({dwarf::DW_IDX_die_offset, dwarf::DW_FORM_ref4});
#  415|->   return UA;
#  416|   }
#  417|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:134: constructor_uses_global_object: The constructor of global object "BasicBlockProfileDump[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BasicBlockProfileDump[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  132|   #define DEBUG_TYPE "asm-printer"
#  133|   
#  134|-> static cl::opt<std::string> BasicBlockProfileDump(
#  135|       "mbb-profile-dump", cl::Hidden,
#  136|       cl::desc("Basic block profile dump for external cost modelling. If "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:30: constructor_uses_global_object: The constructor of global object "TrimVarLocs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TrimVarLocs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   /// If true, we drop variable location ranges which exist entirely outside the
#   29|   /// variable's lexical scope instruction ranges.
#   30|-> static cl::opt<bool> TrimVarLocs("trim-var-locs", cl::Hidden, cl::init(true));
#   31|   
#   32|   std::optional<DbgVariableLocation>

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:964: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:967: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  965|     auto *Array = dyn_cast<DICompositeType>(Var->getType());
#  966|     if (!Array || Array->getTag() != dwarf::DW_TAG_array_type)
#  967|->     return Result;
#  968|     if (auto *DLVar = Array->getDataLocation())
#  969|       Result.push_back(DLVar);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:964: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:1003: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1001|       }
# 1002|     }
# 1003|->   return Result;
# 1004|   }
# 1005|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:1010: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:1049: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1047|       if (!Res.second) {
# 1048|         assert(false && "dependency cycle in local variables");
# 1049|->       return Result;
# 1050|       }
# 1051|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:69: constructor_uses_global_object: The constructor of global object "UseDwarfRangesBaseAddressSpecifier" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseDwarfRangesBaseAddressSpecifier" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|   STATISTIC(NumCSParams, "Number of dbg call site params created");
#   68|   
#   69|-> static cl::opt<bool> UseDwarfRangesBaseAddressSpecifier(
#   70|       "use-dwarf-ranges-base-address-specifier", cl::Hidden,
#   71|       cl::desc("Use base address specifiers in debug_ranges"), cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:73: constructor_uses_global_object: The constructor of global object "GenerateARangeSection" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GenerateARangeSection" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|       cl::desc("Use base address specifiers in debug_ranges"), cl::init(false));
#   72|   
#   73|-> static cl::opt<bool> GenerateARangeSection("generate-arange-section",
#   74|                                              cl::Hidden,
#   75|                                              cl::desc("Generate dwarf aranges"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:79: constructor_uses_global_object: The constructor of global object "GenerateDwarfTypeUnits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GenerateDwarfTypeUnits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   
#   78|   static cl::opt<bool>
#   79|->     GenerateDwarfTypeUnits("generate-type-units", cl::Hidden,
#   80|                              cl::desc("Generate DWARF4 type units."),
#   81|                              cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:83: constructor_uses_global_object: The constructor of global object "SplitDwarfCrossCuReferences" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SplitDwarfCrossCuReferences" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   81|                              cl::init(false));
#   82|   
#   83|-> static cl::opt<bool> SplitDwarfCrossCuReferences(
#   84|       "split-dwarf-cross-cu-references", cl::Hidden,
#   85|       cl::desc("Enable cross-cu references in DWO files"), cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:89: constructor_uses_global_object: The constructor of global object "UnknownLocations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnknownLocations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   87|   enum DefaultOnOff { Default, Enable, Disable };
#   88|   
#   89|-> static cl::opt<DefaultOnOff> UnknownLocations(
#   90|       "use-unknown-locations", cl::Hidden,
#   91|       cl::desc("Make an absence of debug location information explicit."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:96: constructor_uses_global_object: The constructor of global object "AccelTables" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AccelTables" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   94|       cl::init(Default));
#   95|   
#   96|-> static cl::opt<AccelTableKind> AccelTables(
#   97|       "accel-tables", cl::Hidden, cl::desc("Output dwarf accelerator tables."),
#   98|       cl::values(clEnumValN(AccelTableKind::Default, "Default",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:106: constructor_uses_global_object: The constructor of global object "DwarfInlinedStrings" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DwarfInlinedStrings" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  104|   
#  105|   static cl::opt<DefaultOnOff>
#  106|-> DwarfInlinedStrings("dwarf-inlined-strings", cl::Hidden,
#  107|                    cl::desc("Use inlined strings rather than string section."),
#  108|                    cl::values(clEnumVal(Default, "Default for platform"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:114: constructor_uses_global_object: The constructor of global object "NoDwarfRangesSection" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoDwarfRangesSection" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|   
#  113|   static cl::opt<bool>
#  114|->     NoDwarfRangesSection("no-dwarf-ranges-section", cl::Hidden,
#  115|                            cl::desc("Disable emission .debug_ranges section."),
#  116|                            cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:118: constructor_uses_global_object: The constructor of global object "DwarfSectionsAsReferences" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DwarfSectionsAsReferences" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  116|                            cl::init(false));
#  117|   
#  118|-> static cl::opt<DefaultOnOff> DwarfSectionsAsReferences(
#  119|       "dwarf-sections-as-references", cl::Hidden,
#  120|       cl::desc("Use sections+offset as references rather than labels."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:126: constructor_uses_global_object: The constructor of global object "UseGNUDebugMacro" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseGNUDebugMacro" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  124|   
#  125|   static cl::opt<bool>
#  126|->     UseGNUDebugMacro("use-gnu-debug-macro", cl::Hidden,
#  127|                        cl::desc("Emit the GNU .debug_macro format with DWARF <5"),
#  128|                        cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:130: constructor_uses_global_object: The constructor of global object "DwarfOpConvert" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DwarfOpConvert" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|                        cl::init(false));
#  129|   
#  130|-> static cl::opt<DefaultOnOff> DwarfOpConvert(
#  131|       "dwarf-op-convert", cl::Hidden,
#  132|       cl::desc("Enable use of the DWARFv5 DW_OP_convert operator"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:144: constructor_uses_global_object: The constructor of global object "DwarfLinkageNames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DwarfLinkageNames" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  142|   
#  143|   static cl::opt<LinkageNameOption>
#  144|->     DwarfLinkageNames("dwarf-linkage-names", cl::Hidden,
#  145|                         cl::desc("Which DWARF linkage-name attributes to emit."),
#  146|                         cl::values(clEnumValN(DefaultLinkageNames, "Default",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:153: constructor_uses_global_object: The constructor of global object "MinimizeAddrInV5Option" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MinimizeAddrInV5Option" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  151|                         cl::init(DefaultLinkageNames));
#  152|   
#  153|-> static cl::opt<DwarfDebug::MinimizeAddrInV5> MinimizeAddrInV5Option(
#  154|       "minimize-addr-in-v5", cl::Hidden,
#  155|       cl::desc("Always use DW_AT_ranges in DWARFv5 whenever it could allow more "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:1569: var_decl: Declaring variable "LocEntry".
llvm-17.0.6.src/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:1570: uninit_use_in_call: Using uninitialized value "LocEntry". Field "LocEntry.Constant" is uninitialized when calling "DbgValueLoc".
# 1568|         MachineLocation MLoc(VI.getEntryValueRegister(), /*IsIndirect*/ true);
# 1569|         auto LocEntry = DbgValueLocEntry(MLoc);
# 1570|->       RegVar->initializeDbgValue(DbgValueLoc(VI.Expr, LocEntry));
# 1571|       }
# 1572|       LLVM_DEBUG(dbgs() << "Created DbgVariable for " << VI.Var->getName()

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AssignmentTrackingAnalysis.cpp:41: constructor_uses_global_object: The constructor of global object "MaxNumBlocks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxNumBlocks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   
#   40|   static cl::opt<unsigned>
#   41|->     MaxNumBlocks("debug-ata-max-blocks", cl::init(10000),
#   42|                    cl::desc("Maximum num basic blocks before debug info dropped"),
#   43|                    cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AssignmentTrackingAnalysis.cpp:46: constructor_uses_global_object: The constructor of global object "EnableMemLocFragFill" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMemLocFragFill" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   /// Option for debugging the pass, determines if the memory location fragment
#   45|   /// filling happens after generating the variable locations.
#   46|-> static cl::opt<bool> EnableMemLocFragFill("mem-loc-frag-fill", cl::init(true),
#   47|                                             cl::Hidden);
#   48|   /// Print the results of the analysis. Respects -filter-print-funcs.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AssignmentTrackingAnalysis.cpp:49: constructor_uses_global_object: The constructor of global object "PrintResults" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintResults" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|                                             cl::Hidden);
#   48|   /// Print the results of the analysis. Respects -filter-print-funcs.
#   49|-> static cl::opt<bool> PrintResults("print-debug-ata", cl::init(false),
#   50|                                     cl::Hidden);
#   51|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/AssignmentTrackingAnalysis.cpp:56: constructor_uses_global_object: The constructor of global object "CoalesceAdjacentFragmentsOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CoalesceAdjacentFragmentsOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   /// construction for each explicitly stated variable fragment.
#   55|   static cl::opt<cl::boolOrDefault>
#   56|->     CoalesceAdjacentFragmentsOpt("debug-ata-coalesce-frags", cl::Hidden);
#   57|   
#   58|   // Implicit conversions are disabled for enum class types, so unfortunately we

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/AtomicExpandPass.cpp:1792: var_decl: Declaring variable "RTLibType" without initializer.
llvm-17.0.6.src/lib/CodeGen/AtomicExpandPass.cpp:1819: uninit_use_in_call: Using uninitialized value "RTLibType" when calling "getLibcallName".
# 1817|     }
# 1818|   
# 1819|->   if (!TLI->getLibcallName(RTLibType)) {
# 1820|       // This target does not implement the requested atomic libcall so give up.
# 1821|       return false;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/BasicBlockSections.cpp:89: constructor_uses_global_object: The constructor of global object "llvm::BBSectionsColdTextPrefix[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::BBSectionsColdTextPrefix[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   87|   // section granularity. Defaults to ".text.split." which is recognized by lld
#   88|   // via the `-z keep-text-section-prefix` flag.
#   89|-> cl::opt<std::string> llvm::BBSectionsColdTextPrefix(
#   90|       "bbsections-cold-text-prefix",
#   91|       cl::desc("The text prefix to use for cold basic block clusters"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/BasicBlockSections.cpp:94: constructor_uses_global_object: The constructor of global object "BBSectionsDetectSourceDrift" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BBSectionsDetectSourceDrift" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   92|       cl::init(".text.split."), cl::Hidden);
#   93|   
#   94|-> static cl::opt<bool> BBSectionsDetectSourceDrift(
#   95|       "bbsections-detect-source-drift",
#   96|       cl::desc("This checks if there is a fdo instr. profile hash "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/BasicTargetTransformInfo.cpp:28: constructor_uses_global_object: The constructor of global object "llvm::PartialUnrollingThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PartialUnrollingThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   // provide a definition.
#   27|   cl::opt<unsigned>
#   28|-> llvm::PartialUnrollingThreshold("partial-unrolling-threshold", cl::init(0),
#   29|                                   cl::desc("Threshold for partial unrolling"),
#   30|                                   cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/BranchFolding.cpp:73: constructor_uses_global_object: The constructor of global object "FlagEnableTailMerge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FlagEnableTailMerge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   STATISTIC(NumTailCalls,  "Number of tail calls optimized");
#   72|   
#   73|-> static cl::opt<cl::boolOrDefault> FlagEnableTailMerge("enable-tail-merge",
#   74|                                 cl::init(cl::BOU_UNSET), cl::Hidden);
#   75|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/BranchFolding.cpp:78: constructor_uses_global_object: The constructor of global object "TailMergeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailMergeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   // Throttle for huge numbers of predecessors (compile speed problems)
#   77|   static cl::opt<unsigned>
#   78|-> TailMergeThreshold("tail-merge-threshold",
#   79|             cl::desc("Max number of predecessors to consider tail merging"),
#   80|             cl::init(150), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/BranchFolding.cpp:85: constructor_uses_global_object: The constructor of global object "TailMergeSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailMergeSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|   // TODO: This should be replaced with a target query.
#   84|   static cl::opt<unsigned>
#   85|-> TailMergeSize("tail-merge-size",
#   86|                 cl::desc("Min number of instructions to consider tail merging"),
#   87|                 cl::init(3), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CFIInstrInserter.cpp:31: constructor_uses_global_object: The constructor of global object "VerifyCFI" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyCFI" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   using namespace llvm;
#   30|   
#   31|-> static cl::opt<bool> VerifyCFI("verify-cfiinstrs",
#   32|       cl::desc("Verify Call Frame Information instructions"),
#   33|       cl::init(false),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/CallBrPrepare.cpp:86: var_decl: Declaring variable "CBRs".
llvm-17.0.6.src/lib/CodeGen/CallBrPrepare.cpp:91: uninit_use: Using uninitialized value "CBRs". Field "CBRs.InlineElts" is uninitialized.
#   89|         if (!CBR->getType()->isVoidTy() && !CBR->use_empty())
#   90|           CBRs.push_back(CBR);
#   91|->   return CBRs;
#   92|   }
#   93|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:135: constructor_uses_global_object: The constructor of global object "DisableBranchOpts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBranchOpts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|   STATISTIC(NumStoreExtractExposed, "Number of store(extractelement) exposed");
#  134|   
#  135|-> static cl::opt<bool> DisableBranchOpts(
#  136|       "disable-cgp-branch-opts", cl::Hidden, cl::init(false),
#  137|       cl::desc("Disable branch optimizations in CodeGenPrepare"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:140: constructor_uses_global_object: The constructor of global object "DisableGCOpts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableGCOpts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|   
#  139|   static cl::opt<bool>
#  140|->     DisableGCOpts("disable-cgp-gc-opts", cl::Hidden, cl::init(false),
#  141|                     cl::desc("Disable GC optimizations in CodeGenPrepare"));
#  142|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:144: constructor_uses_global_object: The constructor of global object "DisableSelectToBranch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSelectToBranch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  142|   
#  143|   static cl::opt<bool>
#  144|->     DisableSelectToBranch("disable-cgp-select2branch", cl::Hidden,
#  145|                             cl::init(false),
#  146|                             cl::desc("Disable select to branch conversion."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:149: constructor_uses_global_object: The constructor of global object "AddrSinkUsingGEPs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkUsingGEPs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  147|   
#  148|   static cl::opt<bool>
#  149|->     AddrSinkUsingGEPs("addr-sink-using-gep", cl::Hidden, cl::init(true),
#  150|                         cl::desc("Address sinking in CGP using GEPs."));
#  151|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:153: constructor_uses_global_object: The constructor of global object "EnableAndCmpSinking" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAndCmpSinking" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  151|   
#  152|   static cl::opt<bool>
#  153|->     EnableAndCmpSinking("enable-andcmp-sinking", cl::Hidden, cl::init(true),
#  154|                           cl::desc("Enable sinkinig and/cmp into branches."));
#  155|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:156: constructor_uses_global_object: The constructor of global object "DisableStoreExtract" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableStoreExtract" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  154|                           cl::desc("Enable sinkinig and/cmp into branches."));
#  155|   
#  156|-> static cl::opt<bool> DisableStoreExtract(
#  157|       "disable-cgp-store-extract", cl::Hidden, cl::init(false),
#  158|       cl::desc("Disable store(extract) optimizations in CodeGenPrepare"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:160: constructor_uses_global_object: The constructor of global object "StressStoreExtract" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StressStoreExtract" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  158|       cl::desc("Disable store(extract) optimizations in CodeGenPrepare"));
#  159|   
#  160|-> static cl::opt<bool> StressStoreExtract(
#  161|       "stress-cgp-store-extract", cl::Hidden, cl::init(false),
#  162|       cl::desc("Stress test store(extract) optimizations in CodeGenPrepare"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:164: constructor_uses_global_object: The constructor of global object "DisableExtLdPromotion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableExtLdPromotion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  162|       cl::desc("Stress test store(extract) optimizations in CodeGenPrepare"));
#  163|   
#  164|-> static cl::opt<bool> DisableExtLdPromotion(
#  165|       "disable-cgp-ext-ld-promotion", cl::Hidden, cl::init(false),
#  166|       cl::desc("Disable ext(promotable(ld)) -> promoted(ext(ld)) optimization in "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:169: constructor_uses_global_object: The constructor of global object "StressExtLdPromotion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StressExtLdPromotion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  167|                "CodeGenPrepare"));
#  168|   
#  169|-> static cl::opt<bool> StressExtLdPromotion(
#  170|       "stress-cgp-ext-ld-promotion", cl::Hidden, cl::init(false),
#  171|       cl::desc("Stress test ext(promotable(ld)) -> promoted(ext(ld)) "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:174: constructor_uses_global_object: The constructor of global object "DisablePreheaderProtect" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePreheaderProtect" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  172|                "optimization in CodeGenPrepare"));
#  173|   
#  174|-> static cl::opt<bool> DisablePreheaderProtect(
#  175|       "disable-preheader-prot", cl::Hidden, cl::init(false),
#  176|       cl::desc("Disable protection against removing loop preheaders"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:178: constructor_uses_global_object: The constructor of global object "ProfileGuidedSectionPrefix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ProfileGuidedSectionPrefix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  176|       cl::desc("Disable protection against removing loop preheaders"));
#  177|   
#  178|-> static cl::opt<bool> ProfileGuidedSectionPrefix(
#  179|       "profile-guided-section-prefix", cl::Hidden, cl::init(true),
#  180|       cl::desc("Use profile info to add section prefix for hot/cold functions"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:182: constructor_uses_global_object: The constructor of global object "ProfileUnknownInSpecialSection" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ProfileUnknownInSpecialSection" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  180|       cl::desc("Use profile info to add section prefix for hot/cold functions"));
#  181|   
#  182|-> static cl::opt<bool> ProfileUnknownInSpecialSection(
#  183|       "profile-unknown-in-special-section", cl::Hidden,
#  184|       cl::desc("In profiling mode like sampleFDO, if a function doesn't have "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:192: constructor_uses_global_object: The constructor of global object "BBSectionsGuidedSectionPrefix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BBSectionsGuidedSectionPrefix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  190|                "RAM for example. "));
#  191|   
#  192|-> static cl::opt<bool> BBSectionsGuidedSectionPrefix(
#  193|       "bbsections-guided-section-prefix", cl::Hidden, cl::init(true),
#  194|       cl::desc("Use the basic-block-sections profile to determine the text "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:201: constructor_uses_global_object: The constructor of global object "FreqRatioToSkipMerge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FreqRatioToSkipMerge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  199|                "profiles."));
#  200|   
#  201|-> static cl::opt<unsigned> FreqRatioToSkipMerge(
#  202|       "cgp-freq-ratio-to-skip-merge", cl::Hidden, cl::init(2),
#  203|       cl::desc("Skip merging empty blocks if (frequency of empty block) / "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:206: constructor_uses_global_object: The constructor of global object "ForceSplitStore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceSplitStore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  204|                "(frequency of destination block) is greater than this ratio"));
#  205|   
#  206|-> static cl::opt<bool> ForceSplitStore(
#  207|       "force-split-store", cl::Hidden, cl::init(false),
#  208|       cl::desc("Force store splitting no matter what the target query says."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:210: constructor_uses_global_object: The constructor of global object "EnableTypePromotionMerge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableTypePromotionMerge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  208|       cl::desc("Force store splitting no matter what the target query says."));
#  209|   
#  210|-> static cl::opt<bool> EnableTypePromotionMerge(
#  211|       "cgp-type-promotion-merge", cl::Hidden,
#  212|       cl::desc("Enable merging of redundant sexts when one is dominating"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:216: constructor_uses_global_object: The constructor of global object "DisableComplexAddrModes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableComplexAddrModes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  214|       cl::init(true));
#  215|   
#  216|-> static cl::opt<bool> DisableComplexAddrModes(
#  217|       "disable-complex-addr-modes", cl::Hidden, cl::init(false),
#  218|       cl::desc("Disables combining addressing modes with different parts "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:222: constructor_uses_global_object: The constructor of global object "AddrSinkNewPhis" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkNewPhis" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  220|   
#  221|   static cl::opt<bool>
#  222|->     AddrSinkNewPhis("addr-sink-new-phis", cl::Hidden, cl::init(false),
#  223|                       cl::desc("Allow creation of Phis in Address sinking."));
#  224|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:225: constructor_uses_global_object: The constructor of global object "AddrSinkNewSelects" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkNewSelects" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  223|                       cl::desc("Allow creation of Phis in Address sinking."));
#  224|   
#  225|-> static cl::opt<bool> AddrSinkNewSelects(
#  226|       "addr-sink-new-select", cl::Hidden, cl::init(true),
#  227|       cl::desc("Allow creation of selects in Address sinking."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:229: constructor_uses_global_object: The constructor of global object "AddrSinkCombineBaseReg" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkCombineBaseReg" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  227|       cl::desc("Allow creation of selects in Address sinking."));
#  228|   
#  229|-> static cl::opt<bool> AddrSinkCombineBaseReg(
#  230|       "addr-sink-combine-base-reg", cl::Hidden, cl::init(true),
#  231|       cl::desc("Allow combining of BaseReg field in Address sinking."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:233: constructor_uses_global_object: The constructor of global object "AddrSinkCombineBaseGV" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkCombineBaseGV" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  231|       cl::desc("Allow combining of BaseReg field in Address sinking."));
#  232|   
#  233|-> static cl::opt<bool> AddrSinkCombineBaseGV(
#  234|       "addr-sink-combine-base-gv", cl::Hidden, cl::init(true),
#  235|       cl::desc("Allow combining of BaseGV field in Address sinking."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:237: constructor_uses_global_object: The constructor of global object "AddrSinkCombineBaseOffs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkCombineBaseOffs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  235|       cl::desc("Allow combining of BaseGV field in Address sinking."));
#  236|   
#  237|-> static cl::opt<bool> AddrSinkCombineBaseOffs(
#  238|       "addr-sink-combine-base-offs", cl::Hidden, cl::init(true),
#  239|       cl::desc("Allow combining of BaseOffs field in Address sinking."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:241: constructor_uses_global_object: The constructor of global object "AddrSinkCombineScaledReg" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AddrSinkCombineScaledReg" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  239|       cl::desc("Allow combining of BaseOffs field in Address sinking."));
#  240|   
#  241|-> static cl::opt<bool> AddrSinkCombineScaledReg(
#  242|       "addr-sink-combine-scaled-reg", cl::Hidden, cl::init(true),
#  243|       cl::desc("Allow combining of ScaledReg field in Address sinking."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:246: constructor_uses_global_object: The constructor of global object "EnableGEPOffsetSplit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGEPOffsetSplit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  244|   
#  245|   static cl::opt<bool>
#  246|->     EnableGEPOffsetSplit("cgp-split-large-offset-gep", cl::Hidden,
#  247|                            cl::init(true),
#  248|                            cl::desc("Enable splitting large offset of GEP."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:250: constructor_uses_global_object: The constructor of global object "EnableICMP_EQToICMP_ST" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableICMP_EQToICMP_ST" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  248|                            cl::desc("Enable splitting large offset of GEP."));
#  249|   
#  250|-> static cl::opt<bool> EnableICMP_EQToICMP_ST(
#  251|       "cgp-icmp-eq2icmp-st", cl::Hidden, cl::init(false),
#  252|       cl::desc("Enable ICMP_EQ to ICMP_S(L|G)T conversion."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:255: constructor_uses_global_object: The constructor of global object "VerifyBFIUpdates" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyBFIUpdates" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  253|   
#  254|   static cl::opt<bool>
#  255|->     VerifyBFIUpdates("cgp-verify-bfi-updates", cl::Hidden, cl::init(false),
#  256|                        cl::desc("Enable BFI update verification for "
#  257|                                 "CodeGenPrepare."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:260: constructor_uses_global_object: The constructor of global object "OptimizePhiTypes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptimizePhiTypes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  258|   
#  259|   static cl::opt<bool>
#  260|->     OptimizePhiTypes("cgp-optimize-phi-types", cl::Hidden, cl::init(true),
#  261|                        cl::desc("Enable converting phi types in CodeGenPrepare"));
#  262|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:264: constructor_uses_global_object: The constructor of global object "HugeFuncThresholdInCGPP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HugeFuncThresholdInCGPP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  262|   
#  263|   static cl::opt<unsigned>
#  264|->     HugeFuncThresholdInCGPP("cgpp-huge-func", cl::init(10000), cl::Hidden,
#  265|                               cl::desc("Least BB number of huge function."));
#  266|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/CodeGenPrepare.cpp:268: constructor_uses_global_object: The constructor of global object "MaxAddressUsersToScan" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxAddressUsersToScan" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  266|   
#  267|   static cl::opt<unsigned>
#  268|->     MaxAddressUsersToScan("cgp-max-address-users-to-scan", cl::init(100),
#  269|                             cl::Hidden,
#  270|                             cl::desc("Max number of address users to look at"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ComplexDeinterleavingPass.cpp:83: constructor_uses_global_object: The constructor of global object "ComplexDeinterleavingEnabled" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ComplexDeinterleavingEnabled" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   81|   STATISTIC(NumComplexTransformations, "Amount of complex patterns transformed");
#   82|   
#   83|-> static cl::opt<bool> ComplexDeinterleavingEnabled(
#   84|       "enable-complex-deinterleaving",
#   85|       cl::desc("Enable generation of complex instructions"), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/DFAPacketizer.cpp:48: constructor_uses_global_object: The constructor of global object "InstrLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InstrLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   #define DEBUG_TYPE "packets"
#   47|   
#   48|-> static cl::opt<unsigned> InstrLimit("dfa-instr-limit", cl::Hidden,
#   49|     cl::init(0), cl::desc("If present, stops packetizing after N instructions"));
#   50|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/EarlyIfConversion.cpp:48: constructor_uses_global_object: The constructor of global object "BlockInstrLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BlockInstrLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   // This bypasses all other heuristics, so it should be set fairly high.
#   47|   static cl::opt<unsigned>
#   48|-> BlockInstrLimit("early-ifcvt-limit", cl::init(30), cl::Hidden,
#   49|     cl::desc("Maximum number of instructions per speculated block."));
#   50|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/EarlyIfConversion.cpp:52: constructor_uses_global_object: The constructor of global object "Stress" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Stress" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|   
#   51|   // Stress testing mode - disable heuristics.
#   52|-> static cl::opt<bool> Stress("stress-early-ifcvt", cl::Hidden,
#   53|     cl::desc("Turn all knobs to 11"));
#   54|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/EdgeBundles.cpp:26: constructor_uses_global_object: The constructor of global object "ViewEdgeBundles" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ViewEdgeBundles" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   
#   25|   static cl::opt<bool>
#   26|-> ViewEdgeBundles("view-edge-bundles", cl::Hidden,
#   27|                   cl::desc("Pop up a window to show edge bundle graphs"));
#   28|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandLargeDivRem.cpp:36: constructor_uses_global_object: The constructor of global object "ExpandDivRemBits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExpandDivRemBits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   
#   35|   static cl::opt<unsigned>
#   36|->     ExpandDivRemBits("expand-div-rem-bits", cl::Hidden,
#   37|                        cl::init(llvm::IntegerType::MAX_INT_BITS),
#   38|                        cl::desc("div and rem instructions on integers with "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandLargeFpConvert.cpp:35: constructor_uses_global_object: The constructor of global object "ExpandFpConvertBits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExpandFpConvertBits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   static cl::opt<unsigned>
#   35|->     ExpandFpConvertBits("expand-fp-convert-bits", cl::Hidden,
#   36|                        cl::init(llvm::IntegerType::MAX_INT_BITS),
#   37|                        cl::desc("fp convert instructions on integers with "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandMemCmp.cpp:47: constructor_uses_global_object: The constructor of global object "MemCmpEqZeroNumLoadsPerBlock" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemCmpEqZeroNumLoadsPerBlock" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   STATISTIC(NumMemCmpInlined, "Number of inlined memcmp calls");
#   46|   
#   47|-> static cl::opt<unsigned> MemCmpEqZeroNumLoadsPerBlock(
#   48|       "memcmp-num-loads-per-block", cl::Hidden, cl::init(1),
#   49|       cl::desc("The number of loads per basic block for inline expansion of "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandMemCmp.cpp:52: constructor_uses_global_object: The constructor of global object "MaxLoadsPerMemcmp" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxLoadsPerMemcmp" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|                "memcmp that is only being compared against zero."));
#   51|   
#   52|-> static cl::opt<unsigned> MaxLoadsPerMemcmp(
#   53|       "max-loads-per-memcmp", cl::Hidden,
#   54|       cl::desc("Set maximum number of loads used in expanded memcmp"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandMemCmp.cpp:56: constructor_uses_global_object: The constructor of global object "MaxLoadsPerMemcmpOptSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxLoadsPerMemcmpOptSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|       cl::desc("Set maximum number of loads used in expanded memcmp"));
#   55|   
#   56|-> static cl::opt<unsigned> MaxLoadsPerMemcmpOptSize(
#   57|       "max-loads-per-memcmp-opt-size", cl::Hidden,
#   58|       cl::desc("Set maximum number of loads used in expanded memcmp for -Os/Oz"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/ExpandMemCmp.cpp:199: var_decl: Declaring variable "LoadSequence".
llvm-17.0.6.src/lib/CodeGen/ExpandMemCmp.cpp:210: uninit_use: Using uninitialized value "LoadSequence". Field "LoadSequence.InlineElts" is uninitialized.
#  208|     LoadSequence.push_back({MaxLoadSize, Offset - (MaxLoadSize - Size)});
#  209|     NumLoadsNonOneByte = 1;
#  210|->   return LoadSequence;
#  211|   }
#  212|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandVectorPredication.cpp:48: constructor_uses_global_object: The constructor of global object "EVLTransformOverride[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EVLTransformOverride[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   
#   47|   // Override options.
#   48|-> static cl::opt<std::string> EVLTransformOverride(
#   49|       "expandvp-override-evl-transform", cl::init(""), cl::Hidden,
#   50|       cl::desc("Options: <empty>" VPINTERNAL_VPLEGAL_CASES

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ExpandVectorPredication.cpp:56: constructor_uses_global_object: The constructor of global object "MaskTransformOverride[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaskTransformOverride[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|                "testing)."));
#   55|   
#   56|-> static cl::opt<std::string> MaskTransformOverride(
#   57|       "expandvp-override-mask-transform", cl::init(""), cl::Hidden,
#   58|       cl::desc("Options: <empty>" VPINTERNAL_VPLEGAL_CASES

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/FixupStatepointCallerSaved.cpp:40: constructor_uses_global_object: The constructor of global object "FixupSCSExtendSlotSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FixupSCSExtendSlotSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   STATISTIC(NumSpillSlotsExtended, "Number of spill slots extended");
#   39|   
#   40|-> static cl::opt<bool> FixupSCSExtendSlotSize(
#   41|       "fixup-scs-extend-slot-size", cl::Hidden, cl::init(false),
#   42|       cl::desc("Allow spill in spill slot of greater size than register size"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/FixupStatepointCallerSaved.cpp:45: constructor_uses_global_object: The constructor of global object "PassGCPtrInCSR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PassGCPtrInCSR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|       cl::Hidden);
#   44|   
#   45|-> static cl::opt<bool> PassGCPtrInCSR(
#   46|       "fixup-allow-gcptr-in-csr", cl::Hidden, cl::init(false),
#   47|       cl::desc("Allow passing GC Pointer arguments in callee saved registers"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/FixupStatepointCallerSaved.cpp:49: constructor_uses_global_object: The constructor of global object "EnableCopyProp" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCopyProp" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|       cl::desc("Allow passing GC Pointer arguments in callee saved registers"));
#   48|   
#   49|-> static cl::opt<bool> EnableCopyProp(
#   50|       "fixup-scs-enable-copy-propagation", cl::Hidden, cl::init(true),
#   51|       cl::desc("Enable simple copy propagation during register reloading"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/FixupStatepointCallerSaved.cpp:55: constructor_uses_global_object: The constructor of global object "MaxStatepointsWithRegs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxStatepointsWithRegs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   // This is purely debugging option.
#   54|   // It may be handy for investigating statepoint spilling issues.
#   55|-> static cl::opt<unsigned> MaxStatepointsWithRegs(
#   56|       "fixup-max-csr-statepoints", cl::Hidden,
#   57|       cl::desc("Max number of statepoints allowed to pass GC Ptrs in registers"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/Combiner.cpp:31: constructor_uses_global_object: The constructor of global object "llvm::GICombinerOptionCategory" itself makes use of global object "GlobalParser" defined in another compilation unit.  The order of construction is unspecified, so "llvm::GICombinerOptionCategory" might be created before "GlobalParser" is available.
#   29|   
#   30|   namespace llvm {
#   31|-> cl::OptionCategory GICombinerOptionCategory(
#   32|       "GlobalISel Combiner",
#   33|       "Control the rules which are enabled. These options all take a comma "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:47: constructor_uses_global_object: The constructor of global object "ForceLegalIndexing" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceLegalIndexing" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   // addressing.
#   46|   static cl::opt<bool>
#   47|->     ForceLegalIndexing("force-legal-indexing", cl::Hidden, cl::init(false),
#   48|                          cl::desc("Force all indexed operations to be "
#   49|                                   "legal for the GlobalISel combiner"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:1323: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(sqrt(Result.convertToDouble()))".
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:1323: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1321|       Result.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,
# 1322|                      &Unused);
# 1323|->     Result = APFloat(sqrt(Result.convertToDouble()));
# 1324|       break;
# 1325|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:1330: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(log2(Result.convertToDouble()))".
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:1330: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1328|       Result.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,
# 1329|                      &Unused);
# 1330|->     Result = APFloat(log2(Result.convertToDouble()));
# 1331|       break;
# 1332|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:4687: var_decl: Declaring variable "NewOpcode" without initializer.
llvm-17.0.6.src/lib/CodeGen/GlobalISel/CombinerHelper.cpp:4703: uninit_use_in_call: Using uninitialized value "NewOpcode" when calling "get".
# 4701|       }
# 4702|       Observer.changingInstr(MI);
# 4703|->     MI.setDesc(B.getTII().get(NewOpcode));
# 4704|       MI.removeOperand(4);
# 4705|       Observer.changedInstr(MI);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/IRTranslator.cpp:98: constructor_uses_global_object: The constructor of global object "EnableCSEInIRTranslator" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCSEInIRTranslator" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   96|   
#   97|   static cl::opt<bool>
#   98|->     EnableCSEInIRTranslator("enable-cse-in-irtranslator",
#   99|                               cl::desc("Should enable CSE in irtranslator"),
#  100|                               cl::Optional, cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/Legalizer.cpp:39: constructor_uses_global_object: The constructor of global object "EnableCSEInLegalizer" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCSEInLegalizer" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   
#   38|   static cl::opt<bool>
#   39|->     EnableCSEInLegalizer("enable-cse-in-legalizer",
#   40|                            cl::desc("Should enable CSE in Legalizer"),
#   41|                            cl::Optional, cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/Legalizer.cpp:44: constructor_uses_global_object: The constructor of global object "AllowGInsertAsArtifact" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AllowGInsertAsArtifact" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   
#   43|   // This is a temporary hack, should be removed soon.
#   44|-> static cl::opt<bool> AllowGInsertAsArtifact(
#   45|       "allow-ginsert-as-artifact",
#   46|       cl::desc("Allow G_INSERT to be considered an artifact. Hack around AMDGPU "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:6179: var_decl: Declaring variable "TwoPExpFP".
llvm-17.0.6.src/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:6182: uninit_use_in_call: Using uninitialized value "TwoPExpFP.U" when calling "convertFromAPInt".
# 6180|                                                   : APFloat::IEEEdouble(),
# 6181|                       APInt::getZero(SrcTy.getSizeInBits()));
# 6182|->   TwoPExpFP.convertFromAPInt(TwoPExpInt, false, APFloat::rmNearestTiesToEven);
# 6183|   
# 6184|     MachineInstrBuilder FPTOSI = MIRBuilder.buildFPTOSI(DstTy, Src);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/LegalizerInfo.cpp:32: constructor_uses_global_object: The constructor of global object "llvm::DisableGISelLegalityCheck" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DisableGISelLegalityCheck" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   #define DEBUG_TYPE "legalizer-info"
#   31|   
#   32|-> cl::opt<bool> llvm::DisableGISelLegalityCheck(
#   33|       "disable-gisel-legality-check",
#   34|       cl::desc("Don't verify that MIR is fully legal between GlobalISel passes"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/RegBankSelect.cpp:53: constructor_uses_global_object: The constructor of global object "RegBankSelectMode" itself makes use of global object "llvm::cl::AllSubCommands" defined in another compilation unit.  The order of construction is unspecified, so "RegBankSelectMode" might be created before "llvm::cl::AllSubCommands" is available.
#   51|   using namespace llvm;
#   52|   
#   53|-> static cl::opt<RegBankSelect::Mode> RegBankSelectMode(
#   54|       cl::desc("Mode of the RegBankSelect pass"), cl::Hidden, cl::Optional,
#   55|       cl::values(clEnumValN(RegBankSelect::Mode::Fast, "regbankselect-fast",

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/GlobalISel/Utils.cpp:781: var_decl: Declaring variable "DstVal".
llvm-17.0.6.src/lib/CodeGen/GlobalISel/Utils.cpp:782: uninit_use_in_call: Using uninitialized value "DstVal.U" when calling "convertFromAPInt".
#  780|     if (auto MaybeSrcVal = getIConstantVRegVal(Src, MRI)) {
#  781|       APFloat DstVal(getFltSemanticForLLT(DstTy));
#  782|->     DstVal.convertFromAPInt(*MaybeSrcVal, Opcode == TargetOpcode::G_SITOFP,
#  783|                               APFloat::rmNearestTiesToEven);
#  784|       return DstVal;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:108: constructor_uses_global_object: The constructor of global object "EnableGlobalMerge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalMerge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|   // FIXME: This is only useful as a last-resort way to disable the pass.
#  107|   static cl::opt<bool>
#  108|-> EnableGlobalMerge("enable-global-merge", cl::Hidden,
#  109|                     cl::desc("Enable the global merge pass"),
#  110|                     cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:113: constructor_uses_global_object: The constructor of global object "GlobalMergeMaxOffset" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GlobalMergeMaxOffset" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  111|   
#  112|   static cl::opt<unsigned>
#  113|-> GlobalMergeMaxOffset("global-merge-max-offset", cl::Hidden,
#  114|                        cl::desc("Set maximum offset for global merge pass"),
#  115|                        cl::init(0));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:117: constructor_uses_global_object: The constructor of global object "GlobalMergeGroupByUse" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GlobalMergeGroupByUse" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  115|                        cl::init(0));
#  116|   
#  117|-> static cl::opt<bool> GlobalMergeGroupByUse(
#  118|       "global-merge-group-by-use", cl::Hidden,
#  119|       cl::desc("Improve global merge pass to look at uses"), cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:121: constructor_uses_global_object: The constructor of global object "GlobalMergeIgnoreSingleUse" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GlobalMergeIgnoreSingleUse" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  119|       cl::desc("Improve global merge pass to look at uses"), cl::init(true));
#  120|   
#  121|-> static cl::opt<bool> GlobalMergeIgnoreSingleUse(
#  122|       "global-merge-ignore-single-use", cl::Hidden,
#  123|       cl::desc("Improve global merge pass to ignore globals only used alone"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:127: constructor_uses_global_object: The constructor of global object "EnableGlobalMergeOnConst" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalMergeOnConst" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  125|   
#  126|   static cl::opt<bool>
#  127|-> EnableGlobalMergeOnConst("global-merge-on-const", cl::Hidden,
#  128|                            cl::desc("Enable global merge pass on constants"),
#  129|                            cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:134: constructor_uses_global_object: The constructor of global object "EnableGlobalMergeOnExternal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalMergeOnExternal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  132|   // it if only we are sure this optimization could always benefit all targets.
#  133|   static cl::opt<cl::boolOrDefault>
#  134|-> EnableGlobalMergeOnExternal("global-merge-on-external", cl::Hidden,
#  135|        cl::desc("Enable global merge pass on external linkage"));
#  136|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/HardwareLoops.cpp:53: constructor_uses_global_object: The constructor of global object "ForceHardwareLoops" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceHardwareLoops" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|   
#   52|   static cl::opt<bool>
#   53|-> ForceHardwareLoops("force-hardware-loops", cl::Hidden, cl::init(false),
#   54|                      cl::desc("Force hardware loops intrinsics to be inserted"));
#   55|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/HardwareLoops.cpp:57: constructor_uses_global_object: The constructor of global object "ForceHardwareLoopPHI" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceHardwareLoopPHI" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|   
#   56|   static cl::opt<bool>
#   57|-> ForceHardwareLoopPHI(
#   58|     "force-hardware-loop-phi", cl::Hidden, cl::init(false),
#   59|     cl::desc("Force hardware loop counter to be updated through a phi"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/HardwareLoops.cpp:62: constructor_uses_global_object: The constructor of global object "ForceNestedLoop" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceNestedLoop" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   
#   61|   static cl::opt<bool>
#   62|-> ForceNestedLoop("force-nested-hardware-loop", cl::Hidden, cl::init(false),
#   63|                   cl::desc("Force allowance of nested hardware loops"));
#   64|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/HardwareLoops.cpp:66: constructor_uses_global_object: The constructor of global object "LoopDecrement" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LoopDecrement" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   64|   
#   65|   static cl::opt<unsigned>
#   66|-> LoopDecrement("hardware-loop-decrement", cl::Hidden, cl::init(1),
#   67|               cl::desc("Set the loop decrement value"));
#   68|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/HardwareLoops.cpp:70: constructor_uses_global_object: The constructor of global object "CounterBitWidth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CounterBitWidth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|   
#   69|   static cl::opt<unsigned>
#   70|-> CounterBitWidth("hardware-loop-counter-bitwidth", cl::Hidden, cl::init(32),
#   71|                   cl::desc("Set the loop counter bitwidth"));
#   72|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/HardwareLoops.cpp:74: constructor_uses_global_object: The constructor of global object "ForceGuardLoopEntry" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceGuardLoopEntry" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   
#   73|   static cl::opt<bool>
#   74|-> ForceGuardLoopEntry(
#   75|     "force-hardware-loop-guard", cl::Hidden, cl::init(false),
#   76|     cl::desc("Force generation of loop guard intrinsic"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:61: constructor_uses_global_object: The constructor of global object "IfCvtFnStart" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IfCvtFnStart" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   59|   
#   60|   // Hidden options for help debugging.
#   61|-> static cl::opt<int> IfCvtFnStart("ifcvt-fn-start", cl::init(-1), cl::Hidden);
#   62|   static cl::opt<int> IfCvtFnStop("ifcvt-fn-stop", cl::init(-1), cl::Hidden);
#   63|   static cl::opt<int> IfCvtLimit("ifcvt-limit", cl::init(-1), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:62: constructor_uses_global_object: The constructor of global object "IfCvtFnStop" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IfCvtFnStop" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   // Hidden options for help debugging.
#   61|   static cl::opt<int> IfCvtFnStart("ifcvt-fn-start", cl::init(-1), cl::Hidden);
#   62|-> static cl::opt<int> IfCvtFnStop("ifcvt-fn-stop", cl::init(-1), cl::Hidden);
#   63|   static cl::opt<int> IfCvtLimit("ifcvt-limit", cl::init(-1), cl::Hidden);
#   64|   static cl::opt<bool> DisableSimple("disable-ifcvt-simple",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:63: constructor_uses_global_object: The constructor of global object "IfCvtLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IfCvtLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   61|   static cl::opt<int> IfCvtFnStart("ifcvt-fn-start", cl::init(-1), cl::Hidden);
#   62|   static cl::opt<int> IfCvtFnStop("ifcvt-fn-stop", cl::init(-1), cl::Hidden);
#   63|-> static cl::opt<int> IfCvtLimit("ifcvt-limit", cl::init(-1), cl::Hidden);
#   64|   static cl::opt<bool> DisableSimple("disable-ifcvt-simple",
#   65|                                      cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:64: constructor_uses_global_object: The constructor of global object "DisableSimple" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSimple" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   62|   static cl::opt<int> IfCvtFnStop("ifcvt-fn-stop", cl::init(-1), cl::Hidden);
#   63|   static cl::opt<int> IfCvtLimit("ifcvt-limit", cl::init(-1), cl::Hidden);
#   64|-> static cl::opt<bool> DisableSimple("disable-ifcvt-simple",
#   65|                                      cl::init(false), cl::Hidden);
#   66|   static cl::opt<bool> DisableSimpleF("disable-ifcvt-simple-false",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:66: constructor_uses_global_object: The constructor of global object "DisableSimpleF" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSimpleF" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   64|   static cl::opt<bool> DisableSimple("disable-ifcvt-simple",
#   65|                                      cl::init(false), cl::Hidden);
#   66|-> static cl::opt<bool> DisableSimpleF("disable-ifcvt-simple-false",
#   67|                                       cl::init(false), cl::Hidden);
#   68|   static cl::opt<bool> DisableTriangle("disable-ifcvt-triangle",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:68: constructor_uses_global_object: The constructor of global object "DisableTriangle" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableTriangle" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|   static cl::opt<bool> DisableSimpleF("disable-ifcvt-simple-false",
#   67|                                       cl::init(false), cl::Hidden);
#   68|-> static cl::opt<bool> DisableTriangle("disable-ifcvt-triangle",
#   69|                                        cl::init(false), cl::Hidden);
#   70|   static cl::opt<bool> DisableTriangleR("disable-ifcvt-triangle-rev",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:70: constructor_uses_global_object: The constructor of global object "DisableTriangleR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableTriangleR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|   static cl::opt<bool> DisableTriangle("disable-ifcvt-triangle",
#   69|                                        cl::init(false), cl::Hidden);
#   70|-> static cl::opt<bool> DisableTriangleR("disable-ifcvt-triangle-rev",
#   71|                                         cl::init(false), cl::Hidden);
#   72|   static cl::opt<bool> DisableTriangleF("disable-ifcvt-triangle-false",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:72: constructor_uses_global_object: The constructor of global object "DisableTriangleF" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableTriangleF" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   70|   static cl::opt<bool> DisableTriangleR("disable-ifcvt-triangle-rev",
#   71|                                         cl::init(false), cl::Hidden);
#   72|-> static cl::opt<bool> DisableTriangleF("disable-ifcvt-triangle-false",
#   73|                                         cl::init(false), cl::Hidden);
#   74|   static cl::opt<bool> DisableDiamond("disable-ifcvt-diamond",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:74: constructor_uses_global_object: The constructor of global object "DisableDiamond" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableDiamond" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   static cl::opt<bool> DisableTriangleF("disable-ifcvt-triangle-false",
#   73|                                         cl::init(false), cl::Hidden);
#   74|-> static cl::opt<bool> DisableDiamond("disable-ifcvt-diamond",
#   75|                                       cl::init(false), cl::Hidden);
#   76|   static cl::opt<bool> DisableForkedDiamond("disable-ifcvt-forked-diamond",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:76: constructor_uses_global_object: The constructor of global object "DisableForkedDiamond" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableForkedDiamond" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   74|   static cl::opt<bool> DisableDiamond("disable-ifcvt-diamond",
#   75|                                       cl::init(false), cl::Hidden);
#   76|-> static cl::opt<bool> DisableForkedDiamond("disable-ifcvt-forked-diamond",
#   77|                                           cl::init(false), cl::Hidden);
#   78|   static cl::opt<bool> IfCvtBranchFold("ifcvt-branch-fold",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/IfConversion.cpp:78: constructor_uses_global_object: The constructor of global object "IfCvtBranchFold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IfCvtBranchFold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   static cl::opt<bool> DisableForkedDiamond("disable-ifcvt-forked-diamond",
#   77|                                           cl::init(false), cl::Hidden);
#   78|-> static cl::opt<bool> IfCvtBranchFold("ifcvt-branch-fold",
#   79|                                        cl::init(true), cl::Hidden);
#   80|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ImplicitNullChecks.cpp:62: constructor_uses_global_object: The constructor of global object "PageSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PageSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   using namespace llvm;
#   61|   
#   62|-> static cl::opt<int> PageSize("imp-null-check-page-size",
#   63|                                cl::desc("The page size of the target in bytes"),
#   64|                                cl::init(4096), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ImplicitNullChecks.cpp:66: constructor_uses_global_object: The constructor of global object "MaxInstsToConsider" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxInstsToConsider" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   64|                                cl::init(4096), cl::Hidden);
#   65|   
#   66|-> static cl::opt<unsigned> MaxInstsToConsider(
#   67|       "imp-null-max-insts-to-consider",
#   68|       cl::desc("The max number of instructions to consider hoisting loads over "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/InlineSpiller.cpp:75: constructor_uses_global_object: The constructor of global object "DisableHoisting" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableHoisting" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   73|   STATISTIC(NumRemats,          "Number of rematerialized defs for spilling");
#   74|   
#   75|-> static cl::opt<bool> DisableHoisting("disable-spill-hoist", cl::Hidden,
#   76|                                        cl::desc("Disable inline spill hoisting"));
#   77|   static cl::opt<bool>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/InlineSpiller.cpp:78: constructor_uses_global_object: The constructor of global object "RestrictStatepointRemat" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RestrictStatepointRemat" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|                                        cl::desc("Disable inline spill hoisting"));
#   77|   static cl::opt<bool>
#   78|-> RestrictStatepointRemat("restrict-statepoint-remat",
#   79|                          cl::init(false), cl::Hidden,
#   80|                          cl::desc("Restrict remat for statepoint operands"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/InterleavedAccessPass.cpp:78: constructor_uses_global_object: The constructor of global object "LowerInterleavedAccesses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LowerInterleavedAccesses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   #define DEBUG_TYPE "interleaved-access"
#   77|   
#   78|-> static cl::opt<bool> LowerInterleavedAccesses(
#   79|       "lower-interleaved-accesses",
#   80|       cl::desc("Enable lowering interleaved accesses to intrinsics"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/InterleavedLoadCombinePass.cpp:57: constructor_uses_global_object: The constructor of global object "<unnamed>::DisableInterleavedLoadCombine" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DisableInterleavedLoadCombine" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|   
#   56|   /// Option to disable the pass
#   57|-> static cl::opt<bool> DisableInterleavedLoadCombine(
#   58|       "disable-" DEBUG_TYPE, cl::init(false), cl::Hidden,
#   59|       cl::desc("Disable combining of interleaved loads"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LLVMTargetMachine.cpp:37: constructor_uses_global_object: The constructor of global object "EnableTrapUnreachable" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableTrapUnreachable" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|   
#   36|   static cl::opt<bool>
#   37|->     EnableTrapUnreachable("trap-unreachable", cl::Hidden,
#   38|                             cl::desc("Enable generating trap for unreachable"));
#   39|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:141: constructor_uses_global_object: The constructor of global object "EmulateOldLDV" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EmulateOldLDV" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  139|   // Act more like the VarLoc implementation, by propagating some locations too
#  140|   // far and ignoring some transfers.
#  141|-> static cl::opt<bool> EmulateOldLDV("emulate-old-livedebugvalues", cl::Hidden,
#  142|                                      cl::desc("Act like old LiveDebugValues did"),
#  143|                                      cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:155: constructor_uses_global_object: The constructor of global object "StackWorkingSetLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackWorkingSetLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  153|   // consuming all the developer's memory.
#  154|   static cl::opt<unsigned>
#  155|->     StackWorkingSetLimit("livedebugvalues-max-stack-slots", cl::Hidden,
#  156|                            cl::desc("livedebugvalues-stack-ws-limit"),
#  157|                            cl::init(250));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:41: constructor_uses_global_object: The constructor of global object "ForceInstrRefLDV" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceInstrRefLDV" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   
#   40|   static cl::opt<bool>
#   41|->     ForceInstrRefLDV("force-instr-ref-livedebugvalues", cl::Hidden,
#   42|                        cl::desc("Use instruction-ref based LiveDebugValues with "
#   43|                                 "normal DBG_VALUE inputs"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:46: constructor_uses_global_object: The constructor of global object "ValueTrackingVariableLocations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ValueTrackingVariableLocations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|                        cl::init(false));
#   45|   
#   46|-> static cl::opt<cl::boolOrDefault> ValueTrackingVariableLocations(
#   47|       "experimental-debug-variable-locations",
#   48|       cl::desc("Use experimental new value-tracking variable locations"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:52: constructor_uses_global_object: The constructor of global object "InputBBLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InputBBLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|   // Options to prevent pathological compile-time behavior. If InputBBLimit and
#   51|   // InputDbgValueLimit are both exceeded, range extension is disabled.
#   52|-> static cl::opt<unsigned> InputBBLimit(
#   53|       "livedebugvalues-input-bb-limit",
#   54|       cl::desc("Maximum input basic blocks before DBG_VALUE limit applies"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:56: constructor_uses_global_object: The constructor of global object "InputDbgValueLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InputDbgValueLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|       cl::desc("Maximum input basic blocks before DBG_VALUE limit applies"),
#   55|       cl::init(10000), cl::Hidden);
#   56|-> static cl::opt<unsigned> InputDbgValueLimit(
#   57|       "livedebugvalues-input-dbg-value-limit",
#   58|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveDebugVariables.cpp:70: constructor_uses_global_object: The constructor of global object "EnableLDV" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLDV" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|   
#   69|   static cl::opt<bool>
#   70|-> EnableLDV("live-debug-variables", cl::init(true),
#   71|             cl::desc("Enable the live debug variables pass"), cl::Hidden);
#   72|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/CodeGen/LiveDebugVariables.cpp:168: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/CodeGen/LiveDebugVariables.cpp:168: leaked_storage: Ignoring storage allocated by "this->LocNos.release()" leaks it.
#  166|         std::copy(Other.loc_nos_begin(), Other.loc_nos_end(), loc_nos_begin());
#  167|       } else {
#  168|->       LocNos.release();
#  169|       }
#  170|       LocNoCount = Other.getLocNoCount();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/LiveInterval.cpp:725: var_decl: Declaring variable "Updater".
llvm-17.0.6.src/lib/CodeGen/LiveInterval.cpp:729: uninit_use_in_call: Using uninitialized value "Updater.ReadI" when calling "~LiveRangeUpdater".
llvm-17.0.6.src/lib/CodeGen/LiveInterval.cpp:729: uninit_use_in_call: Using uninitialized value "Updater.WriteI" when calling "~LiveRangeUpdater".
#  727|       if (S.valno == RHSValNo)
#  728|         Updater.add(S.start, S.end, LHSValNo);
#  729|-> }
#  730|   
#  731|   /// MergeValueNumberInto - This method is called when two value nubmers

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/LiveIntervals.cpp:79: constructor_uses_global_object: The constructor of global object "llvm::UseSegmentSetForPhysRegs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::UseSegmentSetForPhysRegs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   namespace llvm {
#   78|   
#   79|-> cl::opt<bool> UseSegmentSetForPhysRegs(
#   80|       "use-segment-set-for-physregs", cl::Hidden, cl::init(true),
#   81|       cl::desc(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/LiveRangeCalc.cpp:63: var_decl: Declaring variable "Updater".
llvm-17.0.6.src/lib/CodeGen/LiveRangeCalc.cpp:81: uninit_use_in_call: Using uninitialized value "Updater.ReadI" when calling "setDest".
llvm-17.0.6.src/lib/CodeGen/LiveRangeCalc.cpp:81: uninit_use_in_call: Using uninitialized value "Updater.WriteI" when calling "setDest".
#   79|         Map[MBB] = LiveOutPair(I.Value, nullptr);
#   80|       }
#   81|->     Updater.setDest(&I.LR);
#   82|       Updater.add(Start, End, I.Value);
#   83|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/LiveRangeCalc.cpp:63: var_decl: Declaring variable "Updater".
llvm-17.0.6.src/lib/CodeGen/LiveRangeCalc.cpp:85: uninit_use_in_call: Using uninitialized value "Updater.ReadI" when calling "~LiveRangeUpdater".
llvm-17.0.6.src/lib/CodeGen/LiveRangeCalc.cpp:85: uninit_use_in_call: Using uninitialized value "Updater.WriteI" when calling "~LiveRangeUpdater".
#   83|     }
#   84|     LiveIn.clear();
#   85|-> }
#   86|   
#   87|   void LiveRangeCalc::extend(LiveRange &LR, SlotIndex Use, unsigned PhysReg,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRCanonicalizerPass.cpp:41: constructor_uses_global_object: The constructor of global object "CanonicalizeFunctionNumber" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CanonicalizeFunctionNumber" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   
#   40|   static cl::opt<unsigned>
#   41|->     CanonicalizeFunctionNumber("canon-nth-function", cl::Hidden, cl::init(~0u),
#   42|                                  cl::value_desc("N"),
#   43|                                  cl::desc("Function number to canonicalize."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRFSDiscriminator.cpp:38: constructor_uses_global_object: The constructor of global object "ImprovedFSDiscriminator" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ImprovedFSDiscriminator" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   // TODO(xur): Remove this option and related code once we make true as the
#   37|   // default.
#   38|-> cl::opt<bool> ImprovedFSDiscriminator(
#   39|       "improved-fs-discriminator", cl::Hidden, cl::init(false),
#   40|       cl::desc("New FS discriminators encoding (incompatible with the original "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRPrinter.cpp:65: constructor_uses_global_object: The constructor of global object "SimplifyMIR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SimplifyMIR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   using namespace llvm;
#   64|   
#   65|-> static cl::opt<bool> SimplifyMIR(
#   66|       "simplify-mir", cl::Hidden,
#   67|       cl::desc("Leave out unnecessary information when printing MIR"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRPrinter.cpp:69: constructor_uses_global_object: The constructor of global object "PrintLocations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintLocations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|       cl::desc("Leave out unnecessary information when printing MIR"));
#   68|   
#   69|-> static cl::opt<bool> PrintLocations("mir-debug-loc", cl::Hidden, cl::init(true),
#   70|                                       cl::desc("Print MIR debug-locations"));
#   71|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRSampleProfile.cpp:44: constructor_uses_global_object: The constructor of global object "ShowFSBranchProb" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ShowFSBranchProb" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   #define DEBUG_TYPE "fs-profile-loader"
#   43|   
#   44|-> static cl::opt<bool> ShowFSBranchProb(
#   45|       "show-fs-branchprob", cl::Hidden, cl::init(false),
#   46|       cl::desc("Print setting flow sensitive branch probabilities"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRSampleProfile.cpp:47: constructor_uses_global_object: The constructor of global object "FSProfileDebugProbDiffThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FSProfileDebugProbDiffThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|       "show-fs-branchprob", cl::Hidden, cl::init(false),
#   46|       cl::desc("Print setting flow sensitive branch probabilities"));
#   47|-> static cl::opt<unsigned> FSProfileDebugProbDiffThreshold(
#   48|       "fs-profile-debug-prob-diff-threshold", cl::init(10),
#   49|       cl::desc("Only show debug message if the branch probility is greater than "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRSampleProfile.cpp:52: constructor_uses_global_object: The constructor of global object "FSProfileDebugBWThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FSProfileDebugBWThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|                "this value (in percentage)."));
#   51|   
#   52|-> static cl::opt<unsigned> FSProfileDebugBWThreshold(
#   53|       "fs-profile-debug-bw-threshold", cl::init(10000),
#   54|       cl::desc("Only show debug message if the source branch weight is greater "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRSampleProfile.cpp:57: constructor_uses_global_object: The constructor of global object "ViewBFIBefore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ViewBFIBefore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|                " than this value."));
#   56|   
#   57|-> static cl::opt<bool> ViewBFIBefore("fs-viewbfi-before", cl::Hidden,
#   58|                                      cl::init(false),
#   59|                                      cl::desc("View BFI before MIR loader"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRSampleProfile.cpp:60: constructor_uses_global_object: The constructor of global object "ViewBFIAfter" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ViewBFIAfter" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|                                      cl::init(false),
#   59|                                      cl::desc("View BFI before MIR loader"));
#   60|-> static cl::opt<bool> ViewBFIAfter("fs-viewbfi-after", cl::Hidden,
#   61|                                     cl::init(false),
#   62|                                     cl::desc("View BFI after MIR loader"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MIRVRegNamerUtils.cpp:19: constructor_uses_global_object: The constructor of global object "UseStableNamerHash" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseStableNamerHash" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   17|   
#   18|   static cl::opt<bool>
#   19|->     UseStableNamerHash("mir-vreg-namer-use-stable-hash", cl::init(false),
#   20|                          cl::Hidden,
#   21|                          cl::desc("Use Stable Hashing for MIR VReg Renaming"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MLRegallocEvictAdvisor.cpp:57: constructor_uses_global_object: The constructor of global object "InteractiveChannelBaseName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InteractiveChannelBaseName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|   #endif
#   56|   
#   57|-> static cl::opt<std::string> InteractiveChannelBaseName(
#   58|       "regalloc-evict-interactive-channel-base", cl::Hidden,
#   59|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MLRegallocPriorityAdvisor.cpp:44: constructor_uses_global_object: The constructor of global object "InteractiveChannelBaseName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InteractiveChannelBaseName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   using namespace llvm;
#   43|   
#   44|-> static cl::opt<std::string> InteractiveChannelBaseName(
#   45|       "regalloc-priority-interactive-channel-base", cl::Hidden,
#   46|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBasicBlock.cpp:45: constructor_uses_global_object: The constructor of global object "PrintSlotIndexes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintSlotIndexes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|   #define DEBUG_TYPE "codegen"
#   44|   
#   45|-> static cl::opt<bool> PrintSlotIndexes(
#   46|       "print-slotindexes",
#   47|       cl::desc("When printing machine IR, annotate instructions and blocks with "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockFrequencyInfo.cpp:33: constructor_uses_global_object: The constructor of global object "llvm::ViewMachineBlockFreqPropagationDAG" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ViewMachineBlockFreqPropagationDAG" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   
#   32|   namespace llvm {
#   33|-> static cl::opt<GVDAGType> ViewMachineBlockFreqPropagationDAG(
#   34|       "view-machine-block-freq-propagation-dags", cl::Hidden,
#   35|       cl::desc("Pop up a window to show a dag displaying how machine block "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockFrequencyInfo.cpp:48: constructor_uses_global_object: The constructor of global object "llvm::ViewBlockLayoutWithBFI" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ViewBlockLayoutWithBFI" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   
#   47|   // Similar option above, but used to control BFI display only after MBP pass
#   48|-> cl::opt<GVDAGType> ViewBlockLayoutWithBFI(
#   49|       "view-block-layout-with-bfi", cl::Hidden,
#   50|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockFrequencyInfo.cpp:72: constructor_uses_global_object: The constructor of global object "llvm::PrintMachineBlockFreq" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PrintMachineBlockFreq" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   70|   extern cl::opt<unsigned> ViewHotFreqPercent;
#   71|   
#   72|-> static cl::opt<bool> PrintMachineBlockFreq(
#   73|       "print-machine-bfi", cl::init(false), cl::Hidden,
#   74|       cl::desc("Print the machine block frequency info."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:87: constructor_uses_global_object: The constructor of global object "AlignAllBlock" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AlignAllBlock" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   85|             "Potential frequency of taking unconditional branches");
#   86|   
#   87|-> static cl::opt<unsigned> AlignAllBlock(
#   88|       "align-all-blocks",
#   89|       cl::desc("Force the alignment of all blocks in the function in log2 format "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:93: constructor_uses_global_object: The constructor of global object "AlignAllNonFallThruBlocks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AlignAllNonFallThruBlocks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   91|       cl::init(0), cl::Hidden);
#   92|   
#   93|-> static cl::opt<unsigned> AlignAllNonFallThruBlocks(
#   94|       "align-all-nofallthru-blocks",
#   95|       cl::desc("Force the alignment of all blocks that have no fall-through "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:100: constructor_uses_global_object: The constructor of global object "MaxBytesForAlignmentOverride" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxBytesForAlignmentOverride" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   98|       cl::init(0), cl::Hidden);
#   99|   
#  100|-> static cl::opt<unsigned> MaxBytesForAlignmentOverride(
#  101|       "max-bytes-for-alignment",
#  102|       cl::desc("Forces the maximum bytes allowed to be emitted when padding for "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:107: constructor_uses_global_object: The constructor of global object "ExitBlockBias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExitBlockBias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  105|   
#  106|   // FIXME: Find a good default for this flag and remove the flag.
#  107|-> static cl::opt<unsigned> ExitBlockBias(
#  108|       "block-placement-exit-block-bias",
#  109|       cl::desc("Block frequency percentage a loop exit block needs "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:116: constructor_uses_global_object: The constructor of global object "LoopToColdBlockRatio" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LoopToColdBlockRatio" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  114|   // - Outlining: placement of a basic block outside the chain or hot path.
#  115|   
#  116|-> static cl::opt<unsigned> LoopToColdBlockRatio(
#  117|       "loop-to-cold-block-ratio",
#  118|       cl::desc("Outline loop blocks from loop chain if (frequency of loop) / "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:122: constructor_uses_global_object: The constructor of global object "ForceLoopColdBlock" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceLoopColdBlock" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  120|       cl::init(5), cl::Hidden);
#  121|   
#  122|-> static cl::opt<bool> ForceLoopColdBlock(
#  123|       "force-loop-cold-block",
#  124|       cl::desc("Force outlining cold blocks from loops."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:128: constructor_uses_global_object: The constructor of global object "PreciseRotationCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PreciseRotationCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|   
#  127|   static cl::opt<bool>
#  128|->     PreciseRotationCost("precise-rotation-cost",
#  129|                           cl::desc("Model the cost of loop rotation more "
#  130|                                    "precisely by using profile data."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:134: constructor_uses_global_object: The constructor of global object "ForcePreciseRotationCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForcePreciseRotationCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  132|   
#  133|   static cl::opt<bool>
#  134|->     ForcePreciseRotationCost("force-precise-rotation-cost",
#  135|                                cl::desc("Force the use of precise cost "
#  136|                                         "loop rotation strategy."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:139: constructor_uses_global_object: The constructor of global object "MisfetchCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MisfetchCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  137|                                cl::init(false), cl::Hidden);
#  138|   
#  139|-> static cl::opt<unsigned> MisfetchCost(
#  140|       "misfetch-cost",
#  141|       cl::desc("Cost that models the probabilistic risk of an instruction "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:146: constructor_uses_global_object: The constructor of global object "JumpInstCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "JumpInstCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  144|       cl::init(1), cl::Hidden);
#  145|   
#  146|-> static cl::opt<unsigned> JumpInstCost("jump-inst-cost",
#  147|                                         cl::desc("Cost of jump instructions."),
#  148|                                         cl::init(1), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:150: constructor_uses_global_object: The constructor of global object "TailDupPlacement" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupPlacement" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  148|                                         cl::init(1), cl::Hidden);
#  149|   static cl::opt<bool>
#  150|-> TailDupPlacement("tail-dup-placement",
#  151|                 cl::desc("Perform tail duplication during placement. "
#  152|                          "Creates more fallthrough opportunites in "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:157: constructor_uses_global_object: The constructor of global object "BranchFoldPlacement" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BranchFoldPlacement" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  155|   
#  156|   static cl::opt<bool>
#  157|-> BranchFoldPlacement("branch-fold-placement",
#  158|                 cl::desc("Perform branch folding during placement. "
#  159|                          "Reduces code size."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:163: constructor_uses_global_object: The constructor of global object "TailDupPlacementThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupPlacementThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  161|   
#  162|   // Heuristic for tail duplication.
#  163|-> static cl::opt<unsigned> TailDupPlacementThreshold(
#  164|       "tail-dup-placement-threshold",
#  165|       cl::desc("Instruction cutoff for tail duplication during layout. "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:171: constructor_uses_global_object: The constructor of global object "TailDupPlacementAggressiveThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupPlacementAggressiveThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  169|   
#  170|   // Heuristic for aggressive tail duplication.
#  171|-> static cl::opt<unsigned> TailDupPlacementAggressiveThreshold(
#  172|       "tail-dup-placement-aggressive-threshold",
#  173|       cl::desc("Instruction cutoff for aggressive tail duplication during "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:179: constructor_uses_global_object: The constructor of global object "TailDupPlacementPenalty" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupPlacementPenalty" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  177|   
#  178|   // Heuristic for tail duplication.
#  179|-> static cl::opt<unsigned> TailDupPlacementPenalty(
#  180|       "tail-dup-placement-penalty",
#  181|       cl::desc("Cost penalty for blocks that can avoid breaking CFG by copying. "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:189: constructor_uses_global_object: The constructor of global object "TailDupProfilePercentThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupProfilePercentThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  187|   
#  188|   // Heuristic for tail duplication if profile count is used in cost model.
#  189|-> static cl::opt<unsigned> TailDupProfilePercentThreshold(
#  190|       "tail-dup-profile-percent-threshold",
#  191|       cl::desc("If profile count information is used in tail duplication cost "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:197: constructor_uses_global_object: The constructor of global object "TriangleChainCount" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TriangleChainCount" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  195|   
#  196|   // Heuristic for triangle chains.
#  197|-> static cl::opt<unsigned> TriangleChainCount(
#  198|       "triangle-chain-count",
#  199|       cl::desc("Number of triangle-shaped-CFG's that need to be in a row for the "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:209: constructor_uses_global_object: The constructor of global object "RenumberBlocksBeforeView" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RenumberBlocksBeforeView" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  207|   // With this option on, the basic blocks are renumbered in function layout
#  208|   // order. For debugging only.
#  209|-> static cl::opt<bool> RenumberBlocksBeforeView(
#  210|       "renumber-blocks-before-view",
#  211|       cl::desc(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:2562: var_decl: Declaring variable "LoopBlockSet".
llvm-17.0.6.src/lib/CodeGen/MachineBlockPlacement.cpp:2593: uninit_use: Using uninitialized value "LoopBlockSet". Field "LoopBlockSet.vector_.InlineElts" is uninitialized.
# 2591|       LoopBlockSet.insert(L.block_begin(), L.block_end());
# 2592|   
# 2593|->   return LoopBlockSet;
# 2594|   }
# 2595|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBranchProbabilityInfo.cpp:28: constructor_uses_global_object: The constructor of global object "llvm::StaticLikelyProb" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::StaticLikelyProb" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   namespace llvm {
#   27|   cl::opt<unsigned>
#   28|->     StaticLikelyProb("static-likely-prob",
#   29|                        cl::desc("branch probability threshold in percentage"
#   30|                                 "to be considered very likely"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineBranchProbabilityInfo.cpp:33: constructor_uses_global_object: The constructor of global object "llvm::ProfileLikelyProb" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileLikelyProb" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|                        cl::init(80), cl::Hidden);
#   32|   
#   33|-> cl::opt<unsigned> ProfileLikelyProb(
#   34|       "profile-likely-prob",
#   35|       cl::desc("branch probability threshold in percentage to be considered"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCFGPrinter.cpp:28: constructor_uses_global_object: The constructor of global object "MCFGFuncName[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MCFGFuncName[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   
#   27|   static cl::opt<std::string>
#   28|->     MCFGFuncName("mcfg-func-name", cl::Hidden,
#   29|                    cl::desc("The name of a function (or its substring)"
#   30|                             " whose CFG is viewed/printed."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCFGPrinter.cpp:32: constructor_uses_global_object: The constructor of global object "MCFGDotFilenamePrefix[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MCFGDotFilenamePrefix[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|                             " whose CFG is viewed/printed."));
#   31|   
#   32|-> static cl::opt<std::string> MCFGDotFilenamePrefix(
#   33|       "mcfg-dot-filename-prefix", cl::Hidden,
#   34|       cl::desc("The prefix used for the Machine CFG dot file names."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCFGPrinter.cpp:37: constructor_uses_global_object: The constructor of global object "CFGOnly" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CFGOnly" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|   
#   36|   static cl::opt<bool>
#   37|->     CFGOnly("dot-mcfg-only", cl::init(false), cl::Hidden,
#   38|               cl::desc("Print only the CFG without blocks body"));
#   39|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCSE.cpp:65: constructor_uses_global_object: The constructor of global object "CSUsesThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CSUsesThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   // Threshold to avoid excessive cost to compute isProfitableToCSE.
#   64|   static cl::opt<int>
#   65|->     CSUsesThreshold("csuses-threshold", cl::Hidden, cl::init(1024),
#   66|                       cl::desc("Threshold for the size of CSUses"));
#   67|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCombiner.cpp:42: constructor_uses_global_object: The constructor of global object "inc_threshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "inc_threshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|   
#   41|   static cl::opt<unsigned>
#   42|-> inc_threshold("machine-combiner-inc-threshold", cl::Hidden,
#   43|                 cl::desc("Incremental depth computation will be used for basic "
#   44|                          "blocks with more instructions."), cl::init(500));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCombiner.cpp:46: constructor_uses_global_object: The constructor of global object "dump_intrs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "dump_intrs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|                          "blocks with more instructions."), cl::init(500));
#   45|   
#   46|-> static cl::opt<bool> dump_intrs("machine-combiner-dump-subst-intrs", cl::Hidden,
#   47|                                   cl::desc("Dump all substituted intrs"),
#   48|                                   cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCombiner.cpp:57: constructor_uses_global_object: The constructor of global object "VerifyPatternOrder" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyPatternOrder" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|       cl::init(true));
#   56|   #else
#   57|-> static cl::opt<bool> VerifyPatternOrder(
#   58|       "machine-combiner-verify-pattern-order", cl::Hidden,
#   59|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCopyPropagation.cpp:88: constructor_uses_global_object: The constructor of global object "MCPUseCopyInstr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MCPUseCopyInstr" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   86|                 "Controls which register COPYs are forwarded");
#   87|   
#   88|-> static cl::opt<bool> MCPUseCopyInstr("mcp-use-is-copy-instr", cl::init(false),
#   89|                                        cl::Hidden);
#   90|   static cl::opt<cl::boolOrDefault>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineCopyPropagation.cpp:91: constructor_uses_global_object: The constructor of global object "EnableSpillageCopyElimination" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSpillageCopyElimination" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   89|                                        cl::Hidden);
#   90|   static cl::opt<cl::boolOrDefault>
#   91|->     EnableSpillageCopyElimination("enable-spill-copy-elim", cl::Hidden);
#   92|   
#   93|   namespace {

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineDominators.cpp:33: constructor_uses_global_object: The constructor of global object "VerifyMachineDomInfoX" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyMachineDomInfoX" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   } // namespace llvm
#   32|   
#   33|-> static cl::opt<bool, true> VerifyMachineDomInfoX(
#   34|       "verify-machine-dom-info", cl::location(VerifyMachineDomInfo), cl::Hidden,
#   35|       cl::desc("Verify machine dominator info (time consuming)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineFunction.cpp:84: constructor_uses_global_object: The constructor of global object "AlignAllFunctions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AlignAllFunctions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   82|   #define DEBUG_TYPE "codegen"
#   83|   
#   84|-> static cl::opt<unsigned> AlignAllFunctions(
#   85|       "align-all-functions",
#   86|       cl::desc("Force the alignment of all functions in log2 format (e.g. 4 "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineFunctionSplitter.cpp:53: constructor_uses_global_object: The constructor of global object "PercentileCutoff" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PercentileCutoff" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|   // Intel CPUs.
#   52|   static cl::opt<unsigned>
#   53|->     PercentileCutoff("mfs-psi-cutoff",
#   54|                        cl::desc("Percentile profile summary cutoff used to "
#   55|                                 "determine cold blocks. Unused if set to zero."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineFunctionSplitter.cpp:58: constructor_uses_global_object: The constructor of global object "ColdCountThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ColdCountThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|                        cl::init(999950), cl::Hidden);
#   57|   
#   58|-> static cl::opt<unsigned> ColdCountThreshold(
#   59|       "mfs-count-threshold",
#   60|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineFunctionSplitter.cpp:64: constructor_uses_global_object: The constructor of global object "SplitAllEHCode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SplitAllEHCode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   62|       cl::init(1), cl::Hidden);
#   63|   
#   64|-> static cl::opt<bool> SplitAllEHCode(
#   65|       "mfs-split-ehcode",
#   66|       cl::desc("Splits all EH code and it's descendants by default."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineLICM.cpp:62: constructor_uses_global_object: The constructor of global object "AvoidSpeculation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AvoidSpeculation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   
#   61|   static cl::opt<bool>
#   62|-> AvoidSpeculation("avoid-speculation",
#   63|                    cl::desc("MachineLICM should avoid speculation"),
#   64|                    cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineLICM.cpp:67: constructor_uses_global_object: The constructor of global object "HoistCheapInsts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HoistCheapInsts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   
#   66|   static cl::opt<bool>
#   67|-> HoistCheapInsts("hoist-cheap-insts",
#   68|                   cl::desc("MachineLICM should hoist even cheap instructions"),
#   69|                   cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineLICM.cpp:72: constructor_uses_global_object: The constructor of global object "HoistConstStores" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HoistConstStores" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   70|   
#   71|   static cl::opt<bool>
#   72|-> HoistConstStores("hoist-const-stores",
#   73|                    cl::desc("Hoist invariant stores"),
#   74|                    cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineLICM.cpp:78: constructor_uses_global_object: The constructor of global object "BlockFrequencyRatioThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BlockFrequencyRatioThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   // is based on empirical data on a single target and is subject to tuning.
#   77|   static cl::opt<unsigned>
#   78|-> BlockFrequencyRatioThreshold("block-freq-ratio-threshold",
#   79|                                cl::desc("Do not hoist instructions if target"
#   80|                                "block is N times hotter than the source."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineLICM.cpp:86: constructor_uses_global_object: The constructor of global object "DisableHoistingToHotterBlocks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableHoistingToHotterBlocks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|   
#   85|   static cl::opt<UseBFI>
#   86|-> DisableHoistingToHotterBlocks("disable-hoisting-to-hotter-blocks",
#   87|                                 cl::desc("Disable hoisting instructions to"
#   88|                                 " hotter blocks"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineModuleInfo.cpp:35: constructor_uses_global_object: The constructor of global object "DisableDebugInfoPrinting" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableDebugInfoPrinting" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   static cl::opt<bool>
#   35|->     DisableDebugInfoPrinting("disable-debug-info-print", cl::Hidden,
#   36|                                cl::desc("Disable debug info printing"));
#   37|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineOperand.cpp:36: constructor_uses_global_object: The constructor of global object "PrintRegMaskNumRegs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintRegMaskNumRegs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   
#   35|   static cl::opt<int>
#   36|->     PrintRegMaskNumRegs("print-regmask-num-regs",
#   37|                           cl::desc("Number of registers to limit to when "
#   38|                                    "printing regmask operands in IR dumps. "

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/CodeGen/MachineOperand.cpp:1166: overrun-call: Overrunning callee's array of size 8 by passing argument "this->getSuccessOrdering()" (which evaluates to 15) in call to "toIRString".
# 1164|   
# 1165|     if (getSuccessOrdering() != AtomicOrdering::NotAtomic)
# 1166|->     OS << toIRString(getSuccessOrdering()) << ' ';
# 1167|     if (getFailureOrdering() != AtomicOrdering::NotAtomic)
# 1168|       OS << toIRString(getFailureOrdering()) << ' ';

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/CodeGen/MachineOperand.cpp:1168: overrun-call: Overrunning callee's array of size 8 by passing argument "this->getFailureOrdering()" (which evaluates to 15) in call to "toIRString".
# 1166|       OS << toIRString(getSuccessOrdering()) << ' ';
# 1167|     if (getFailureOrdering() != AtomicOrdering::NotAtomic)
# 1168|->     OS << toIRString(getFailureOrdering()) << ' ';
# 1169|   
# 1170|     if (getMemoryType().isValid())

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineOutliner.cpp:106: constructor_uses_global_object: The constructor of global object "EnableLinkOnceODROutlining" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLinkOnceODROutlining" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  104|   // this is off by default. It should, however, be the default behaviour in
#  105|   // LTO.
#  106|-> static cl::opt<bool> EnableLinkOnceODROutlining(
#  107|       "enable-linkonceodr-outlining", cl::Hidden,
#  108|       cl::desc("Enable the machine outliner on linkonceodr functions"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineOutliner.cpp:114: constructor_uses_global_object: The constructor of global object "OutlinerReruns" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OutlinerReruns" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|   /// as the outliner will run at least one time. The default value is set to 0,
#  113|   /// meaning the outliner will run one time and rerun zero times after that.
#  114|-> static cl::opt<unsigned> OutlinerReruns(
#  115|       "machine-outliner-reruns", cl::init(0), cl::Hidden,
#  116|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineOutliner.cpp:119: constructor_uses_global_object: The constructor of global object "OutlinerBenefitThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OutlinerBenefitThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|           "Number of times to rerun the outliner after the initial outline"));
#  118|   
#  119|-> static cl::opt<unsigned> OutlinerBenefitThreshold(
#  120|       "outliner-benefit-threshold", cl::init(1), cl::Hidden,
#  121|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:114: constructor_uses_global_object: The constructor of global object "EnableSWP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSWP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|   
#  113|   /// A command line option to turn software pipelining on or off.
#  114|-> static cl::opt<bool> EnableSWP("enable-pipeliner", cl::Hidden, cl::init(true),
#  115|                                  cl::desc("Enable Software Pipelining"));
#  116|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:118: constructor_uses_global_object: The constructor of global object "EnableSWPOptSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSWPOptSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  116|   
#  117|   /// A command line option to enable SWP at -Os.
#  118|-> static cl::opt<bool> EnableSWPOptSize("enable-pipeliner-opt-size",
#  119|                                         cl::desc("Enable SWP at Os."), cl::Hidden,
#  120|                                         cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:123: constructor_uses_global_object: The constructor of global object "SwpMaxMii" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpMaxMii" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  121|   
#  122|   /// A command line argument to limit minimum initial interval for pipelining.
#  123|-> static cl::opt<int> SwpMaxMii("pipeliner-max-mii",
#  124|                                 cl::desc("Size limit for the MII."),
#  125|                                 cl::Hidden, cl::init(27));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:129: constructor_uses_global_object: The constructor of global object "SwpForceII" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpForceII" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  127|   /// A command line argument to force pipeliner to use specified initial
#  128|   /// interval.
#  129|-> static cl::opt<int> SwpForceII("pipeliner-force-ii",
#  130|                                  cl::desc("Force pipeliner to use specified II."),
#  131|                                  cl::Hidden, cl::init(-1));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:135: constructor_uses_global_object: The constructor of global object "SwpMaxStages" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpMaxStages" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|   /// A command line argument to limit the number of stages in the pipeline.
#  134|   static cl::opt<int>
#  135|->     SwpMaxStages("pipeliner-max-stages",
#  136|                    cl::desc("Maximum stages allowed in the generated scheduled."),
#  137|                    cl::Hidden, cl::init(3));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:142: constructor_uses_global_object: The constructor of global object "SwpPruneDeps" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpPruneDeps" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  140|   /// an unrelated Phi.
#  141|   static cl::opt<bool>
#  142|->     SwpPruneDeps("pipeliner-prune-deps",
#  143|                    cl::desc("Prune dependences between unrelated Phi nodes."),
#  144|                    cl::Hidden, cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:149: constructor_uses_global_object: The constructor of global object "SwpPruneLoopCarried" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpPruneLoopCarried" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  147|   /// dependences.
#  148|   static cl::opt<bool>
#  149|->     SwpPruneLoopCarried("pipeliner-prune-loop-carried",
#  150|                           cl::desc("Prune loop carried order dependences."),
#  151|                           cl::Hidden, cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:157: constructor_uses_global_object: The constructor of global object "SwpIgnoreRecMII" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpIgnoreRecMII" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  155|   #endif
#  156|   
#  157|-> static cl::opt<bool> SwpIgnoreRecMII("pipeliner-ignore-recmii",
#  158|                                        cl::ReallyHidden,
#  159|                                        cl::desc("Ignore RecMII"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:161: constructor_uses_global_object: The constructor of global object "SwpShowResMask" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpShowResMask" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  159|                                        cl::desc("Ignore RecMII"));
#  160|   
#  161|-> static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,
#  162|                                       cl::init(false));
#  163|   static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:163: constructor_uses_global_object: The constructor of global object "SwpDebugResource" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwpDebugResource" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  161|   static cl::opt<bool> SwpShowResMask("pipeliner-show-mask", cl::Hidden,
#  162|                                       cl::init(false));
#  163|-> static cl::opt<bool> SwpDebugResource("pipeliner-dbg-res", cl::Hidden,
#  164|                                         cl::init(false));
#  165|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:166: constructor_uses_global_object: The constructor of global object "EmitTestAnnotations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EmitTestAnnotations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  164|                                         cl::init(false));
#  165|   
#  166|-> static cl::opt<bool> EmitTestAnnotations(
#  167|       "pipeliner-annotate-for-testing", cl::Hidden, cl::init(false),
#  168|       cl::desc("Instead of emitting the pipelined code, annotate instructions "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:172: constructor_uses_global_object: The constructor of global object "ExperimentalCodeGen" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExperimentalCodeGen" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  170|                "-modulo-schedule-test pass"));
#  171|   
#  172|-> static cl::opt<bool> ExperimentalCodeGen(
#  173|       "pipeliner-experimental-cg", cl::Hidden, cl::init(false),
#  174|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:180: constructor_uses_global_object: The constructor of global object "llvm::SwpEnableCopyToPhi" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::SwpEnableCopyToPhi" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  178|   
#  179|   // A command line option to enable the CopyToPhi DAG mutation.
#  180|-> cl::opt<bool> SwpEnableCopyToPhi("pipeliner-enable-copytophi", cl::ReallyHidden,
#  181|                                    cl::init(true),
#  182|                                    cl::desc("Enable CopyToPhi DAG Mutation"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachinePipeliner.cpp:186: constructor_uses_global_object: The constructor of global object "llvm::SwpForceIssueWidth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::SwpForceIssueWidth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  184|   /// A command line argument to force pipeliner to use specified issue
#  185|   /// width.
#  186|-> cl::opt<int> SwpForceIssueWidth(
#  187|       "pipeliner-force-issue-width",
#  188|       cl::desc("Force pipeliner to use specified issue width."), cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineRegisterInfo.cpp:37: constructor_uses_global_object: The constructor of global object "EnableSubRegLiveness" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSubRegLiveness" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|   using namespace llvm;
#   36|   
#   37|-> static cl::opt<bool> EnableSubRegLiveness("enable-subreg-liveness", cl::Hidden,
#   38|     cl::init(true), cl::desc("Enable subregister liveness tracking."));
#   39|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:80: constructor_uses_global_object: The constructor of global object "llvm::ForceTopDown" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ForceTopDown" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   78|   namespace llvm {
#   79|   
#   80|-> cl::opt<bool> ForceTopDown("misched-topdown", cl::Hidden,
#   81|                              cl::desc("Force top-down list scheduling"));
#   82|   cl::opt<bool> ForceBottomUp("misched-bottomup", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:82: constructor_uses_global_object: The constructor of global object "llvm::ForceBottomUp" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ForceBottomUp" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   cl::opt<bool> ForceTopDown("misched-topdown", cl::Hidden,
#   81|                              cl::desc("Force top-down list scheduling"));
#   82|-> cl::opt<bool> ForceBottomUp("misched-bottomup", cl::Hidden,
#   83|                               cl::desc("Force bottom-up list scheduling"));
#   84|   cl::opt<bool>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:85: constructor_uses_global_object: The constructor of global object "llvm::DumpCriticalPathLength" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DumpCriticalPathLength" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|                               cl::desc("Force bottom-up list scheduling"));
#   84|   cl::opt<bool>
#   85|-> DumpCriticalPathLength("misched-dcpl", cl::Hidden,
#   86|                          cl::desc("Print critical path length to stdout"));
#   87|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:88: constructor_uses_global_object: The constructor of global object "llvm::VerifyScheduling" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::VerifyScheduling" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   86|                          cl::desc("Print critical path length to stdout"));
#   87|   
#   88|-> cl::opt<bool> VerifyScheduling(
#   89|       "verify-misched", cl::Hidden,
#   90|       cl::desc("Verify machine instrs before and after machine scheduling"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:132: constructor_uses_global_object: The constructor of global object "ReadyListLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReadyListLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  130|   /// Avoid quadratic complexity in unusually large basic blocks by limiting the
#  131|   /// size of the ready lists.
#  132|-> static cl::opt<unsigned> ReadyListLimit("misched-limit", cl::Hidden,
#  133|     cl::desc("Limit ready list to N instructions"), cl::init(256));
#  134|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:135: constructor_uses_global_object: The constructor of global object "EnableRegPressure" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRegPressure" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|     cl::desc("Limit ready list to N instructions"), cl::init(256));
#  134|   
#  135|-> static cl::opt<bool> EnableRegPressure("misched-regpressure", cl::Hidden,
#  136|     cl::desc("Enable register pressure scheduling."), cl::init(true));
#  137|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:138: constructor_uses_global_object: The constructor of global object "EnableCyclicPath" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCyclicPath" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  136|     cl::desc("Enable register pressure scheduling."), cl::init(true));
#  137|   
#  138|-> static cl::opt<bool> EnableCyclicPath("misched-cyclicpath", cl::Hidden,
#  139|     cl::desc("Enable cyclic critical path analysis."), cl::init(true));
#  140|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:141: constructor_uses_global_object: The constructor of global object "EnableMemOpCluster" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMemOpCluster" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  139|     cl::desc("Enable cyclic critical path analysis."), cl::init(true));
#  140|   
#  141|-> static cl::opt<bool> EnableMemOpCluster("misched-cluster", cl::Hidden,
#  142|                                           cl::desc("Enable memop clustering."),
#  143|                                           cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:145: constructor_uses_global_object: The constructor of global object "ForceFastCluster" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceFastCluster" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  143|                                           cl::init(true));
#  144|   static cl::opt<bool>
#  145|->     ForceFastCluster("force-fast-cluster", cl::Hidden,
#  146|                        cl::desc("Switch to fast cluster algorithm with the lost "
#  147|                                 "of some fusion opportunities"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:150: constructor_uses_global_object: The constructor of global object "FastClusterThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FastClusterThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  148|                        cl::init(false));
#  149|   static cl::opt<unsigned>
#  150|->     FastClusterThreshold("fast-cluster-threshold", cl::Hidden,
#  151|                            cl::desc("The threshold for fast cluster"),
#  152|                            cl::init(1000));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:173: constructor_uses_global_object: The constructor of global object "MIResourceCutOff" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MIResourceCutOff" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  171|   
#  172|   static cl::opt<unsigned>
#  173|->     MIResourceCutOff("misched-resource-cutoff", cl::Hidden,
#  174|                        cl::desc("Number of intervals to track"), cl::init(10));
#  175|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:310: constructor_uses_global_object: The constructor of global object "MachineSchedOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MachineSchedOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  308|   static cl::opt<MachineSchedRegistry::ScheduleDAGCtor, false,
#  309|                  RegisterPassParser<MachineSchedRegistry>>
#  310|-> MachineSchedOpt("misched",
#  311|                   cl::init(&useDefaultMachineSched), cl::Hidden,
#  312|                   cl::desc("Machine instruction scheduler to use"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:318: constructor_uses_global_object: The constructor of global object "EnableMachineSched" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMachineSched" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  316|                        useDefaultMachineSched);
#  317|   
#  318|-> static cl::opt<bool> EnableMachineSched(
#  319|       "enable-misched",
#  320|       cl::desc("Enable the machine instruction scheduling pass."), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineScheduler.cpp:323: constructor_uses_global_object: The constructor of global object "EnablePostRAMachineSched" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePostRAMachineSched" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  321|       cl::Hidden);
#  322|   
#  323|-> static cl::opt<bool> EnablePostRAMachineSched(
#  324|       "enable-post-misched",
#  325|       cl::desc("Enable the post-ra machine instruction scheduling pass."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:68: constructor_uses_global_object: The constructor of global object "SplitEdges" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SplitEdges" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|   
#   67|   static cl::opt<bool>
#   68|-> SplitEdges("machine-sink-split",
#   69|              cl::desc("Split critical edges during machine sinking"),
#   70|              cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:73: constructor_uses_global_object: The constructor of global object "UseBlockFreqInfo" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseBlockFreqInfo" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   
#   72|   static cl::opt<bool>
#   73|-> UseBlockFreqInfo("machine-sink-bfi",
#   74|              cl::desc("Use block frequency info to find successors to sink"),
#   75|              cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:77: constructor_uses_global_object: The constructor of global object "SplitEdgeProbabilityThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SplitEdgeProbabilityThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|              cl::init(true), cl::Hidden);
#   76|   
#   77|-> static cl::opt<unsigned> SplitEdgeProbabilityThreshold(
#   78|       "machine-sink-split-probability-threshold",
#   79|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:86: constructor_uses_global_object: The constructor of global object "SinkLoadInstsPerBlockThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SinkLoadInstsPerBlockThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|       cl::init(40), cl::Hidden);
#   85|   
#   86|-> static cl::opt<unsigned> SinkLoadInstsPerBlockThreshold(
#   87|       "machine-sink-load-instrs-threshold",
#   88|       cl::desc("Do not try to find alias store for a load if there is a in-path "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:92: constructor_uses_global_object: The constructor of global object "SinkLoadBlocksThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SinkLoadBlocksThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   90|       cl::init(2000), cl::Hidden);
#   91|   
#   92|-> static cl::opt<unsigned> SinkLoadBlocksThreshold(
#   93|       "machine-sink-load-blocks-threshold",
#   94|       cl::desc("Do not try to find alias store for a load if the block number in "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:99: constructor_uses_global_object: The constructor of global object "SinkInstsIntoCycle" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SinkInstsIntoCycle" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   97|   
#   98|   static cl::opt<bool>
#   99|->     SinkInstsIntoCycle("sink-insts-to-avoid-spills",
#  100|                          cl::desc("Sink instructions into cycles to avoid "
#  101|                                   "register spills"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineSink.cpp:104: constructor_uses_global_object: The constructor of global object "SinkIntoCycleLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SinkIntoCycleLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  102|                          cl::init(false), cl::Hidden);
#  103|   
#  104|-> static cl::opt<unsigned> SinkIntoCycleLimit(
#  105|       "machine-sink-cycle-limit",
#  106|       cl::desc("The maximum number of instructions considered for cycle sinking."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MachineStripDebug.cpp:27: constructor_uses_global_object: The constructor of global object "<unnamed>::OnlyDebugifiedDefault" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::OnlyDebugifiedDefault" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   namespace {
#   26|   cl::opt<bool>
#   27|->     OnlyDebugifiedDefault("mir-strip-debugify-only",
#   28|                             cl::desc("Should mir-strip-debug only strip debug "
#   29|                                      "info from debugified modules by default"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/MacroFusion.cpp:31: constructor_uses_global_object: The constructor of global object "EnableMacroFusion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMacroFusion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   using namespace llvm;
#   30|   
#   31|-> static cl::opt<bool> EnableMacroFusion("misched-fusion", cl::Hidden,
#   32|     cl::desc("Enable scheduling for macro fusion."), cl::init(true));
#   33|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PHIElimination.cpp:50: constructor_uses_global_object: The constructor of global object "DisableEdgeSplitting" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableEdgeSplitting" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|   
#   49|   static cl::opt<bool>
#   50|-> DisableEdgeSplitting("disable-phi-elim-edge-splitting", cl::init(false),
#   51|                        cl::Hidden, cl::desc("Disable critical edge splitting "
#   52|                                             "during PHI elimination"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PHIElimination.cpp:55: constructor_uses_global_object: The constructor of global object "SplitAllCriticalEdges" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SplitAllCriticalEdges" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   
#   54|   static cl::opt<bool>
#   55|-> SplitAllCriticalEdges("phi-elim-split-all-critical-edges", cl::init(false),
#   56|                         cl::Hidden, cl::desc("Split all critical edges during "
#   57|                                              "PHI elimination"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PHIElimination.cpp:59: constructor_uses_global_object: The constructor of global object "NoPhiElimLiveOutEarlyExit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoPhiElimLiveOutEarlyExit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|                                              "PHI elimination"));
#   58|   
#   59|-> static cl::opt<bool> NoPhiElimLiveOutEarlyExit(
#   60|       "no-phi-elim-live-out-early-exit", cl::init(false), cl::Hidden,
#   61|       cl::desc("Do not use an early exit if isLiveOutPastPHIs returns true."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PeepholeOptimizer.cpp:106: constructor_uses_global_object: The constructor of global object "Aggressive" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Aggressive" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  104|   // Optimize Extensions
#  105|   static cl::opt<bool>
#  106|-> Aggressive("aggressive-ext-opt", cl::Hidden,
#  107|              cl::desc("Aggressive extension optimization"));
#  108|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PeepholeOptimizer.cpp:110: constructor_uses_global_object: The constructor of global object "DisablePeephole" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePeephole" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  108|   
#  109|   static cl::opt<bool>
#  110|-> DisablePeephole("disable-peephole", cl::Hidden, cl::init(false),
#  111|                   cl::desc("Disable the peephole optimizer"));
#  112|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PeepholeOptimizer.cpp:117: constructor_uses_global_object: The constructor of global object "DisableAdvCopyOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableAdvCopyOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  115|   /// bails on everything that is not a copy or a bitcast.
#  116|   static cl::opt<bool>
#  117|-> DisableAdvCopyOpt("disable-adv-copy-opt", cl::Hidden, cl::init(false),
#  118|                     cl::desc("Disable advanced copy optimization"));
#  119|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PeepholeOptimizer.cpp:120: constructor_uses_global_object: The constructor of global object "DisableNAPhysCopyOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableNAPhysCopyOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  118|                     cl::desc("Disable advanced copy optimization"));
#  119|   
#  120|-> static cl::opt<bool> DisableNAPhysCopyOpt(
#  121|       "disable-non-allocatable-phys-copy-opt", cl::Hidden, cl::init(false),
#  122|       cl::desc("Disable non-allocatable physical register copy optimization"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PeepholeOptimizer.cpp:126: constructor_uses_global_object: The constructor of global object "RewritePHILimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RewritePHILimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  124|   // Limit the number of PHI instructions to process
#  125|   // in PeepholeOptimizer::getNextSource.
#  126|-> static cl::opt<unsigned> RewritePHILimit(
#  127|       "rewrite-phi-limit", cl::Hidden, cl::init(10),
#  128|       cl::desc("Limit the length of PHI chains to lookup"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PeepholeOptimizer.cpp:132: constructor_uses_global_object: The constructor of global object "MaxRecurrenceChain" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxRecurrenceChain" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  130|   // Limit the length of recurrence chain when evaluating the benefit of
#  131|   // commuting operands.
#  132|-> static cl::opt<unsigned> MaxRecurrenceChain(
#  133|       "recurrence-chain-limit", cl::Hidden, cl::init(3),
#  134|       cl::desc("Maximum length of recurrence chain when evaluating the benefit "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PostRASchedulerList.cpp:54: constructor_uses_global_object: The constructor of global object "EnablePostRAScheduler" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePostRAScheduler" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   // override the target.
#   53|   static cl::opt<bool>
#   54|-> EnablePostRAScheduler("post-RA-scheduler",
#   55|                          cl::desc("Enable scheduling after register allocation"),
#   56|                          cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PostRASchedulerList.cpp:58: constructor_uses_global_object: The constructor of global object "EnableAntiDepBreaking[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAntiDepBreaking[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|                          cl::init(false), cl::Hidden);
#   57|   static cl::opt<std::string>
#   58|-> EnableAntiDepBreaking("break-anti-dependencies",
#   59|                         cl::desc("Break post-RA scheduling anti-dependencies: "
#   60|                                  "\"critical\", \"all\", or \"none\""),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PostRASchedulerList.cpp:65: constructor_uses_global_object: The constructor of global object "DebugDiv" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugDiv" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   // If DebugDiv > 0 then only schedule MBB with (ID % DebugDiv) == DebugMod
#   64|   static cl::opt<int>
#   65|-> DebugDiv("postra-sched-debugdiv",
#   66|                         cl::desc("Debug control MBBs that are scheduled"),
#   67|                         cl::init(0), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PostRASchedulerList.cpp:69: constructor_uses_global_object: The constructor of global object "DebugMod" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugMod" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|                         cl::init(0), cl::Hidden);
#   68|   static cl::opt<int>
#   69|-> DebugMod("postra-sched-debugmod",
#   70|                         cl::desc("Debug control MBBs that are scheduled"),
#   71|                         cl::init(0), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/PreISelIntrinsicLowering.cpp:38: constructor_uses_global_object: The constructor of global object "MemIntrinsicExpandSizeThresholdOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemIntrinsicExpandSizeThresholdOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   /// size larger than this will be expanded by the pass. Calls of unknown or
#   37|   /// lower size will be left for expansion in codegen.
#   38|-> static cl::opt<int64_t> MemIntrinsicExpandSizeThresholdOpt(
#   39|       "mem-intrinsic-expand-size",
#   40|       cl::desc("Set minimum mem intrinsic size to expand in IR"), cl::init(-1),

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/CodeGen/PrologEpilogInserter.cpp:789: tainted_data_return: Called function "StackBytesFree->find_next(FreeStart)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/CodeGen/PrologEpilogInserter.cpp:789: assign: Assigning: "FreeStart" = "StackBytesFree->find_next(FreeStart)".
llvm-17.0.6.src/lib/CodeGen/PrologEpilogInserter.cpp:823: overflow: The expression "FreeStart + ObjSize" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/CodeGen/PrologEpilogInserter.cpp:823: overflow_sink: "FreeStart + ObjSize", which might be negative, is passed to "StackBytesFree->reset(FreeStart, FreeStart + ObjSize)".
#  821|     }
#  822|   
#  823|->   StackBytesFree.reset(FreeStart, FreeStart + ObjSize);
#  824|     return true;
#  825|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/RDFGraph.cpp:1139: var_decl: Declaring variable "Refs".
llvm-17.0.6.src/lib/CodeGen/RDFGraph.cpp:1145: uninit_use: Using uninitialized value "Refs". Field "Refs.InlineElts" is uninitialized.
# 1143|       RA = getNextRelated(IA, RA);
# 1144|     } while (RA.Id != 0 && RA.Id != Start);
# 1145|->   return Refs;
# 1146|   }
# 1147|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/RDFGraph.cpp:1712: var_decl: Declaring variable "Res".
llvm-17.0.6.src/lib/CodeGen/RDFGraph.cpp:1719: uninit_use: Using uninitialized value "Res". Field "Res.InlineElts" is uninitialized.
# 1717|         N = RA.Addr->getSibling();
# 1718|       }
# 1719|->     return Res;
# 1720|     };
# 1721|     NodeList ReachedDefs = getAllNodes(DA.Addr->getReachedDef());

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RDFLiveness.cpp:55: constructor_uses_global_object: The constructor of global object "MaxRecNest" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxRecNest" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   using namespace llvm;
#   54|   
#   55|-> static cl::opt<unsigned> MaxRecNest("rdf-liveness-max-rec", cl::init(25),
#   56|                                       cl::Hidden,
#   57|                                       cl::desc("Maximum recursion level"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/RDFLiveness.cpp:108: var_decl: Declaring variable "RDefs".
llvm-17.0.6.src/lib/CodeGen/RDFLiveness.cpp:118: uninit_use: Using uninitialized value "RDefs". Field "RDefs.InlineElts" is uninitialized.
#  116|     // If the reference is undefined, there is nothing to do.
#  117|     if (RefA.Addr->getFlags() & NodeAttrs::Undef)
#  118|->     return RDefs;
#  119|   
#  120|     // The initial queue should not have reaching defs for shadows. The

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/RDFLiveness.cpp:108: var_decl: Declaring variable "RDefs".
llvm-17.0.6.src/lib/CodeGen/RDFLiveness.cpp:300: uninit_use: Using uninitialized value "RDefs". Field "RDefs.InlineElts" is uninitialized.
#  298|     llvm::erase_if(RDefs, DeadP);
#  299|   
#  300|->   return RDefs;
#  301|   }
#  302|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocBase.cpp:43: constructor_uses_global_object: The constructor of global object "VerifyRegAlloc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyRegAlloc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   // MachineVerifier.
#   42|   static cl::opt<bool, true>
#   43|->     VerifyRegAlloc("verify-regalloc", cl::location(RegAllocBase::VerifyEnabled),
#   44|                      cl::Hidden, cl::desc("Verify during register allocation"));
#   45|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocEvictionAdvisor.cpp:28: constructor_uses_global_object: The constructor of global object "Mode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   using namespace llvm;
#   27|   
#   28|-> static cl::opt<RegAllocEvictionAdvisorAnalysis::AdvisorMode> Mode(
#   29|       "regalloc-enable-advisor", cl::Hidden,
#   30|       cl::init(RegAllocEvictionAdvisorAnalysis::AdvisorMode::Default),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocEvictionAdvisor.cpp:40: constructor_uses_global_object: The constructor of global object "EnableLocalReassignment" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLocalReassignment" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|                      "development", "for training")));
#   39|   
#   40|-> static cl::opt<bool> EnableLocalReassignment(
#   41|       "enable-local-reassign", cl::Hidden,
#   42|       cl::desc("Local reassignment can yield better allocation decisions, but "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocEvictionAdvisor.cpp:47: constructor_uses_global_object: The constructor of global object "llvm::EvictInterferenceCutoff" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::EvictInterferenceCutoff" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   
#   46|   namespace llvm {
#   47|-> cl::opt<unsigned> EvictInterferenceCutoff(
#   48|       "regalloc-eviction-max-interference-cutoff", cl::Hidden,
#   49|       cl::desc("Number of interferences after which we declare "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocFast.cpp:57: constructor_uses_global_object: The constructor of global object "IgnoreMissingDefs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IgnoreMissingDefs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|   
#   56|   // FIXME: Remove this switch when all testcases are fixed!
#   57|-> static cl::opt<bool> IgnoreMissingDefs("rafast-ignore-missing-defs",
#   58|                                          cl::Hidden);
#   59|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:86: constructor_uses_global_object: The constructor of global object "SplitSpillMode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SplitSpillMode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|   STATISTIC(NumEvicted,      "Number of interferences evicted");
#   85|   
#   86|-> static cl::opt<SplitEditor::ComplementSpillMode> SplitSpillMode(
#   87|       "split-spill-mode", cl::Hidden,
#   88|       cl::desc("Spill mode for splitting live ranges"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:95: constructor_uses_global_object: The constructor of global object "LastChanceRecoloringMaxDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LastChanceRecoloringMaxDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   93|   
#   94|   static cl::opt<unsigned>
#   95|-> LastChanceRecoloringMaxDepth("lcr-max-depth", cl::Hidden,
#   96|                                cl::desc("Last chance recoloring max depth"),
#   97|                                cl::init(5));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:99: constructor_uses_global_object: The constructor of global object "LastChanceRecoloringMaxInterference" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LastChanceRecoloringMaxInterference" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   97|                                cl::init(5));
#   98|   
#   99|-> static cl::opt<unsigned> LastChanceRecoloringMaxInterference(
#  100|       "lcr-max-interf", cl::Hidden,
#  101|       cl::desc("Last chance recoloring maximum number of considered"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:105: constructor_uses_global_object: The constructor of global object "ExhaustiveSearch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExhaustiveSearch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  103|       cl::init(8));
#  104|   
#  105|-> static cl::opt<bool> ExhaustiveSearch(
#  106|       "exhaustive-register-search", cl::NotHidden,
#  107|       cl::desc("Exhaustive Search for registers bypassing the depth "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:111: constructor_uses_global_object: The constructor of global object "EnableDeferredSpilling" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableDeferredSpilling" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  109|       cl::Hidden);
#  110|   
#  111|-> static cl::opt<bool> EnableDeferredSpilling(
#  112|       "enable-deferred-spilling", cl::Hidden,
#  113|       cl::desc("Instead of spilling a variable right away, defer the actual "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:121: constructor_uses_global_object: The constructor of global object "CSRFirstTimeCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CSRFirstTimeCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  119|   // FIXME: Find a good default for this flag and remove the flag.
#  120|   static cl::opt<unsigned>
#  121|-> CSRFirstTimeCost("regalloc-csr-first-time-cost",
#  122|                 cl::desc("Cost for first time use of callee-saved register."),
#  123|                 cl::init(0), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:125: constructor_uses_global_object: The constructor of global object "GrowRegionComplexityBudget" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GrowRegionComplexityBudget" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  123|                 cl::init(0), cl::Hidden);
#  124|   
#  125|-> static cl::opt<unsigned long> GrowRegionComplexityBudget(
#  126|       "grow-region-complexity-budget",
#  127|       cl::desc("growRegion() does not scale with the number of BB edges, so "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:131: constructor_uses_global_object: The constructor of global object "GreedyRegClassPriorityTrumpsGlobalness" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GreedyRegClassPriorityTrumpsGlobalness" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  129|       cl::init(10000), cl::Hidden);
#  130|   
#  131|-> static cl::opt<bool> GreedyRegClassPriorityTrumpsGlobalness(
#  132|       "greedy-regclass-priority-trumps-globalness",
#  133|       cl::desc("Change the greedy register allocator's live range priority "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocGreedy.cpp:138: constructor_uses_global_object: The constructor of global object "GreedyReverseLocalAssignment" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GreedyReverseLocalAssignment" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  136|       cl::Hidden);
#  137|   
#  138|-> static cl::opt<bool> GreedyReverseLocalAssignment(
#  139|       "greedy-reverse-local-assignment",
#  140|       cl::desc("Reverse allocation order of local live ranges, such that "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocPBQP.cpp:99: constructor_uses_global_object: The constructor of global object "PBQPCoalescing" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PBQPCoalescing" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   97|   
#   98|   static cl::opt<bool>
#   99|-> PBQPCoalescing("pbqp-coalescing",
#  100|                   cl::desc("Attempt coalescing during PBQP register allocation."),
#  101|                   cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocPriorityAdvisor.cpp:23: constructor_uses_global_object: The constructor of global object "Mode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   using namespace llvm;
#   22|   
#   23|-> static cl::opt<RegAllocPriorityAdvisorAnalysis::AdvisorMode> Mode(
#   24|       "regalloc-enable-priority-advisor", cl::Hidden,
#   25|       cl::init(RegAllocPriorityAdvisorAnalysis::AdvisorMode::Default),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocScore.cpp:29: constructor_uses_global_object: The constructor of global object "CopyWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CopyWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|   
#   28|   using namespace llvm;
#   29|-> cl::opt<double> CopyWeight("regalloc-copy-weight", cl::init(0.2), cl::Hidden);
#   30|   cl::opt<double> LoadWeight("regalloc-load-weight", cl::init(4.0), cl::Hidden);
#   31|   cl::opt<double> StoreWeight("regalloc-store-weight", cl::init(1.0), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocScore.cpp:30: constructor_uses_global_object: The constructor of global object "LoadWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LoadWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   using namespace llvm;
#   29|   cl::opt<double> CopyWeight("regalloc-copy-weight", cl::init(0.2), cl::Hidden);
#   30|-> cl::opt<double> LoadWeight("regalloc-load-weight", cl::init(4.0), cl::Hidden);
#   31|   cl::opt<double> StoreWeight("regalloc-store-weight", cl::init(1.0), cl::Hidden);
#   32|   cl::opt<double> CheapRematWeight("regalloc-cheap-remat-weight", cl::init(0.2),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocScore.cpp:31: constructor_uses_global_object: The constructor of global object "StoreWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StoreWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   cl::opt<double> CopyWeight("regalloc-copy-weight", cl::init(0.2), cl::Hidden);
#   30|   cl::opt<double> LoadWeight("regalloc-load-weight", cl::init(4.0), cl::Hidden);
#   31|-> cl::opt<double> StoreWeight("regalloc-store-weight", cl::init(1.0), cl::Hidden);
#   32|   cl::opt<double> CheapRematWeight("regalloc-cheap-remat-weight", cl::init(0.2),
#   33|                                    cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocScore.cpp:32: constructor_uses_global_object: The constructor of global object "CheapRematWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CheapRematWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   cl::opt<double> LoadWeight("regalloc-load-weight", cl::init(4.0), cl::Hidden);
#   31|   cl::opt<double> StoreWeight("regalloc-store-weight", cl::init(1.0), cl::Hidden);
#   32|-> cl::opt<double> CheapRematWeight("regalloc-cheap-remat-weight", cl::init(0.2),
#   33|                                    cl::Hidden);
#   34|   cl::opt<double> ExpensiveRematWeight("regalloc-expensive-remat-weight",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegAllocScore.cpp:34: constructor_uses_global_object: The constructor of global object "ExpensiveRematWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExpensiveRematWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   cl::opt<double> CheapRematWeight("regalloc-cheap-remat-weight", cl::init(0.2),
#   33|                                    cl::Hidden);
#   34|-> cl::opt<double> ExpensiveRematWeight("regalloc-expensive-remat-weight",
#   35|                                        cl::init(1.0), cl::Hidden);
#   36|   #define DEBUG_TYPE "regalloc-score"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterClassInfo.cpp:37: constructor_uses_global_object: The constructor of global object "StressRA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StressRA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|   
#   36|   static cl::opt<unsigned>
#   37|-> StressRA("stress-regalloc", cl::Hidden, cl::init(0), cl::value_desc("N"),
#   38|            cl::desc("Limit all regclasses to N registers"));
#   39|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:75: constructor_uses_global_object: The constructor of global object "EnableJoining" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableJoining" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   73|   STATISTIC(NumShrinkToUses,  "Number of shrinkToUses called");
#   74|   
#   75|-> static cl::opt<bool> EnableJoining("join-liveintervals",
#   76|                                      cl::desc("Coalesce copies (default=true)"),
#   77|                                      cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:79: constructor_uses_global_object: The constructor of global object "UseTerminalRule" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseTerminalRule" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|                                      cl::init(true), cl::Hidden);
#   78|   
#   79|-> static cl::opt<bool> UseTerminalRule("terminal-rule",
#   80|                                        cl::desc("Apply the terminal rule"),
#   81|                                        cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:85: constructor_uses_global_object: The constructor of global object "EnableJoinSplits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableJoinSplits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|   /// Temporary flag to test critical edge unsplitting.
#   84|   static cl::opt<bool>
#   85|-> EnableJoinSplits("join-splitedges",
#   86|     cl::desc("Coalesce copies on split edges (default=subtarget)"), cl::Hidden);
#   87|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:90: constructor_uses_global_object: The constructor of global object "EnableGlobalCopies" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalCopies" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   88|   /// Temporary flag to test global copy optimization.
#   89|   static cl::opt<cl::boolOrDefault>
#   90|-> EnableGlobalCopies("join-globalcopies",
#   91|     cl::desc("Coalesce copies that span blocks (default=subtarget)"),
#   92|     cl::init(cl::BOU_UNSET), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:95: constructor_uses_global_object: The constructor of global object "VerifyCoalescing" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyCoalescing" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   93|   
#   94|   static cl::opt<bool>
#   95|-> VerifyCoalescing("verify-coalescing",
#   96|            cl::desc("Verify machine instrs before and after register coalescing"),
#   97|            cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:99: constructor_uses_global_object: The constructor of global object "LateRematUpdateThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LateRematUpdateThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   97|            cl::Hidden);
#   98|   
#   99|-> static cl::opt<unsigned> LateRematUpdateThreshold(
#  100|       "late-remat-update-threshold", cl::Hidden,
#  101|       cl::desc("During rematerialization for a copy, if the def instruction has "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:108: constructor_uses_global_object: The constructor of global object "LargeIntervalSizeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LargeIntervalSizeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|       cl::init(100));
#  107|   
#  108|-> static cl::opt<unsigned> LargeIntervalSizeThreshold(
#  109|       "large-interval-size-threshold", cl::Hidden,
#  110|       cl::desc("If the valnos size of an interval is larger than the threshold, "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterCoalescer.cpp:114: constructor_uses_global_object: The constructor of global object "LargeIntervalFreqThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LargeIntervalFreqThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|       cl::init(100));
#  113|   
#  114|-> static cl::opt<unsigned> LargeIntervalFreqThreshold(
#  115|       "large-interval-freq-threshold", cl::Hidden,
#  116|       cl::desc("For a large interval, if it is coalesed with other live "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/RegisterUsageInfo.cpp:31: constructor_uses_global_object: The constructor of global object "DumpRegUsage" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DumpRegUsage" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   using namespace llvm;
#   30|   
#   31|-> static cl::opt<bool> DumpRegUsage(
#   32|       "print-regusage", cl::init(false), cl::Hidden,
#   33|       cl::desc("print register usage details collected for analysis."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SafeStack.cpp:97: constructor_uses_global_object: The constructor of global object "SafeStackUsePointerAddress" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SafeStackUsePointerAddress" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   95|   /// access safe stack pointer.
#   96|   static cl::opt<bool>
#   97|->     SafeStackUsePointerAddress("safestack-use-pointer-address",
#   98|                                     cl::init(false), cl::Hidden);
#   99|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SafeStack.cpp:100: constructor_uses_global_object: The constructor of global object "ClColoring" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClColoring" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   98|                                     cl::init(false), cl::Hidden);
#   99|   
#  100|-> static cl::opt<bool> ClColoring("safe-stack-coloring",
#  101|                                   cl::desc("enable safe stack coloring"),
#  102|                                   cl::Hidden, cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SafeStackLayout.cpp:23: constructor_uses_global_object: The constructor of global object "ClLayout" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClLayout" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   #define DEBUG_TYPE "safestacklayout"
#   22|   
#   23|-> static cl::opt<bool> ClLayout("safe-stack-layout",
#   24|                                 cl::desc("enable safe stack layout"), cl::Hidden,
#   25|                                 cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ScheduleDAGInstrs.cpp:65: constructor_uses_global_object: The constructor of global object "EnableAASchedMI" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAASchedMI" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   
#   64|   static cl::opt<bool>
#   65|->     EnableAASchedMI("enable-aa-sched-mi", cl::Hidden,
#   66|                       cl::desc("Enable use of AA during MI DAG construction"));
#   67|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ScheduleDAGInstrs.cpp:68: constructor_uses_global_object: The constructor of global object "UseTBAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseTBAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|                       cl::desc("Enable use of AA during MI DAG construction"));
#   67|   
#   68|-> static cl::opt<bool> UseTBAA("use-tbaa-in-sched-mi", cl::Hidden,
#   69|       cl::init(true), cl::desc("Enable use of TBAA during MI DAG construction"));
#   70|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ScheduleDAGInstrs.cpp:77: constructor_uses_global_object: The constructor of global object "HugeRegion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HugeRegion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|   // When Stores and Loads maps (or NonAliasStores and NonAliasLoads)
#   76|   // together hold this many SUs, a reduction of maps will be done.
#   77|-> static cl::opt<unsigned> HugeRegion("dag-maps-huge-region", cl::Hidden,
#   78|       cl::init(1000), cl::desc("The limit to use while constructing the DAG "
#   79|                                "prior to scheduling, at which point a trade-off "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ScheduleDAGInstrs.cpp:82: constructor_uses_global_object: The constructor of global object "ReductionSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReductionSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|                                "is made to avoid excessive compile time."));
#   81|   
#   82|-> static cl::opt<unsigned> ReductionSize(
#   83|       "dag-maps-reduction-size", cl::Hidden,
#   84|       cl::desc("A huge scheduling region will have maps reduced by this many "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:62: constructor_uses_global_object: The constructor of global object "ColdOperandThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ColdOperandThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   STATISTIC(NumSelectsConverted, "Number of selects converted");
#   61|   
#   62|-> static cl::opt<unsigned> ColdOperandThreshold(
#   63|       "cold-operand-threshold",
#   64|       cl::desc("Maximum frequency of path for an operand to be considered cold."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:67: constructor_uses_global_object: The constructor of global object "ColdOperandMaxCostMultiplier" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ColdOperandMaxCostMultiplier" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|       cl::init(20), cl::Hidden);
#   66|   
#   67|-> static cl::opt<unsigned> ColdOperandMaxCostMultiplier(
#   68|       "cold-operand-max-cost-multiplier",
#   69|       cl::desc("Maximum cost multiplier of TCC_expensive for the dependence "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:74: constructor_uses_global_object: The constructor of global object "GainGradientThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GainGradientThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   
#   73|   static cl::opt<unsigned>
#   74|->     GainGradientThreshold("select-opti-loop-gradient-gain-threshold",
#   75|                             cl::desc("Gradient gain threshold (%)."),
#   76|                             cl::init(25), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:79: constructor_uses_global_object: The constructor of global object "GainCycleThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GainCycleThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   
#   78|   static cl::opt<unsigned>
#   79|->     GainCycleThreshold("select-opti-loop-cycle-gain-threshold",
#   80|                          cl::desc("Minimum gain per loop (in cycles) threshold."),
#   81|                          cl::init(4), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:83: constructor_uses_global_object: The constructor of global object "GainRelativeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GainRelativeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   81|                          cl::init(4), cl::Hidden);
#   82|   
#   83|-> static cl::opt<unsigned> GainRelativeThreshold(
#   84|       "select-opti-loop-relative-gain-threshold",
#   85|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:89: constructor_uses_global_object: The constructor of global object "MispredictDefaultRate" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MispredictDefaultRate" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   87|       cl::init(8), cl::Hidden);
#   88|   
#   89|-> static cl::opt<unsigned> MispredictDefaultRate(
#   90|       "mispredict-default-rate", cl::Hidden, cl::init(25),
#   91|       cl::desc("Default mispredict rate (initialized to 25%)."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectOptimize.cpp:94: constructor_uses_global_object: The constructor of global object "DisableLoopLevelHeuristics" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLoopLevelHeuristics" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   92|   
#   93|   static cl::opt<bool>
#   94|->     DisableLoopLevelHeuristics("disable-loop-level-heuristics", cl::Hidden,
#   95|                                  cl::init(false),
#   96|                                  cl::desc("Disable loop-level heuristics."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:91: constructor_uses_global_object: The constructor of global object "CombinerGlobalAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CombinerGlobalAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   89|   
#   90|   static cl::opt<bool>
#   91|-> CombinerGlobalAA("combiner-global-alias-analysis", cl::Hidden,
#   92|                    cl::desc("Enable DAG combiner's use of IR alias analysis"));
#   93|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:95: constructor_uses_global_object: The constructor of global object "UseTBAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseTBAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   93|   
#   94|   static cl::opt<bool>
#   95|-> UseTBAA("combiner-use-tbaa", cl::Hidden, cl::init(true),
#   96|           cl::desc("Enable DAG combiner's use of TBAA"));
#   97|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:108: constructor_uses_global_object: The constructor of global object "StressLoadSlicing" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StressLoadSlicing" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|   /// is enabled, load slicing bypasses most of its profitability guards.
#  107|   static cl::opt<bool>
#  108|-> StressLoadSlicing("combiner-stress-load-slicing", cl::Hidden,
#  109|                     cl::desc("Bypass the profitability model of load slicing"),
#  110|                     cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:113: constructor_uses_global_object: The constructor of global object "MaySplitLoadIndex" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaySplitLoadIndex" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  111|   
#  112|   static cl::opt<bool>
#  113|->   MaySplitLoadIndex("combiner-split-load-index", cl::Hidden, cl::init(true),
#  114|                       cl::desc("DAG combiner may split indexing from loads"));
#  115|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:117: constructor_uses_global_object: The constructor of global object "EnableStoreMerging" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableStoreMerging" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  115|   
#  116|   static cl::opt<bool>
#  117|->     EnableStoreMerging("combiner-store-merging", cl::Hidden, cl::init(true),
#  118|                          cl::desc("DAG combiner enable merging multiple stores "
#  119|                                   "into a wider store"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:121: constructor_uses_global_object: The constructor of global object "TokenFactorInlineLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TokenFactorInlineLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  119|                                   "into a wider store"));
#  120|   
#  121|-> static cl::opt<unsigned> TokenFactorInlineLimit(
#  122|       "combiner-tokenfactor-inline-limit", cl::Hidden, cl::init(2048),
#  123|       cl::desc("Limit the number of operands to inline for Token Factors"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:125: constructor_uses_global_object: The constructor of global object "StoreMergeDependenceLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StoreMergeDependenceLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  123|       cl::desc("Limit the number of operands to inline for Token Factors"));
#  124|   
#  125|-> static cl::opt<unsigned> StoreMergeDependenceLimit(
#  126|       "combiner-store-merge-dependence-limit", cl::Hidden, cl::init(10),
#  127|       cl::desc("Limit the number of times for the same StoreNode and RootNode "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:130: constructor_uses_global_object: The constructor of global object "EnableReduceLoadOpStoreWidth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableReduceLoadOpStoreWidth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|                "to bail out in store merging dependence check"));
#  129|   
#  130|-> static cl::opt<bool> EnableReduceLoadOpStoreWidth(
#  131|       "combiner-reduce-load-op-store-width", cl::Hidden, cl::init(true),
#  132|       cl::desc("DAG combiner enable reducing the width of load/op/store "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:135: constructor_uses_global_object: The constructor of global object "EnableShrinkLoadReplaceStoreWithStore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableShrinkLoadReplaceStoreWithStore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|                "sequence"));
#  134|   
#  135|-> static cl::opt<bool> EnableShrinkLoadReplaceStoreWithStore(
#  136|       "combiner-shrink-load-replace-store-with-store", cl::Hidden, cl::init(true),
#  137|       cl::desc("DAG combiner enable load/<replace bytes>/store with "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:140: constructor_uses_global_object: The constructor of global object "EnableVectorFCopySignExtendRound" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableVectorFCopySignExtendRound" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|                "a narrower store"));
#  139|   
#  140|-> static cl::opt<bool> EnableVectorFCopySignExtendRound(
#  141|       "combiner-vector-fcopysign-extend-round", cl::Hidden, cl::init(false),
#  142|       cl::desc(

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1852: address_of: Taking address with "&RV" yields a singleton pointer.
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:1852: callee_ptr_arith: Passing "&RV" to function "ReplaceAllUsesWith" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 1850|         assert(N->getValueType(0) == RV.getValueType() &&
# 1851|                N->getNumValues() == 1 && "Type mismatch");
# 1852|->       DAG.ReplaceAllUsesWith(N, &RV);
# 1853|       }
# 1854|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/FastISel.cpp:1008: var_decl: Declaring variable "MyFlags".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/FastISel.cpp:1018: uninit_use_in_call: Using uninitialized value "MyFlags". Field "MyFlags.OrigArgIndex" is uninitialized when calling "push_back".
# 1016|         if (CLI.IsInReg)
# 1017|           MyFlags.Flags.setInReg();
# 1018|->       CLI.Ins.push_back(MyFlags);
# 1019|       }
# 1020|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1367: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(this->DAG.EVTToAPFloatSemantics(NVT), llvm::APInt(64U, C.getRawData()[1], false))".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1367: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1365|     APInt C = cast<ConstantFPSDNode>(N)->getValueAPF().bitcastToAPInt();
# 1366|     SDLoc dl(N);
# 1367|->   Lo = DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(NVT),
# 1368|                                    APInt(64, C.getRawData()[1])),
# 1369|                            dl, NVT);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1370: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(this->DAG.EVTToAPFloatSemantics(NVT), llvm::APInt(64U, C.getRawData()[0], false))".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1370: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1368|                                    APInt(64, C.getRawData()[1])),
# 1369|                            dl, NVT);
# 1370|->   Hi = DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(NVT),
# 1371|                                    APInt(64, C.getRawData()[0])),
# 1372|                            dl, NVT);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1606: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(this->DAG.EVTToAPFloatSemantics(NVT), llvm::APInt(llvm::TypeSize(NVT.getSizeInBits()).operator llvm::details::FixedOrScalableQuantity<llvm::TypeSize, unsigned long>::ScalarTy(), 0UL, false))".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1606: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1604|     }
# 1605|   
# 1606|->   Lo = DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(NVT),
# 1607|                                    APInt(NVT.getSizeInBits(), 0)), dl, NVT);
# 1608|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1736: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(this->DAG.EVTToAPFloatSemantics(NVT), llvm::APInt(llvm::TypeSize(NVT.getSizeInBits()).operator llvm::details::FixedOrScalableQuantity<llvm::TypeSize, unsigned long>::ScalarTy(), 0UL, false))".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:1736: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1734|   
# 1735|     // The low part is zero.
# 1736|->   Lo = DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(NVT),
# 1737|                                    APInt(NVT.getSizeInBits(), 0)), dl, NVT);
# 1738|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp:26: constructor_uses_global_object: The constructor of global object "EnableExpensiveChecks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableExpensiveChecks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   
#   25|   static cl::opt<bool>
#   26|-> EnableExpensiveChecks("enable-legalize-types-checking", cl::Hidden);
#   27|   
#   28|   /// Do extensive, expensive, basic correctness checking.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:36: constructor_uses_global_object: The constructor of global object "DisableDFASched" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableDFASched" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   
#   35|   static cl::opt<bool>
#   36|->     DisableDFASched("disable-dfa-sched", cl::Hidden,
#   37|                       cl::desc("Disable use of DFA during scheduling"));
#   38|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:39: constructor_uses_global_object: The constructor of global object "RegPressureThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RegPressureThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|                       cl::desc("Disable use of DFA during scheduling"));
#   38|   
#   39|-> static cl::opt<int> RegPressureThreshold(
#   40|       "dfa-sched-reg-pressure-threshold", cl::Hidden, cl::init(5),
#   41|       cl::desc("Track reg pressure and switch priority to in-depth"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:195: var_decl: Declaring variable "Dependencies".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:201: uninit_use: Using uninitialized value "Dependencies". Field "Dependencies.InlineElts" is uninitialized.
#  199|       for (SDNode *Node : getAdditionalDependencies())
#  200|         Dependencies.push_back(Node);
#  201|->     return Dependencies;
#  202|     }
#  203|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:273: var_decl: Declaring variable "ChainPred".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:295: uninit_use_in_call: Using uninitialized value "ChainPred". Field "ChainPred.Contents" is uninitialized when calling "RemovePred".
#  293|   
#  294|       if (ChainPred.getSUnit()) {
#  295|->       RemovePred(SU, ChainPred);
#  296|         if (isNewLoad)
#  297|           AddPred(LoadSU, ChainPred);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:92: constructor_uses_global_object: The constructor of global object "DisableSchedCycles" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedCycles" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   90|                         createILPListDAGScheduler);
#   91|   
#   92|-> static cl::opt<bool> DisableSchedCycles(
#   93|     "disable-sched-cycles", cl::Hidden, cl::init(false),
#   94|     cl::desc("Disable cycle-level precision during preRA scheduling"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:98: constructor_uses_global_object: The constructor of global object "DisableSchedRegPressure" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedRegPressure" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   96|   // Temporary sched=list-ilp flags until the heuristics are robust.
#   97|   // Some options are also available under sched=list-hybrid.
#   98|-> static cl::opt<bool> DisableSchedRegPressure(
#   99|     "disable-sched-reg-pressure", cl::Hidden, cl::init(false),
#  100|     cl::desc("Disable regpressure priority in sched=list-ilp"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:101: constructor_uses_global_object: The constructor of global object "DisableSchedLiveUses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedLiveUses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   99|     "disable-sched-reg-pressure", cl::Hidden, cl::init(false),
#  100|     cl::desc("Disable regpressure priority in sched=list-ilp"));
#  101|-> static cl::opt<bool> DisableSchedLiveUses(
#  102|     "disable-sched-live-uses", cl::Hidden, cl::init(true),
#  103|     cl::desc("Disable live use priority in sched=list-ilp"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:104: constructor_uses_global_object: The constructor of global object "DisableSchedVRegCycle" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedVRegCycle" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  102|     "disable-sched-live-uses", cl::Hidden, cl::init(true),
#  103|     cl::desc("Disable live use priority in sched=list-ilp"));
#  104|-> static cl::opt<bool> DisableSchedVRegCycle(
#  105|     "disable-sched-vrcycle", cl::Hidden, cl::init(false),
#  106|     cl::desc("Disable virtual register cycle interference checks"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:107: constructor_uses_global_object: The constructor of global object "DisableSchedPhysRegJoin" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedPhysRegJoin" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  105|     "disable-sched-vrcycle", cl::Hidden, cl::init(false),
#  106|     cl::desc("Disable virtual register cycle interference checks"));
#  107|-> static cl::opt<bool> DisableSchedPhysRegJoin(
#  108|     "disable-sched-physreg-join", cl::Hidden, cl::init(false),
#  109|     cl::desc("Disable physreg def-use affinity"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:110: constructor_uses_global_object: The constructor of global object "DisableSchedStalls" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedStalls" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  108|     "disable-sched-physreg-join", cl::Hidden, cl::init(false),
#  109|     cl::desc("Disable physreg def-use affinity"));
#  110|-> static cl::opt<bool> DisableSchedStalls(
#  111|     "disable-sched-stalls", cl::Hidden, cl::init(true),
#  112|     cl::desc("Disable no-stall priority in sched=list-ilp"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:113: constructor_uses_global_object: The constructor of global object "DisableSchedCriticalPath" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedCriticalPath" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  111|     "disable-sched-stalls", cl::Hidden, cl::init(true),
#  112|     cl::desc("Disable no-stall priority in sched=list-ilp"));
#  113|-> static cl::opt<bool> DisableSchedCriticalPath(
#  114|     "disable-sched-critical-path", cl::Hidden, cl::init(false),
#  115|     cl::desc("Disable critical path priority in sched=list-ilp"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:116: constructor_uses_global_object: The constructor of global object "DisableSchedHeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSchedHeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  114|     "disable-sched-critical-path", cl::Hidden, cl::init(false),
#  115|     cl::desc("Disable critical path priority in sched=list-ilp"));
#  116|-> static cl::opt<bool> DisableSchedHeight(
#  117|     "disable-sched-height", cl::Hidden, cl::init(false),
#  118|     cl::desc("Disable scheduled-height priority in sched=list-ilp"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:119: constructor_uses_global_object: The constructor of global object "Disable2AddrHack" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Disable2AddrHack" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|     "disable-sched-height", cl::Hidden, cl::init(false),
#  118|     cl::desc("Disable scheduled-height priority in sched=list-ilp"));
#  119|-> static cl::opt<bool> Disable2AddrHack(
#  120|     "disable-2addr-hack", cl::Hidden, cl::init(true),
#  121|     cl::desc("Disable scheduler's two-address hack"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:123: constructor_uses_global_object: The constructor of global object "MaxReorderWindow" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxReorderWindow" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  121|     cl::desc("Disable scheduler's two-address hack"));
#  122|   
#  123|-> static cl::opt<int> MaxReorderWindow(
#  124|     "max-sched-reorder", cl::Hidden, cl::init(6),
#  125|     cl::desc("Number of instructions to allow ahead of the critical path "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:128: constructor_uses_global_object: The constructor of global object "AvgIPC" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AvgIPC" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|              "in sched=list-ilp"));
#  127|   
#  128|-> static cl::opt<unsigned> AvgIPC(
#  129|     "sched-avg-ipc", cl::Hidden, cl::init(1),
#  130|     cl::desc("Average inst/cycle whan no target itinerary exists."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:44: constructor_uses_global_object: The constructor of global object "HighLatencyCycles" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HighLatencyCycles" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   // without a target itinerary. The choice of number here has more to do with
#   43|   // balancing scheduler heuristics than with the actual machine latency.
#   44|-> static cl::opt<int> HighLatencyCycles(
#   45|     "sched-high-latency-cycles", cl::Hidden, cl::init(10),
#   46|     cl::desc("Roughly estimate the number of cycles that 'long latency'"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:101: constructor_uses_global_object: The constructor of global object "EnableMemCpyDAGOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMemCpyDAGOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   99|   #define DEBUG_TYPE "selectiondag"
#  100|   
#  101|-> static cl::opt<bool> EnableMemCpyDAGOpt("enable-memcpy-dag-opt",
#  102|          cl::Hidden, cl::init(true),
#  103|          cl::desc("Gang up loads and stores generated by inlining of memcpy"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:105: constructor_uses_global_object: The constructor of global object "MaxLdStGlue" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxLdStGlue" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  103|          cl::desc("Gang up loads and stores generated by inlining of memcpy"));
#  104|   
#  105|-> static cl::opt<int> MaxLdStGlue("ldstmemcpy-glue-max",
#  106|          cl::desc("Number limit for gluing ld/st of memcpy."),
#  107|          cl::Hidden, cl::init(0));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:1723: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat((float)Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:1723: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1721|     EVT EltVT = VT.getScalarType();
# 1722|     if (EltVT == MVT::f32)
# 1723|->     return getConstantFP(APFloat((float)Val), DL, VT, isTarget);
# 1724|     if (EltVT == MVT::f64)
# 1725|       return getConstantFP(APFloat(Val), DL, VT, isTarget);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:1725: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:1725: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1723|       return getConstantFP(APFloat((float)Val), DL, VT, isTarget);
# 1724|     if (EltVT == MVT::f64)
# 1725|->     return getConstantFP(APFloat(Val), DL, VT, isTarget);
# 1726|     if (EltVT == MVT::f80 || EltVT == MVT::f128 || EltVT == MVT::ppcf128 ||
# 1727|         EltVT == MVT::f16 || EltVT == MVT::bf16) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5456: var_decl: Declaring variable "apf".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5458: uninit_use_in_call: Using uninitialized value "apf.U" when calling "convertFromAPInt".
# 5456|         APFloat apf(EVTToAPFloatSemantics(VT),
# 5457|                     APInt::getZero(VT.getSizeInBits()));
# 5458|->       (void)apf.convertFromAPInt(Val,
# 5459|                                    Opcode==ISD::SINT_TO_FP,
# 5460|                                    APFloat::rmNearestTiesToEven);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5465: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEhalf(), Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5465: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5463|       case ISD::BITCAST:
# 5464|         if (VT == MVT::f16 && C->getValueType(0) == MVT::i16)
# 5465|->         return getConstantFP(APFloat(APFloat::IEEEhalf(), Val), DL, VT);
# 5466|         if (VT == MVT::f32 && C->getValueType(0) == MVT::i32)
# 5467|           return getConstantFP(APFloat(APFloat::IEEEsingle(), Val), DL, VT);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5467: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5467: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5465|           return getConstantFP(APFloat(APFloat::IEEEhalf(), Val), DL, VT);
# 5466|         if (VT == MVT::f32 && C->getValueType(0) == MVT::i32)
# 5467|->         return getConstantFP(APFloat(APFloat::IEEEsingle(), Val), DL, VT);
# 5468|         if (VT == MVT::f64 && C->getValueType(0) == MVT::i64)
# 5469|           return getConstantFP(APFloat(APFloat::IEEEdouble(), Val), DL, VT);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5469: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5469: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5467|           return getConstantFP(APFloat(APFloat::IEEEsingle(), Val), DL, VT);
# 5468|         if (VT == MVT::f64 && C->getValueType(0) == MVT::i64)
# 5469|->         return getConstantFP(APFloat(APFloat::IEEEdouble(), Val), DL, VT);
# 5470|         if (VT == MVT::f128 && C->getValueType(0) == MVT::i128)
# 5471|           return getConstantFP(APFloat(APFloat::IEEEquad(), Val), DL, VT);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5471: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEquad(), Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:5471: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5469|           return getConstantFP(APFloat(APFloat::IEEEdouble(), Val), DL, VT);
# 5470|         if (VT == MVT::f128 && C->getValueType(0) == MVT::i128)
# 5471|->         return getConstantFP(APFloat(APFloat::IEEEquad(), Val), DL, VT);
# 5472|         break;
# 5473|       case ISD::ABS:

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:7081: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(DAG.EVTToAPFloatSemantics(VT), Val)".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:7081: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 7079|         return DAG.getConstant(Val, dl, VT, false, IsOpaque);
# 7080|       }
# 7081|->     return DAG.getConstantFP(APFloat(DAG.EVTToAPFloatSemantics(VT), Val), dl,
# 7082|                                VT);
# 7083|     }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:119: constructor_uses_global_object: The constructor of global object "InsertAssertAlign" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InsertAssertAlign" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|   
#  118|   static cl::opt<bool>
#  119|->     InsertAssertAlign("insert-assert-align", cl::init(true),
#  120|                         cl::desc("Insert the experimental `assertalign` node."),
#  121|                         cl::ReallyHidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:124: constructor_uses_global_object: The constructor of global object "LimitFPPrecision" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LimitFPPrecision" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  122|   
#  123|   static cl::opt<unsigned, true>
#  124|->     LimitFPPrecision("limit-float-precision",
#  125|                        cl::desc("Generate low-precision inline sequences "
#  126|                                 "for some float libcalls"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:130: constructor_uses_global_object: The constructor of global object "SwitchPeelThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SwitchPeelThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|                        cl::init(0));
#  129|   
#  130|-> static cl::opt<unsigned> SwitchPeelThreshold(
#  131|       "switch-peel-threshold", cl::Hidden, cl::init(66),
#  132|       cl::desc("Set the case probability threshold for peeling the case from a "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:1047: var_decl: Declaring variable "OutVec".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:1056: uninit_use: Using uninitialized value "OutVec". Field "OutVec.InlineElts" is uninitialized.
# 1054|         OutVec.push_back(std::make_pair(Regs[I], RegisterSize));
# 1055|     }
# 1056|->   return OutVec;
# 1057|   }
# 1058|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:5036: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), llvm::APInt(32U, Flt, false))".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:5036: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5034|   static SDValue getF32Constant(SelectionDAG &DAG, unsigned Flt,
# 5035|                                 const SDLoc &dl) {
# 5036|->   return DAG.getConstantFP(APFloat(APFloat::IEEEsingle(), APInt(32, Flt)), dl,
# 5037|                              MVT::f32);
# 5038|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:5460: var_decl: Declaring variable "Ten".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:5461: uninit_use_in_call: Using uninitialized value "Ten.U" when calling "isExactlyValue".
# 5459|       if (ConstantFPSDNode *LHSC = dyn_cast<ConstantFPSDNode>(LHS)) {
# 5460|         APFloat Ten(10.0f);
# 5461|->       IsExp10 = LHSC->isExactlyValue(Ten);
# 5462|       }
# 5463|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:10145: var_decl: Declaring variable "MyFlags".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:10161: uninit_use_in_call: Using uninitialized value "MyFlags". Field "MyFlags.OrigArgIndex" is uninitialized when calling "push_back".
#10159|           if (CLI.IsInReg)
#10160|             MyFlags.Flags.setInReg();
#10161|->         CLI.Ins.push_back(MyFlags);
#10162|         }
#10163|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:10171: var_decl: Declaring variable "MyFlags".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:10175: uninit_use_in_call: Using uninitialized value "MyFlags". Field "MyFlags.OrigArgIndex" is uninitialized when calling "push_back".
#10173|           MyFlags.ArgVT = EVT(getPointerTy(DL));
#10174|           MyFlags.Flags.setSwiftError();
#10175|->         CLI.Ins.push_back(MyFlags);
#10176|         }
#10177|       }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp:54: constructor_uses_global_object: The constructor of global object "VerboseDAGDumping" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerboseDAGDumping" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   
#   53|   static cl::opt<bool>
#   54|-> VerboseDAGDumping("dag-dump-verbose", cl::Hidden,
#   55|                     cl::desc("Display more information when dumping selection "
#   56|                              "DAG nodes."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:126: constructor_uses_global_object: The constructor of global object "EnableFastISelAbort" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFastISelAbort" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  124|             "Number of entry blocks where fast isel failed to lower arguments");
#  125|   
#  126|-> static cl::opt<int> EnableFastISelAbort(
#  127|       "fast-isel-abort", cl::Hidden,
#  128|       cl::desc("Enable abort calls when \"fast\" instruction selection "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:134: constructor_uses_global_object: The constructor of global object "EnableFastISelFallbackReport" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFastISelFallbackReport" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  132|                "to SelectionDAG."));
#  133|   
#  134|-> static cl::opt<bool> EnableFastISelFallbackReport(
#  135|       "fast-isel-report-on-fallback", cl::Hidden,
#  136|       cl::desc("Emit a diagnostic when \"fast\" instruction selection "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:140: constructor_uses_global_object: The constructor of global object "UseMBPI" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseMBPI" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|   
#  139|   static cl::opt<bool>
#  140|-> UseMBPI("use-mbpi",
#  141|           cl::desc("use Machine Branch Probability Info"),
#  142|           cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:198: constructor_uses_global_object: The constructor of global object "ISHeuristic" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ISHeuristic" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  196|   static cl::opt<RegisterScheduler::FunctionPassCtor, false,
#  197|                  RegisterPassParser<RegisterScheduler>>
#  198|-> ISHeuristic("pre-RA-sched",
#  199|               cl::init(&createDefaultScheduler), cl::Hidden,
#  200|               cl::desc("Instruction schedulers available (before register"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:65: constructor_uses_global_object: The constructor of global object "UseRegistersForDeoptValues" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseRegistersForDeoptValues" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|             "Maximum number of stack slots required for a singe statepoint");
#   64|   
#   65|-> cl::opt<bool> UseRegistersForDeoptValues(
#   66|       "use-registers-for-deopt-values", cl::Hidden, cl::init(false),
#   67|       cl::desc("Allow using registers for non pointer deopt args"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:69: constructor_uses_global_object: The constructor of global object "UseRegistersForGCPointersInLandingPad" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseRegistersForGCPointersInLandingPad" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|       cl::desc("Allow using registers for non pointer deopt args"));
#   68|   
#   69|-> cl::opt<bool> UseRegistersForGCPointersInLandingPad(
#   70|       "use-registers-for-gc-values-in-landing-pad", cl::Hidden, cl::init(false),
#   71|       cl::desc("Allow using registers for gc pointer in landing pad"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:73: constructor_uses_global_object: The constructor of global object "MaxRegistersForGCPointers" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxRegistersForGCPointers" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|       cl::desc("Allow using registers for gc pointer in landing pad"));
#   72|   
#   73|-> cl::opt<unsigned> MaxRegistersForGCPointers(
#   74|       "max-registers-for-gc-values", cl::Hidden, cl::init(0),
#   75|       cl::desc("Max number of VRegs allowed to pass GC pointer meta args in"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp:7893: var_decl: Declaring variable "APF".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp:7895: uninit_use_in_call: Using uninitialized value "APF.U" when calling "convertFromAPInt".
# 7893|     APFloat APF(APFSem, APInt::getZero(SrcVT.getScalarSizeInBits()));
# 7894|     APInt SignMask = APInt::getSignMask(DstVT.getScalarSizeInBits());
# 7895|->   if (APFloat::opOverflow &
# 7896|         APF.convertFromAPInt(SignMask, false, APFloat::rmNearestTiesToEven)) {
# 7897|       if (Node->isStrictFPOpcode()) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp:10499: var_decl: Declaring variable "MinFloat".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp:10502: uninit_use_in_call: Using uninitialized value "MinFloat.U" when calling "convertFromAPInt".
#10500|     APFloat MaxFloat(DAG.EVTToAPFloatSemantics(SrcVT));
#10501|   
#10502|->   APFloat::opStatus MinStatus =
#10503|         MinFloat.convertFromAPInt(MinInt, IsSigned, APFloat::rmTowardZero);
#10504|     APFloat::opStatus MaxStatus =

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp:10500: var_decl: Declaring variable "MaxFloat".
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/TargetLowering.cpp:10504: uninit_use_in_call: Using uninitialized value "MaxFloat.U" when calling "convertFromAPInt".
#10502|     APFloat::opStatus MinStatus =
#10503|         MinFloat.convertFromAPInt(MinInt, IsSigned, APFloat::rmTowardZero);
#10504|->   APFloat::opStatus MaxStatus =
#10505|         MaxFloat.convertFromAPInt(MaxInt, IsSigned, APFloat::rmTowardZero);
#10506|     bool AreExactFloatBounds = !(MinStatus & APFloat::opStatus::opInexact) &&

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ShrinkWrap.cpp:99: constructor_uses_global_object: The constructor of global object "EnableShrinkWrapOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableShrinkWrapOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   97|   
#   98|   static cl::opt<cl::boolOrDefault>
#   99|-> EnableShrinkWrapOpt("enable-shrink-wrap", cl::Hidden,
#  100|                       cl::desc("enable the shrink-wrapping pass"));
#  101|   static cl::opt<bool> EnablePostShrinkWrapOpt(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/ShrinkWrap.cpp:101: constructor_uses_global_object: The constructor of global object "EnablePostShrinkWrapOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePostShrinkWrapOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   99|   EnableShrinkWrapOpt("enable-shrink-wrap", cl::Hidden,
#  100|                       cl::desc("enable the shrink-wrapping pass"));
#  101|-> static cl::opt<bool> EnablePostShrinkWrapOpt(
#  102|       "enable-shrink-wrap-region-split", cl::init(true), cl::Hidden,
#  103|       cl::desc("enable splitting of the restore block if possible"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackColoring.cpp:67: constructor_uses_global_object: The constructor of global object "DisableColoring" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableColoring" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   
#   66|   static cl::opt<bool>
#   67|-> DisableColoring("no-stack-coloring",
#   68|           cl::init(false), cl::Hidden,
#   69|           cl::desc("Disable stack coloring"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackColoring.cpp:77: constructor_uses_global_object: The constructor of global object "ProtectFromEscapedAllocas" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ProtectFromEscapedAllocas" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|   /// is treated as overriding LifetimeStartOnFirstUse below.
#   76|   static cl::opt<bool>
#   77|-> ProtectFromEscapedAllocas("protect-from-escaped-allocas",
#   78|                             cl::init(false), cl::Hidden,
#   79|                             cl::desc("Do not optimize lifetime zones that "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackColoring.cpp:87: constructor_uses_global_object: The constructor of global object "LifetimeStartOnFirstUse" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LifetimeStartOnFirstUse" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   85|   /// more info.
#   86|   static cl::opt<bool>
#   87|-> LifetimeStartOnFirstUse("stackcoloring-lifetime-start-on-first-use",
#   88|           cl::init(true), cl::Hidden,
#   89|           cl::desc("Treat stack lifetimes as starting on first use, not on START marker."));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:210: var_decl: Declaring variable "SlotDebugMap".
llvm-17.0.6.src/lib/CodeGen/StackFrameLayoutAnalysisPass.cpp:237: uninit_use: Using uninitialized value "SlotDebugMap". Field "SlotDebugMap.NumEntries" is uninitialized.
#  235|       }
#  236|   
#  237|->     return SlotDebugMap;
#  238|     }
#  239|   };

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackMapLivenessAnalysis.cpp:31: constructor_uses_global_object: The constructor of global object "EnablePatchPointLiveness" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePatchPointLiveness" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   #define DEBUG_TYPE "stackmaps"
#   30|   
#   31|-> static cl::opt<bool> EnablePatchPointLiveness(
#   32|       "enable-patchpoint-liveness", cl::Hidden, cl::init(true),
#   33|       cl::desc("Enable PatchPoint Liveness Analysis Pass"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackMaps.cpp:42: constructor_uses_global_object: The constructor of global object "StackMapVersion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackMapVersion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|   #define DEBUG_TYPE "stackmaps"
#   41|   
#   42|-> static cl::opt<int> StackMapVersion(
#   43|       "stackmap-version", cl::init(3), cl::Hidden,
#   44|       cl::desc("Specify the stackmap encoding version (default = 3)"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/CodeGen/StackMaps.cpp:371: var_decl: Declaring variable "LiveOuts".
llvm-17.0.6.src/lib/CodeGen/StackMaps.cpp:403: uninit_use: Using uninitialized value "LiveOuts". Field "LiveOuts.InlineElts" is uninitialized.
#  401|     llvm::erase_if(LiveOuts, [](const LiveOutReg &LO) { return LO.Reg == 0; });
#  402|   
#  403|->   return LiveOuts;
#  404|   }
#  405|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackProtector.cpp:62: constructor_uses_global_object: The constructor of global object "EnableSelectionDAGSP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSelectionDAGSP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|                           " taken.");
#   61|   
#   62|-> static cl::opt<bool> EnableSelectionDAGSP("enable-selectiondag-sp",
#   63|                                             cl::init(true), cl::Hidden);
#   64|   static cl::opt<bool> DisableCheckNoReturn("disable-check-noreturn-call",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackProtector.cpp:64: constructor_uses_global_object: The constructor of global object "DisableCheckNoReturn" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCheckNoReturn" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   62|   static cl::opt<bool> EnableSelectionDAGSP("enable-selectiondag-sp",
#   63|                                             cl::init(true), cl::Hidden);
#   64|-> static cl::opt<bool> DisableCheckNoReturn("disable-check-noreturn-call",
#   65|                                             cl::init(false), cl::Hidden);
#   66|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackSlotColoring.cpp:50: constructor_uses_global_object: The constructor of global object "DisableSharing" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSharing" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|   
#   49|   static cl::opt<bool>
#   50|-> DisableSharing("no-stack-slot-sharing",
#   51|                cl::init(false), cl::Hidden,
#   52|                cl::desc("Suppress slot sharing during stack coloring"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/StackSlotColoring.cpp:54: constructor_uses_global_object: The constructor of global object "DCELimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DCELimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|                cl::desc("Suppress slot sharing during stack coloring"));
#   53|   
#   54|-> static cl::opt<int> DCELimit("ssc-dce-limit", cl::init(-1), cl::Hidden);
#   55|   
#   56|   STATISTIC(NumEliminated, "Number of stack slots eliminated due to coloring");

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TailDuplicator.cpp:60: constructor_uses_global_object: The constructor of global object "TailDuplicateSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDuplicateSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|   
#   59|   // Heuristic for tail duplication.
#   60|-> static cl::opt<unsigned> TailDuplicateSize(
#   61|       "tail-dup-size",
#   62|       cl::desc("Maximum instructions to consider tail duplicating"), cl::init(2),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TailDuplicator.cpp:65: constructor_uses_global_object: The constructor of global object "TailDupIndirectBranchSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupIndirectBranchSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|       cl::Hidden);
#   64|   
#   65|-> static cl::opt<unsigned> TailDupIndirectBranchSize(
#   66|       "tail-dup-indirect-size",
#   67|       cl::desc("Maximum instructions to consider tail duplicating blocks that "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TailDuplicator.cpp:72: constructor_uses_global_object: The constructor of global object "TailDupVerify" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupVerify" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   70|   
#   71|   static cl::opt<bool>
#   72|->     TailDupVerify("tail-dup-verify",
#   73|                     cl::desc("Verify sanity of PHI instructions during taildup"),
#   74|                     cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TailDuplicator.cpp:76: constructor_uses_global_object: The constructor of global object "TailDupLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TailDupLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   74|                     cl::init(false), cl::Hidden);
#   75|   
#   76|-> static cl::opt<unsigned> TailDupLimit("tail-dup-limit", cl::init(~0U),
#   77|                                         cl::Hidden);
#   78|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetInstrInfo.cpp:40: constructor_uses_global_object: The constructor of global object "DisableHazardRecognizer" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableHazardRecognizer" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   using namespace llvm;
#   39|   
#   40|-> static cl::opt<bool> DisableHazardRecognizer(
#   41|     "disable-sched-hazard", cl::Hidden, cl::init(false),
#   42|     cl::desc("Disable hazard detection during preRA scheduling"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringBase.cpp:68: constructor_uses_global_object: The constructor of global object "JumpIsExpensiveOverride" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "JumpIsExpensiveOverride" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|   using namespace llvm;
#   67|   
#   68|-> static cl::opt<bool> JumpIsExpensiveOverride(
#   69|       "jump-is-expensive", cl::init(false),
#   70|       cl::desc("Do not create extra branches to split comparison logic."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringBase.cpp:73: constructor_uses_global_object: The constructor of global object "MinimumJumpTableEntries" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MinimumJumpTableEntries" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|       cl::Hidden);
#   72|   
#   73|-> static cl::opt<unsigned> MinimumJumpTableEntries
#   74|     ("min-jump-table-entries", cl::init(4), cl::Hidden,
#   75|      cl::desc("Set minimum number of entries to use a jump table."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringBase.cpp:77: constructor_uses_global_object: The constructor of global object "MaximumJumpTableSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaximumJumpTableSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|      cl::desc("Set minimum number of entries to use a jump table."));
#   76|   
#   77|-> static cl::opt<unsigned> MaximumJumpTableSize
#   78|     ("max-jump-table-size", cl::init(UINT_MAX), cl::Hidden,
#   79|      cl::desc("Set maximum size of jump tables."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringBase.cpp:83: constructor_uses_global_object: The constructor of global object "JumpTableDensity" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "JumpTableDensity" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   81|   /// Minimum jump table density for normal functions.
#   82|   static cl::opt<unsigned>
#   83|->     JumpTableDensity("jump-table-density", cl::init(10), cl::Hidden,
#   84|                        cl::desc("Minimum density for building a jump table in "
#   85|                                 "a normal function"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringBase.cpp:88: constructor_uses_global_object: The constructor of global object "OptsizeJumpTableDensity" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptsizeJumpTableDensity" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   86|   
#   87|   /// Minimum jump table density for -Os or -Oz functions.
#   88|-> static cl::opt<unsigned> OptsizeJumpTableDensity(
#   89|       "optsize-jump-table-density", cl::init(40), cl::Hidden,
#   90|       cl::desc("Minimum density for building a jump table in "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringBase.cpp:97: constructor_uses_global_object: The constructor of global object "DisableStrictNodeMutation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableStrictNodeMutation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   95|   // during development. When the backend supports strict float operation, this
#   96|   // option will be meaningless.
#   97|-> static cl::opt<bool> DisableStrictNodeMutation("disable-strictnode-mutation",
#   98|          cl::desc("Don't mutate strict-float node to a legalize node"),
#   99|          cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:74: constructor_uses_global_object: The constructor of global object "JumpTableInFunctionSection" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "JumpTableInFunctionSection" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   using namespace dwarf;
#   73|   
#   74|-> static cl::opt<bool> JumpTableInFunctionSection(
#   75|       "jumptable-in-function-section", cl::Hidden, cl::init(false),
#   76|       cl::desc("Putting Jump Table in function section"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:58: constructor_uses_global_object: The constructor of global object "EnableIPRA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableIPRA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|   
#   57|   static cl::opt<bool>
#   58|->     EnableIPRA("enable-ipra", cl::init(false), cl::Hidden,
#   59|                  cl::desc("Enable interprocedural register allocation "
#   60|                           "to reduce load/store at procedure calls."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:61: constructor_uses_global_object: The constructor of global object "DisablePostRASched" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePostRASched" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   59|                  cl::desc("Enable interprocedural register allocation "
#   60|                           "to reduce load/store at procedure calls."));
#   61|-> static cl::opt<bool> DisablePostRASched("disable-post-ra", cl::Hidden,
#   62|       cl::desc("Disable Post Regalloc Scheduler"));
#   63|   static cl::opt<bool> DisableBranchFold("disable-branch-fold", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:63: constructor_uses_global_object: The constructor of global object "DisableBranchFold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBranchFold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   61|   static cl::opt<bool> DisablePostRASched("disable-post-ra", cl::Hidden,
#   62|       cl::desc("Disable Post Regalloc Scheduler"));
#   63|-> static cl::opt<bool> DisableBranchFold("disable-branch-fold", cl::Hidden,
#   64|       cl::desc("Disable branch folding"));
#   65|   static cl::opt<bool> DisableTailDuplicate("disable-tail-duplicate", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:65: constructor_uses_global_object: The constructor of global object "DisableTailDuplicate" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableTailDuplicate" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   static cl::opt<bool> DisableBranchFold("disable-branch-fold", cl::Hidden,
#   64|       cl::desc("Disable branch folding"));
#   65|-> static cl::opt<bool> DisableTailDuplicate("disable-tail-duplicate", cl::Hidden,
#   66|       cl::desc("Disable tail duplication"));
#   67|   static cl::opt<bool> DisableEarlyTailDup("disable-early-taildup", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:67: constructor_uses_global_object: The constructor of global object "DisableEarlyTailDup" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableEarlyTailDup" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   static cl::opt<bool> DisableTailDuplicate("disable-tail-duplicate", cl::Hidden,
#   66|       cl::desc("Disable tail duplication"));
#   67|-> static cl::opt<bool> DisableEarlyTailDup("disable-early-taildup", cl::Hidden,
#   68|       cl::desc("Disable pre-register allocation tail duplication"));
#   69|   static cl::opt<bool> DisableBlockPlacement("disable-block-placement",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:69: constructor_uses_global_object: The constructor of global object "DisableBlockPlacement" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBlockPlacement" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|   static cl::opt<bool> DisableEarlyTailDup("disable-early-taildup", cl::Hidden,
#   68|       cl::desc("Disable pre-register allocation tail duplication"));
#   69|-> static cl::opt<bool> DisableBlockPlacement("disable-block-placement",
#   70|       cl::Hidden, cl::desc("Disable probability-driven block placement"));
#   71|   static cl::opt<bool> EnableBlockPlacementStats("enable-block-placement-stats",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:71: constructor_uses_global_object: The constructor of global object "EnableBlockPlacementStats" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableBlockPlacementStats" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|   static cl::opt<bool> DisableBlockPlacement("disable-block-placement",
#   70|       cl::Hidden, cl::desc("Disable probability-driven block placement"));
#   71|-> static cl::opt<bool> EnableBlockPlacementStats("enable-block-placement-stats",
#   72|       cl::Hidden, cl::desc("Collect probability-driven block placement stats"));
#   73|   static cl::opt<bool> DisableSSC("disable-ssc", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:73: constructor_uses_global_object: The constructor of global object "DisableSSC" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSSC" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   static cl::opt<bool> EnableBlockPlacementStats("enable-block-placement-stats",
#   72|       cl::Hidden, cl::desc("Collect probability-driven block placement stats"));
#   73|-> static cl::opt<bool> DisableSSC("disable-ssc", cl::Hidden,
#   74|       cl::desc("Disable Stack Slot Coloring"));
#   75|   static cl::opt<bool> DisableMachineDCE("disable-machine-dce", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:75: constructor_uses_global_object: The constructor of global object "DisableMachineDCE" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableMachineDCE" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   73|   static cl::opt<bool> DisableSSC("disable-ssc", cl::Hidden,
#   74|       cl::desc("Disable Stack Slot Coloring"));
#   75|-> static cl::opt<bool> DisableMachineDCE("disable-machine-dce", cl::Hidden,
#   76|       cl::desc("Disable Machine Dead Code Elimination"));
#   77|   static cl::opt<bool> DisableEarlyIfConversion("disable-early-ifcvt", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:77: constructor_uses_global_object: The constructor of global object "DisableEarlyIfConversion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableEarlyIfConversion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|   static cl::opt<bool> DisableMachineDCE("disable-machine-dce", cl::Hidden,
#   76|       cl::desc("Disable Machine Dead Code Elimination"));
#   77|-> static cl::opt<bool> DisableEarlyIfConversion("disable-early-ifcvt", cl::Hidden,
#   78|       cl::desc("Disable Early If-conversion"));
#   79|   static cl::opt<bool> DisableMachineLICM("disable-machine-licm", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:79: constructor_uses_global_object: The constructor of global object "DisableMachineLICM" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableMachineLICM" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   static cl::opt<bool> DisableEarlyIfConversion("disable-early-ifcvt", cl::Hidden,
#   78|       cl::desc("Disable Early If-conversion"));
#   79|-> static cl::opt<bool> DisableMachineLICM("disable-machine-licm", cl::Hidden,
#   80|       cl::desc("Disable Machine LICM"));
#   81|   static cl::opt<bool> DisableMachineCSE("disable-machine-cse", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:81: constructor_uses_global_object: The constructor of global object "DisableMachineCSE" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableMachineCSE" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   79|   static cl::opt<bool> DisableMachineLICM("disable-machine-licm", cl::Hidden,
#   80|       cl::desc("Disable Machine LICM"));
#   81|-> static cl::opt<bool> DisableMachineCSE("disable-machine-cse", cl::Hidden,
#   82|       cl::desc("Disable Machine Common Subexpression Elimination"));
#   83|   static cl::opt<cl::boolOrDefault> OptimizeRegAlloc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:83: constructor_uses_global_object: The constructor of global object "OptimizeRegAlloc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptimizeRegAlloc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   81|   static cl::opt<bool> DisableMachineCSE("disable-machine-cse", cl::Hidden,
#   82|       cl::desc("Disable Machine Common Subexpression Elimination"));
#   83|-> static cl::opt<cl::boolOrDefault> OptimizeRegAlloc(
#   84|       "optimize-regalloc", cl::Hidden,
#   85|       cl::desc("Enable optimized register allocation compilation path."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:86: constructor_uses_global_object: The constructor of global object "DisablePostRAMachineLICM" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePostRAMachineLICM" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|       "optimize-regalloc", cl::Hidden,
#   85|       cl::desc("Enable optimized register allocation compilation path."));
#   86|-> static cl::opt<bool> DisablePostRAMachineLICM("disable-postra-machine-licm",
#   87|       cl::Hidden,
#   88|       cl::desc("Disable Machine LICM"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:89: constructor_uses_global_object: The constructor of global object "DisableMachineSink" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableMachineSink" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   87|       cl::Hidden,
#   88|       cl::desc("Disable Machine LICM"));
#   89|-> static cl::opt<bool> DisableMachineSink("disable-machine-sink", cl::Hidden,
#   90|       cl::desc("Disable Machine Sinking"));
#   91|   static cl::opt<bool> DisablePostRAMachineSink("disable-postra-machine-sink",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:91: constructor_uses_global_object: The constructor of global object "DisablePostRAMachineSink" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePostRAMachineSink" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   89|   static cl::opt<bool> DisableMachineSink("disable-machine-sink", cl::Hidden,
#   90|       cl::desc("Disable Machine Sinking"));
#   91|-> static cl::opt<bool> DisablePostRAMachineSink("disable-postra-machine-sink",
#   92|       cl::Hidden,
#   93|       cl::desc("Disable PostRA Machine Sinking"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:94: constructor_uses_global_object: The constructor of global object "DisableLSR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLSR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   92|       cl::Hidden,
#   93|       cl::desc("Disable PostRA Machine Sinking"));
#   94|-> static cl::opt<bool> DisableLSR("disable-lsr", cl::Hidden,
#   95|       cl::desc("Disable Loop Strength Reduction Pass"));
#   96|   static cl::opt<bool> DisableConstantHoisting("disable-constant-hoisting",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:96: constructor_uses_global_object: The constructor of global object "DisableConstantHoisting" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableConstantHoisting" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   94|   static cl::opt<bool> DisableLSR("disable-lsr", cl::Hidden,
#   95|       cl::desc("Disable Loop Strength Reduction Pass"));
#   96|-> static cl::opt<bool> DisableConstantHoisting("disable-constant-hoisting",
#   97|       cl::Hidden, cl::desc("Disable ConstantHoisting"));
#   98|   static cl::opt<bool> DisableCGP("disable-cgp", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:98: constructor_uses_global_object: The constructor of global object "DisableCGP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCGP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   96|   static cl::opt<bool> DisableConstantHoisting("disable-constant-hoisting",
#   97|       cl::Hidden, cl::desc("Disable ConstantHoisting"));
#   98|-> static cl::opt<bool> DisableCGP("disable-cgp", cl::Hidden,
#   99|       cl::desc("Disable Codegen Prepare"));
#  100|   static cl::opt<bool> DisableCopyProp("disable-copyprop", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:100: constructor_uses_global_object: The constructor of global object "DisableCopyProp" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCopyProp" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   98|   static cl::opt<bool> DisableCGP("disable-cgp", cl::Hidden,
#   99|       cl::desc("Disable Codegen Prepare"));
#  100|-> static cl::opt<bool> DisableCopyProp("disable-copyprop", cl::Hidden,
#  101|       cl::desc("Disable Copy Propagation pass"));
#  102|   static cl::opt<bool> DisablePartialLibcallInlining("disable-partial-libcall-inlining",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:102: constructor_uses_global_object: The constructor of global object "DisablePartialLibcallInlining" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePartialLibcallInlining" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  100|   static cl::opt<bool> DisableCopyProp("disable-copyprop", cl::Hidden,
#  101|       cl::desc("Disable Copy Propagation pass"));
#  102|-> static cl::opt<bool> DisablePartialLibcallInlining("disable-partial-libcall-inlining",
#  103|       cl::Hidden, cl::desc("Disable Partial Libcall Inlining"));
#  104|   static cl::opt<bool> DisableAtExitBasedGlobalDtorLowering(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:104: constructor_uses_global_object: The constructor of global object "DisableAtExitBasedGlobalDtorLowering" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableAtExitBasedGlobalDtorLowering" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  102|   static cl::opt<bool> DisablePartialLibcallInlining("disable-partial-libcall-inlining",
#  103|       cl::Hidden, cl::desc("Disable Partial Libcall Inlining"));
#  104|-> static cl::opt<bool> DisableAtExitBasedGlobalDtorLowering(
#  105|       "disable-atexit-based-global-dtor-lowering", cl::Hidden,
#  106|       cl::desc("For MachO, disable atexit()-based global destructor lowering"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:107: constructor_uses_global_object: The constructor of global object "EnableImplicitNullChecks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableImplicitNullChecks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  105|       "disable-atexit-based-global-dtor-lowering", cl::Hidden,
#  106|       cl::desc("For MachO, disable atexit()-based global destructor lowering"));
#  107|-> static cl::opt<bool> EnableImplicitNullChecks(
#  108|       "enable-implicit-null-checks",
#  109|       cl::desc("Fold null checks into faulting memory operations"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:111: constructor_uses_global_object: The constructor of global object "DisableMergeICmps" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableMergeICmps" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  109|       cl::desc("Fold null checks into faulting memory operations"),
#  110|       cl::init(false), cl::Hidden);
#  111|-> static cl::opt<bool> DisableMergeICmps("disable-mergeicmps",
#  112|       cl::desc("Disable MergeICmps Pass"),
#  113|       cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:114: constructor_uses_global_object: The constructor of global object "PrintLSR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintLSR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|       cl::desc("Disable MergeICmps Pass"),
#  113|       cl::init(false), cl::Hidden);
#  114|-> static cl::opt<bool> PrintLSR("print-lsr-output", cl::Hidden,
#  115|       cl::desc("Print LLVM IR produced by the loop-reduce pass"));
#  116|   static cl::opt<bool> PrintISelInput("print-isel-input", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:116: constructor_uses_global_object: The constructor of global object "PrintISelInput" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintISelInput" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  114|   static cl::opt<bool> PrintLSR("print-lsr-output", cl::Hidden,
#  115|       cl::desc("Print LLVM IR produced by the loop-reduce pass"));
#  116|-> static cl::opt<bool> PrintISelInput("print-isel-input", cl::Hidden,
#  117|       cl::desc("Print LLVM IR input to isel pass"));
#  118|   static cl::opt<bool> PrintGCInfo("print-gc", cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:118: constructor_uses_global_object: The constructor of global object "PrintGCInfo" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintGCInfo" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  116|   static cl::opt<bool> PrintISelInput("print-isel-input", cl::Hidden,
#  117|       cl::desc("Print LLVM IR input to isel pass"));
#  118|-> static cl::opt<bool> PrintGCInfo("print-gc", cl::Hidden,
#  119|       cl::desc("Dump garbage collector data"));
#  120|   static cl::opt<cl::boolOrDefault>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:121: constructor_uses_global_object: The constructor of global object "VerifyMachineCode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyMachineCode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  119|       cl::desc("Dump garbage collector data"));
#  120|   static cl::opt<cl::boolOrDefault>
#  121|->     VerifyMachineCode("verify-machineinstrs", cl::Hidden,
#  122|                         cl::desc("Verify generated machine code"));
#  123|   static cl::opt<cl::boolOrDefault>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:124: constructor_uses_global_object: The constructor of global object "DebugifyAndStripAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugifyAndStripAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  122|                         cl::desc("Verify generated machine code"));
#  123|   static cl::opt<cl::boolOrDefault>
#  124|->     DebugifyAndStripAll("debugify-and-strip-all-safe", cl::Hidden,
#  125|                           cl::desc("Debugify MIR before and Strip debug after "
#  126|                                    "each pass except those known to be unsafe "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:128: constructor_uses_global_object: The constructor of global object "DebugifyCheckAndStripAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DebugifyCheckAndStripAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|                                    "each pass except those known to be unsafe "
#  127|                                    "when debug info is present"));
#  128|-> static cl::opt<cl::boolOrDefault> DebugifyCheckAndStripAll(
#  129|       "debugify-check-and-strip-all-safe", cl::Hidden,
#  130|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:135: constructor_uses_global_object: The constructor of global object "EnableMachineOutliner" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMachineOutliner" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|           "present"));
#  134|   // Enable or disable the MachineOutliner.
#  135|-> static cl::opt<RunOutliner> EnableMachineOutliner(
#  136|       "enable-machine-outliner", cl::desc("Enable the machine outliner"),
#  137|       cl::Hidden, cl::ValueOptional, cl::init(RunOutliner::TargetDefault),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:147: constructor_uses_global_object: The constructor of global object "DisableCFIFixup" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCFIFixup" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  145|   // the pipeline is controlled via the target options, this option serves as
#  146|   // manual override.
#  147|-> static cl::opt<bool> DisableCFIFixup("disable-cfi-fixup", cl::Hidden,
#  148|                                        cl::desc("Disable the CFI fixup pass"));
#  149|   // Enable or disable FastISel. Both options are needed, because

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:153: constructor_uses_global_object: The constructor of global object "EnableFastISelOption" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFastISelOption" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  151|   // able to enable or disable fast-isel independently from -O0.
#  152|   static cl::opt<cl::boolOrDefault>
#  153|-> EnableFastISelOption("fast-isel", cl::Hidden,
#  154|     cl::desc("Enable the \"fast\" instruction selector"));
#  155|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:156: constructor_uses_global_object: The constructor of global object "EnableGlobalISelOption" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalISelOption" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  154|     cl::desc("Enable the \"fast\" instruction selector"));
#  155|   
#  156|-> static cl::opt<cl::boolOrDefault> EnableGlobalISelOption(
#  157|       "global-isel", cl::Hidden,
#  158|       cl::desc("Enable the \"global\" instruction selector"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:163: constructor_uses_global_object: The constructor of global object "PrintAfterISel" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintAfterISel" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  161|   //        first...
#  162|   static cl::opt<bool>
#  163|->     PrintAfterISel("print-after-isel", cl::init(false), cl::Hidden,
#  164|                      cl::desc("Print machine instrs after ISel"));
#  165|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:166: constructor_uses_global_object: The constructor of global object "EnableGlobalISelAbort" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalISelAbort" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  164|                      cl::desc("Print machine instrs after ISel"));
#  165|   
#  166|-> static cl::opt<GlobalISelAbortMode> EnableGlobalISelAbort(
#  167|       "global-isel-abort", cl::Hidden,
#  168|       cl::desc("Enable abort calls when \"global\" instruction selection "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:178: constructor_uses_global_object: The constructor of global object "DisableRAFSProfileLoader" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableRAFSProfileLoader" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  176|   // Disable MIRProfileLoader before RegAlloc. This is for for debugging and
#  177|   // tuning purpose.
#  178|-> static cl::opt<bool> DisableRAFSProfileLoader(
#  179|       "disable-ra-fsprofile-loader", cl::init(false), cl::Hidden,
#  180|       cl::desc("Disable MIRProfileLoader before RegAlloc"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:183: constructor_uses_global_object: The constructor of global object "DisableLayoutFSProfileLoader" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLayoutFSProfileLoader" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  181|   // Disable MIRProfileLoader before BloackPlacement. This is for for debugging
#  182|   // and tuning purpose.
#  183|-> static cl::opt<bool> DisableLayoutFSProfileLoader(
#  184|       "disable-layout-fsprofile-loader", cl::init(false), cl::Hidden,
#  185|       cl::desc("Disable MIRProfileLoader before BlockPlacement"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:188: constructor_uses_global_object: The constructor of global object "FSProfileFile[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FSProfileFile[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  186|   // Specify FSProfile file name.
#  187|   static cl::opt<std::string>
#  188|->     FSProfileFile("fs-profile-file", cl::init(""), cl::value_desc("filename"),
#  189|                     cl::desc("Flow Sensitive profile file name."), cl::Hidden);
#  190|   // Specify Remapping file for FSProfile.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:191: constructor_uses_global_object: The constructor of global object "FSRemappingFile[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FSRemappingFile[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  189|                     cl::desc("Flow Sensitive profile file name."), cl::Hidden);
#  190|   // Specify Remapping file for FSProfile.
#  191|-> static cl::opt<std::string> FSRemappingFile(
#  192|       "fs-remapping-file", cl::init(""), cl::value_desc("filename"),
#  193|       cl::desc("Flow Sensitive profile remapping file name."), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:200: constructor_uses_global_object: The constructor of global object "MISchedPostRA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MISchedPostRA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  198|   // Targets can return true in targetSchedulesPostRAScheduling() and
#  199|   // insert a PostRA scheduling pass wherever it wants.
#  200|-> static cl::opt<bool> MISchedPostRA(
#  201|       "misched-postra", cl::Hidden,
#  202|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:206: constructor_uses_global_object: The constructor of global object "EarlyLiveIntervals" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EarlyLiveIntervals" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  204|   
#  205|   // Experimental option to run live interval analysis early.
#  206|-> static cl::opt<bool> EarlyLiveIntervals("early-live-intervals", cl::Hidden,
#  207|       cl::desc("Run live interval analysis earlier in the pipeline"));
#  208|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:218: constructor_uses_global_object: The constructor of global object "StartAfterOpt[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StartAfterOpt[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  216|   
#  217|   static cl::opt<std::string>
#  218|->     StartAfterOpt(StringRef(StartAfterOptName),
#  219|                     cl::desc("Resume compilation after a specific pass"),
#  220|                     cl::value_desc("pass-name"), cl::init(""), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:223: constructor_uses_global_object: The constructor of global object "StartBeforeOpt[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StartBeforeOpt[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  221|   
#  222|   static cl::opt<std::string>
#  223|->     StartBeforeOpt(StringRef(StartBeforeOptName),
#  224|                      cl::desc("Resume compilation before a specific pass"),
#  225|                      cl::value_desc("pass-name"), cl::init(""), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:228: constructor_uses_global_object: The constructor of global object "StopAfterOpt[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StopAfterOpt[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  226|   
#  227|   static cl::opt<std::string>
#  228|->     StopAfterOpt(StringRef(StopAfterOptName),
#  229|                    cl::desc("Stop compilation after a specific pass"),
#  230|                    cl::value_desc("pass-name"), cl::init(""), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:233: constructor_uses_global_object: The constructor of global object "StopBeforeOpt[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StopBeforeOpt[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  231|   
#  232|   static cl::opt<std::string>
#  233|->     StopBeforeOpt(StringRef(StopBeforeOptName),
#  234|                     cl::desc("Stop compilation before a specific pass"),
#  235|                     cl::value_desc("pass-name"), cl::init(""), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:238: constructor_uses_global_object: The constructor of global object "EnableMachineFunctionSplitter" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMachineFunctionSplitter" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  236|   
#  237|   /// Enable the machine function splitter pass.
#  238|-> static cl::opt<bool> EnableMachineFunctionSplitter(
#  239|       "enable-split-machine-functions", cl::Hidden,
#  240|       cl::desc("Split out cold blocks from machine functions based on profile "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:244: constructor_uses_global_object: The constructor of global object "DisableExpandReductions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableExpandReductions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  242|   
#  243|   /// Disable the expand reductions pass for testing.
#  244|-> static cl::opt<bool> DisableExpandReductions(
#  245|       "disable-expand-reductions", cl::init(false), cl::Hidden,
#  246|       cl::desc("Disable the expand reduction intrinsics pass from running"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:249: constructor_uses_global_object: The constructor of global object "DisableSelectOptimize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSelectOptimize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  247|   
#  248|   /// Disable the select optimization pass.
#  249|-> static cl::opt<bool> DisableSelectOptimize(
#  250|       "disable-select-optimize", cl::init(true), cl::Hidden,
#  251|       cl::desc("Disable the select-optimization pass from running"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetPassConfig.cpp:1102: constructor_uses_global_object: The constructor of global object "RegAlloc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RegAlloc" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 1100|   static cl::opt<RegisterRegAlloc::FunctionPassCtor, false,
# 1101|                  RegisterPassParser<RegisterRegAlloc>>
# 1102|->     RegAlloc("regalloc", cl::Hidden, cl::init(&useDefaultRegisterAllocator),
# 1103|                cl::desc("Register allocator to use"));
# 1104|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetRegisterInfo.cpp:48: constructor_uses_global_object: The constructor of global object "HugeSizeForSplit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HugeSizeForSplit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   
#   47|   static cl::opt<unsigned>
#   48|->     HugeSizeForSplit("huge-size-for-split", cl::Hidden,
#   49|                        cl::desc("A threshold of live range size which may cause "
#   50|                                 "high compile time cost in global splitting."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetSchedule.cpp:33: constructor_uses_global_object: The constructor of global object "EnableSchedModel" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSchedModel" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   using namespace llvm;
#   32|   
#   33|-> static cl::opt<bool> EnableSchedModel("schedmodel", cl::Hidden, cl::init(true),
#   34|     cl::desc("Use TargetSchedModel for latency lookup"));
#   35|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TargetSchedule.cpp:36: constructor_uses_global_object: The constructor of global object "EnableSchedItins" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSchedItins" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|     cl::desc("Use TargetSchedModel for latency lookup"));
#   35|   
#   36|-> static cl::opt<bool> EnableSchedItins("scheditins", cl::Hidden, cl::init(true),
#   37|     cl::desc("Use InstrItineraryData for latency lookup"));
#   38|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TwoAddressInstructionPass.cpp:76: constructor_uses_global_object: The constructor of global object "EnableRescheduling" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRescheduling" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   74|   // Temporary flag to disable rescheduling.
#   75|   static cl::opt<bool>
#   76|-> EnableRescheduling("twoaddr-reschedule",
#   77|                      cl::desc("Coalesce copies by rescheduling (default=true)"),
#   78|                      cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TwoAddressInstructionPass.cpp:82: constructor_uses_global_object: The constructor of global object "MaxDataFlowEdge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxDataFlowEdge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   // Limit the number of dataflow edges to traverse when evaluating the benefit
#   81|   // of commuting operands.
#   82|-> static cl::opt<unsigned> MaxDataFlowEdge(
#   83|       "dataflow-edge-limit", cl::Hidden, cl::init(3),
#   84|       cl::desc("Maximum number of dataflow edges to traverse when evaluating "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/TypePromotion.cpp:47: constructor_uses_global_object: The constructor of global object "DisablePromotion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePromotion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   using namespace llvm;
#   46|   
#   47|-> static cl::opt<bool> DisablePromotion("disable-type-promotion", cl::Hidden,
#   48|                                         cl::init(false),
#   49|                                         cl::desc("Disable type promotion pass"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/VLIWMachineScheduler.cpp:44: constructor_uses_global_object: The constructor of global object "IgnoreBBRegPressure" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IgnoreBBRegPressure" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   #define DEBUG_TYPE "machine-scheduler"
#   43|   
#   44|-> static cl::opt<bool> IgnoreBBRegPressure("ignore-bb-reg-pressure", cl::Hidden,
#   45|                                            cl::init(false));
#   46|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/VLIWMachineScheduler.cpp:47: constructor_uses_global_object: The constructor of global object "UseNewerCandidate" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseNewerCandidate" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|                                            cl::init(false));
#   46|   
#   47|-> static cl::opt<bool> UseNewerCandidate("use-newer-candidate", cl::Hidden,
#   48|                                          cl::init(true));
#   49|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/VLIWMachineScheduler.cpp:50: constructor_uses_global_object: The constructor of global object "SchedDebugVerboseLevel" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SchedDebugVerboseLevel" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|                                          cl::init(true));
#   49|   
#   50|-> static cl::opt<unsigned> SchedDebugVerboseLevel("misched-verbose-level",
#   51|                                                   cl::Hidden, cl::init(1));
#   52|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/VLIWMachineScheduler.cpp:55: constructor_uses_global_object: The constructor of global object "CheckEarlyAvail" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CheckEarlyAvail" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   // Check if the scheduler should penalize instructions that are available to
#   54|   // early due to a zero-latency dependence.
#   55|-> static cl::opt<bool> CheckEarlyAvail("check-early-avail", cl::Hidden,
#   56|                                        cl::init(true));
#   57|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/VLIWMachineScheduler.cpp:61: constructor_uses_global_object: The constructor of global object "RPThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RPThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   59|   // We compute the maximum number of registers needed and divided by the total
#   60|   // available. Then, we compare the result to this value.
#   61|-> static cl::opt<float> RPThreshold("vliw-misched-reg-pressure", cl::Hidden,
#   62|                                     cl::init(0.75f),
#   63|                                     cl::desc("High register pressure threhold."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/WinEHPrepare.cpp:43: constructor_uses_global_object: The constructor of global object "DisableDemotion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableDemotion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   #define DEBUG_TYPE "winehprepare"
#   42|   
#   43|-> static cl::opt<bool> DisableDemotion(
#   44|       "disable-demotion", cl::Hidden,
#   45|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/WinEHPrepare.cpp:49: constructor_uses_global_object: The constructor of global object "DisableCleanups" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCleanups" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|       cl::init(false));
#   48|   
#   49|-> static cl::opt<bool> DisableCleanups(
#   50|       "disable-cleanups", cl::Hidden,
#   51|       cl::desc("Do not remove implausible terminators or other similar cleanups"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/CodeGen/WinEHPrepare.cpp:54: constructor_uses_global_object: The constructor of global object "DemoteCatchSwitchPHIOnlyOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DemoteCatchSwitchPHIOnlyOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|       cl::init(false));
#   53|   
#   54|-> static cl::opt<bool> DemoteCatchSwitchPHIOnlyOpt(
#   55|       "demote-catchswitch-only", cl::Hidden,
#   56|       cl::desc("Demote catchswitch BBs only (for wasm EH)"), cl::init(false));

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1219: address_of: Taking address with "&LinkedAddress" yields a singleton pointer.
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1219: identity_transfer: Passing "reinterpret_cast<uint8_t const *>(&LinkedAddress)" as argument 1 to constructor for class "ArrayRef", which sets "AddressBytes.Data" to that argument.
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1222: callee_ptr_arith: Passing "AddressBytes.Data" via argument "AddressBytes" to function "end" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 1220|               reinterpret_cast<const uint8_t *>(&LinkedAddress),
# 1221|               OrigAddressByteSize);
# 1222|->         OutputBuffer.append(AddressBytes.begin(), AddressBytes.end());
# 1223|         } else
# 1224|           Linker.reportWarning("cannot read DW_OP_addrx operand.", File);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1253: address_of: Taking address with "&LinkedAddress" yields a singleton pointer.
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1253: identity_transfer: Passing "reinterpret_cast<uint8_t const *>(&LinkedAddress)" as argument 1 to constructor for class "ArrayRef", which sets "AddressBytes.Data" to that argument.
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1256: callee_ptr_arith: Passing "AddressBytes.Data" via argument "AddressBytes" to function "end" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 1254|                 reinterpret_cast<const uint8_t *>(&LinkedAddress),
# 1255|                 OrigAddressByteSize);
# 1256|->           OutputBuffer.append(AddressBytes.begin(), AddressBytes.end());
# 1257|           }
# 1258|         } else

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1968: var_decl: Declaring variable "LinkedExpression".
llvm-17.0.6.src/lib/DWARFLinker/DWARFLinker.cpp:1982: uninit_use_in_call: Using uninitialized value "LinkedExpression". Field "LinkedExpression.Expr.InlineElts" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1980|                     CurLocAttr.RelocAdjustment);
# 1981|   
# 1982|->       LinkedLocationExpressions.push_back(LinkedExpression);
# 1983|       }
# 1984|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/DWP/DWP.cpp:28: constructor_uses_global_object: The constructor of global object "MCTargetOptionsFlags" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MCTargetOptionsFlags" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   using namespace llvm::object;
#   27|   
#   28|-> static mc::RegisterMCTargetOptionsFlags MCTargetOptionsFlags;
#   29|   
#   30|   // Returns the size of debug_str_offsets section headers in bytes.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1399: var_decl: Declaring variable "Lines".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1402: uninit_use: Using uninitialized value "Lines". Field "Lines.InlineElts" is uninitialized.
# 1400|     DWARFCompileUnit *CU = getCompileUnitForCodeAddress(Address.Address);
# 1401|     if (!CU)
# 1402|->     return Lines;
# 1403|   
# 1404|     uint32_t StartLine = 0;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1399: var_decl: Declaring variable "Lines".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1421: uninit_use: Using uninitialized value "Lines". Field "Lines.InlineElts" is uninitialized.
# 1419|       Result.StartAddress = StartAddress;
# 1420|       Lines.push_back(std::make_pair(Address.Address, Result));
# 1421|->     return Lines;
# 1422|     }
# 1423|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1399: var_decl: Declaring variable "Lines".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1430: uninit_use: Using uninitialized value "Lines". Field "Lines.InlineElts" is uninitialized.
# 1428|     if (!LineTable->lookupAddressRange({Address.Address, Address.SectionIndex},
# 1429|                                        Size, RowVector)) {
# 1430|->     return Lines;
# 1431|     }
# 1432|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1399: var_decl: Declaring variable "Lines".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1448: uninit_use: Using uninitialized value "Lines". Field "Lines.InlineElts" is uninitialized.
# 1446|     }
# 1447|   
# 1448|->   return Lines;
# 1449|   }
# 1450|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1454: var_decl: Declaring variable "InliningInfo".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1458: uninit_use: Using uninitialized value "InliningInfo". Field "InliningInfo.Frames.InlineElts" is uninitialized.
# 1456|     DWARFCompileUnit *CU = getCompileUnitForCodeAddress(Address.Address);
# 1457|     if (!CU)
# 1458|->     return InliningInfo;
# 1459|   
# 1460|     const DWARFLineTable *LineTable = nullptr;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1454: var_decl: Declaring variable "InliningInfo".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFContext.cpp:1474: uninit_use: Using uninitialized value "InliningInfo". Field "InliningInfo.Frames.InlineElts" is uninitialized.
# 1472|           InliningInfo.addFrame(Frame);
# 1473|       }
# 1474|->     return InliningInfo;
# 1475|     }
# 1476|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:213: var_decl: Declaring variable "FileEntry".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:227: uninit_use_in_call: Using uninitialized value "FileEntry". Field "FileEntry.Checksum" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  225|             "the end of the prologue");
#  226|       }
#  227|->     FileNames.push_back(FileEntry);
#  228|     }
#  229|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:311: var_decl: Declaring variable "FileEntry".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:346: uninit_use_in_call: Using uninitialized value "FileEntry". Field "FileEntry.Checksum" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  344|         }
#  345|       }
#  346|->     FileNames.push_back(FileEntry);
#  347|     }
#  348|     return Error::success();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:976: var_decl: Declaring variable "FileEntry".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFDebugLine.cpp:983: uninit_use_in_call: Using uninitialized value "FileEntry". Field "FileEntry.Checksum" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  981|             FileEntry.ModTime = TableData.getULEB128(Cursor);
#  982|             FileEntry.Length = TableData.getULEB128(Cursor);
#  983|->           Prologue.FileNames.push_back(FileEntry);
#  984|             if (Cursor && Verbose)
#  985|               *OS << " (" << Name << ", dir=" << FileEntry.DirIdx << ", mod_time="

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFFormValue.cpp:96: var_decl: Declaring variable "V".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFFormValue.cpp:99: uninit_use_in_call: Using uninitialized value "V". Field "V.SectionIndex" is uninitialized when calling "DWARFFormValue".
#   97|     V.uval = D.size();
#   98|     V.data = D.data();
#   99|->   return DWARFFormValue(F, V);
#  100|   }
#  101|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFUnit.cpp:799: var_decl: Declaring variable "LocationAddr" without initializer.
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFUnit.cpp:823: uninit_use: Using uninitialized value "LocationAddr".
#  821|       }
#  822|   
#  823|->     Address = LocationAddr;
#  824|       break;
#  825|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFVerifier.cpp:1356: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/DebugInfo/DWARF/DWARFVerifier.cpp:1367: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1365|     }
# 1366|   
# 1367|->   return Result;
# 1368|   }
# 1369|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/GSYM/GsymCreator.cpp:482: var_decl: Declaring variable "DstFI".
llvm-17.0.6.src/lib/DebugInfo/GSYM/GsymCreator.cpp:506: uninit_use_in_call: Using uninitialized value "DstFI". Field "DstFI.EncodingCache.InlineElts" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  504|     }
#  505|     std::lock_guard<std::mutex> Guard(Mutex);
#  506|->   Funcs.push_back(DstFI);
#  507|     return Funcs.back().cacheEncoding();
#  508|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/LogicalView/Core/LVSupport.cpp:75: var_decl: Declaring variable "Indexes".
llvm-17.0.6.src/lib/DebugInfo/LogicalView/Core/LVSupport.cpp:117: uninit_use: Using uninitialized value "Indexes". Field "Indexes.InlineElts" is uninitialized.
#  115|     Indexes.push_back(LexicalEntry(Current, Length - 1));
#  116|     LLVM_DEBUG({ PrintLexicalEntry(); });
#  117|->   return Indexes;
#  118|   }
#  119|   

Error: Y2K38_SAFETY (CWE-197):
llvm-17.0.6.src/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp:360: store_truncates_time_t: A "time_t" value is stored in an integer with too few bits to accommodate it.  The expression "Sig.operator bool() ? *Sig : time(NULL)" is cast to "llvm::support::detail::packed_endian_specific_integral<unsigned int, (llvm::support::endianness)1, 1ul, 1ul>::value_type".
#  358|       H->Guid = Info->getGuid();
#  359|       std::optional<uint32_t> Sig = Info->getSignature();
#  360|->     H->Signature = Sig ? *Sig : time(nullptr);
#  361|     }
#  362|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/PDB/PDBContext.cpp:81: var_decl: Declaring variable "Table".
llvm-17.0.6.src/lib/DebugInfo/PDB/PDBContext.cpp:84: uninit_use: Using uninitialized value "Table". Field "Table.InlineElts" is uninitialized.
#   82|     auto LineNumbers = Session->findLineNumbersByAddress(Address.Address, Size);
#   83|     if (!LineNumbers || LineNumbers->getChildCount() == 0)
#   84|->     return Table;
#   85|   
#   86|     while (auto LineInfo = LineNumbers->getNext()) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/PDB/PDBContext.cpp:81: var_decl: Declaring variable "Table".
llvm-17.0.6.src/lib/DebugInfo/PDB/PDBContext.cpp:91: uninit_use: Using uninitialized value "Table". Field "Table.InlineElts" is uninitialized.
#   89|       Table.push_back(std::make_pair(LineInfo->getVirtualAddress(), LineEntry));
#   90|     }
#   91|->   return Table;
#   92|   }
#   93|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/DebugInfo/Symbolize/Markup.cpp:146: var_decl: Declaring variable "Node".
llvm-17.0.6.src/lib/DebugInfo/Symbolize/Markup.cpp:148: uninit_use: Using uninitialized value "Node". Field "Node.Fields.InlineElts" is uninitialized.
#  146|     MarkupNode Node;
#  147|     Node.Text = Text;
#  148|->   return Node;
#  149|   }
#  150|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/DebugInfo/Symbolize/Symbolize.cpp:700: alloc_fn: Storage is returned from allocation function "microsoftDemangle".
llvm-17.0.6.src/lib/DebugInfo/Symbolize/Symbolize.cpp:700: var_assign: Assigning: "DemangledName" = storage returned from "llvm::microsoftDemangle(Name->operator std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__sv_type(), NULL, &status, (llvm::MSDemangleFlags)30)".
llvm-17.0.6.src/lib/DebugInfo/Symbolize/Symbolize.cpp:705: leaked_storage: Variable "DemangledName" going out of scope leaks the storage it points to.
#  703|                           MSDF_NoMemberType | MSDF_NoReturnType));
#  704|       if (status != 0)
#  705|->       return Name;
#  706|       Result = DemangledName;
#  707|       free(DemangledName);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Debuginfod/Debuginfod.cpp:67: var_decl: Declaring variable "DebuginfodUrls".
llvm-17.0.6.src/lib/Debuginfod/Debuginfod.cpp:69: uninit_use: Using uninitialized value "DebuginfodUrls". Field "DebuginfodUrls.InlineElts" is uninitialized.
#   67|     SmallVector<StringRef> DebuginfodUrls;
#   68|     StringRef(DebuginfodUrlsEnv).split(DebuginfodUrls, " ");
#   69|->   return DebuginfodUrls;
#   70|   }
#   71|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Demangle/MicrosoftDemangle.cpp:1022: var_decl: Declaring variable "OuterContext".
llvm-17.0.6.src/lib/Demangle/MicrosoftDemangle.cpp:1023: uninit_use_in_call: Using uninitialized value "OuterContext". Field "OuterContext.FunctionParams" is uninitialized when calling "swap".
# 1021|   
# 1022|     BackrefContext OuterContext;
# 1023|->   std::swap(OuterContext, Backrefs);
# 1024|   
# 1025|     IdentifierNode *Identifier =

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:144: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:144: leaked_storage: Ignoring storage allocated by "I->release()" leaks it.
#  142|       Module *Found = I->get();
#  143|       if (Found == M) {
#  144|->       I->release();
#  145|         Modules.erase(I);
#  146|         clearGlobalMappingsFromModule(M);

Error: OVERLAPPING_COPY:
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:671: equal: The address of "GV.FloatVal" is equal to the address of "GV".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:671: equal: The address of "GV.DoubleVal" is equal to the address of "GV".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:671: overlapping_assignment: Assigning "GV.DoubleVal" to "GV.FloatVal", which have overlapping memory locations and different types.
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:671: target_type: "GV.FloatVal" has type "float".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:671: source_type: "GV.DoubleVal" has type "double".
#  669|         // FIXME long double
#  670|         GenericValue GV = getConstantValue(Op0);
#  671|->       GV.FloatVal = float(GV.DoubleVal);
#  672|         return GV;
#  673|       }

Error: OVERLAPPING_COPY:
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:677: equal: The address of "GV.DoubleVal" is equal to the address of "GV".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:677: equal: The address of "GV.FloatVal" is equal to the address of "GV".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:677: overlapping_assignment: Assigning "GV.FloatVal" to "GV.DoubleVal", which have overlapping memory locations and different types.
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:677: target_type: "GV.DoubleVal" has type "double".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:677: source_type: "GV.FloatVal" has type "float".
#  675|         // FIXME long double
#  676|         GenericValue GV = getConstantValue(Op0);
#  677|->       GV.DoubleVal = double(GV.FloatVal);
#  678|         return GV;
#  679|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:719: var_decl: Declaring variable "apf".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:722: uninit_use_in_call: Using uninitialized value "apf.U" when calling "convertToInteger".
#  720|           uint64_t v;
#  721|           bool ignored;
#  722|->         (void)apf.convertToInteger(MutableArrayRef(v), BitWidth,
#  723|                                      CE->getOpcode()==Instruction::FPToSI,
#  724|                                      APFloat::rmTowardZero, &ignored);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:843: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, RHS.IntVal)".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:843: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  841|             default: llvm_unreachable("Invalid long double opcode");
#  842|             case Instruction::FAdd:
#  843|->             apfLHS.add(APFloat(Sem, RHS.IntVal), APFloat::rmNearestTiesToEven);
#  844|               GV.IntVal = apfLHS.bitcastToAPInt();
#  845|               break;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:839: var_decl: Declaring variable "apfLHS".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:843: uninit_use_in_call: Using uninitialized value "apfLHS.U" when calling "add".
#  841|             default: llvm_unreachable("Invalid long double opcode");
#  842|             case Instruction::FAdd:
#  843|->             apfLHS.add(APFloat(Sem, RHS.IntVal), APFloat::rmNearestTiesToEven);
#  844|               GV.IntVal = apfLHS.bitcastToAPInt();
#  845|               break;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:847: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, RHS.IntVal)".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:847: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  845|               break;
#  846|             case Instruction::FSub:
#  847|->             apfLHS.subtract(APFloat(Sem, RHS.IntVal),
#  848|                               APFloat::rmNearestTiesToEven);
#  849|               GV.IntVal = apfLHS.bitcastToAPInt();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:839: var_decl: Declaring variable "apfLHS".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:847: uninit_use_in_call: Using uninitialized value "apfLHS.U" when calling "subtract".
#  845|               break;
#  846|             case Instruction::FSub:
#  847|->             apfLHS.subtract(APFloat(Sem, RHS.IntVal),
#  848|                               APFloat::rmNearestTiesToEven);
#  849|               GV.IntVal = apfLHS.bitcastToAPInt();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:852: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, RHS.IntVal)".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:852: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  850|               break;
#  851|             case Instruction::FMul:
#  852|->             apfLHS.multiply(APFloat(Sem, RHS.IntVal),
#  853|                               APFloat::rmNearestTiesToEven);
#  854|               GV.IntVal = apfLHS.bitcastToAPInt();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:839: var_decl: Declaring variable "apfLHS".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:852: uninit_use_in_call: Using uninitialized value "apfLHS.U" when calling "multiply".
#  850|               break;
#  851|             case Instruction::FMul:
#  852|->             apfLHS.multiply(APFloat(Sem, RHS.IntVal),
#  853|                               APFloat::rmNearestTiesToEven);
#  854|               GV.IntVal = apfLHS.bitcastToAPInt();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:857: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, RHS.IntVal)".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:857: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  855|               break;
#  856|             case Instruction::FDiv:
#  857|->             apfLHS.divide(APFloat(Sem, RHS.IntVal),
#  858|                             APFloat::rmNearestTiesToEven);
#  859|               GV.IntVal = apfLHS.bitcastToAPInt();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:839: var_decl: Declaring variable "apfLHS".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:857: uninit_use_in_call: Using uninitialized value "apfLHS.U" when calling "divide".
#  855|               break;
#  856|             case Instruction::FDiv:
#  857|->             apfLHS.divide(APFloat(Sem, RHS.IntVal),
#  858|                             APFloat::rmNearestTiesToEven);
#  859|               GV.IntVal = apfLHS.bitcastToAPInt();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:862: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, RHS.IntVal)".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:862: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  860|               break;
#  861|             case Instruction::FRem:
#  862|->             apfLHS.mod(APFloat(Sem, RHS.IntVal));
#  863|               GV.IntVal = apfLHS.bitcastToAPInt();
#  864|               break;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:839: var_decl: Declaring variable "apfLHS".
llvm-17.0.6.src/lib/ExecutionEngine/ExecutionEngine.cpp:862: uninit_use_in_call: Using uninitialized value "apfLHS.U" when calling "mod".
#  860|               break;
#  861|             case Instruction::FRem:
#  862|->             apfLHS.mod(APFloat(Sem, RHS.IntVal));
#  863|               GV.IntVal = apfLHS.bitcastToAPInt();
#  864|               break;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/Execution.cpp:34: constructor_uses_global_object: The constructor of global object "PrintVolatile" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintVolatile" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   STATISTIC(NumDynamicInsts, "Number of dynamic instructions executed");
#   33|   
#   34|-> static cl::opt<bool> PrintVolatile("interpreter-print-volatile", cl::Hidden,
#   35|             cl::desc("make the interpreter print every volatile load and store"));
#   36|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:274: var_decl: Declaring variable "Guard".
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:282: uninit_use_in_call: Using uninitialized value "Guard._M_device" when calling "unlock".
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:282: uninit_use_in_call: Using uninitialized value "Guard._M_owns" when calling "unlock".
#  280|     if (ExFunc Fn = (FI == Fns.ExportedFunctions.end()) ? lookupFunction(F)
#  281|                                                         : FI->second) {
#  282|->     Guard.unlock();
#  283|       return Fn(F->getFunctionType(), ArgVals);
#  284|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:274: var_decl: Declaring variable "Guard".
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:300: uninit_use_in_call: Using uninitialized value "Guard._M_device" when calling "unlock".
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:300: uninit_use_in_call: Using uninitialized value "Guard._M_owns" when calling "unlock".
#  298|     }
#  299|   
#  300|->   Guard.unlock();
#  301|   
#  302|     GenericValue Result;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:509: identity_transfer: Passing "18446744073709551615UL" as argument 1 to member function "getLimitedValue", which returns that argument.
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:509: overrun-buffer-arg: Calling "memcpy" with "llvm::GVTOP(Args[0UL])" and "(size_t)Args[2UL].IntVal.getLimitedValue(18446744073709551615UL)" is suspicious because of the very large index, 18446744073709551615. The index may be due to a negative parameter being interpreted as unsigned.
#  507|   static GenericValue lle_X_memcpy(FunctionType *FT,
#  508|                                    ArrayRef<GenericValue> Args) {
#  509|->   memcpy(GVTOP(Args[0]), GVTOP(Args[1]),
#  510|            (size_t)(Args[2].IntVal.getLimitedValue()));
#  511|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:509: identity_transfer: Passing "18446744073709551615UL" as argument 1 to member function "getLimitedValue", which returns that argument.
llvm-17.0.6.src/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:509: overrun-buffer-arg: Calling "memcpy" with "llvm::GVTOP(Args[1UL])" and "(size_t)Args[2UL].IntVal.getLimitedValue(18446744073709551615UL)" is suspicious because of the very large index, 18446744073709551615. The index may be due to a negative parameter being interpreted as unsigned.
#  507|   static GenericValue lle_X_memcpy(FunctionType *FT,
#  508|                                    ArrayRef<GenericValue> Args) {
#  509|->   memcpy(GVTOP(Args[0]), GVTOP(Args[1]),
#  510|            (size_t)(Args[2].IntVal.getLimitedValue()));
#  511|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Core.cpp:2511: extract: Calling "back" which extracts wrapped state from "IPLS->CurDefGeneratorStack".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Core.cpp:2511: identity_transfer: Member function call "IPLS->CurDefGeneratorStack.back()->lock()" returns "IPLS->CurDefGeneratorStack.back()" ("this").
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Core.cpp:2511: assign: Assigning: "DG" = "IPLS->CurDefGeneratorStack.back()->lock()".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Core.cpp:2512: invalidate: Calling "pop_back" invalidates the internal representation of "IPLS->CurDefGeneratorStack".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Core.cpp:2514: use_after_free: Using invalidated internal representation of "IPLS->CurDefGeneratorStack".
# 2512|         IPLS->CurDefGeneratorStack.pop_back();
# 2513|   
# 2514|->       if (!DG)
# 2515|           return IPLS->fail(make_error<StringError>(
# 2516|               "DefinitionGenerator removed while lookup in progress",

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:521: var_decl: Declaring variable "Lock".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:529: uninit_use_in_call: Using uninitialized value "Lock._M_device" when calling "unlock".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:529: uninit_use_in_call: Using uninitialized value "Lock._M_owns" when calling "unlock".
#  527|         // If there's no init sequence entry yet then we need to look up the
#  528|         // header symbol to force creation of one.
#  529|->       Lock.unlock();
#  530|   
#  531|         auto SearchOrder =
llvm-17.0.6.src/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:529: note: trimmed 1 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:86: var_decl: Declaring variable "Lock".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:93: uninit_use_in_call: Using uninitialized value "Lock._M_device" when calling "unlock".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/IndirectionUtils.cpp:93: uninit_use_in_call: Using uninitialized value "Lock._M_owns" when calling "unlock".
#   91|       // callee.
#   92|       if (I == AddrToSymbol.end()) {
#   93|->       Lock.unlock();
#   94|         ES.reportError(
#   95|             make_error<StringError>("No compile callback for trampoline at " +

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/OrcV2CBindings.cpp:662: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/ExecutionEngine/Orc/OrcV2CBindings.cpp:662: leaked_storage: Ignoring storage allocated by "TmpMU.release()" leaks it.
#  660|   
#  661|     if (auto Err = unwrap(JD)->define(TmpMU)) {
#  662|->     TmpMU.release();
#  663|       return wrap(std::move(Err));
#  664|     }

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:142: tainted_data_argument: The check "Completed < static_cast<ssize_t>(Size)" contains the tainted expression "Completed" which causes "Size" to be considered tainted.
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:143: overflow: The expression "Size - Completed" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:143: overflow_sink: "Size - Completed", which might have underflowed, is passed to "read(this->InFD, Dst + Completed, Size - Completed)".
#  141|     ssize_t Completed = 0;
#  142|     while (Completed < static_cast<ssize_t>(Size)) {
#  143|->     ssize_t Read = ::read(InFD, Dst + Completed, Size - Completed);
#  144|       if (Read <= 0) {
#  145|         auto ErrNo = errno;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:172: tainted_data_argument: The check "Completed < static_cast<ssize_t>(Size)" contains the tainted expression "Completed" which causes "Size" to be considered tainted.
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:173: overflow: The expression "Size - Completed" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.cpp:173: overflow_sink: "Size - Completed", which might have underflowed, is passed to "write(this->OutFD, Src + Completed, Size - Completed)".
#  171|     ssize_t Completed = 0;
#  172|     while (Completed < static_cast<ssize_t>(Size)) {
#  173|->     ssize_t Written = ::write(OutFD, Src + Completed, Size - Completed);
#  174|       if (Written < 0) {
#  175|         auto ErrNo = errno;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:28: var_decl: Declaring variable "BBs".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:41: uninit_use: Using uninitialized value "BBs". Field "BBs.InlineElts" is uninitialized.
#   39|         BBs.emplace_back(&BB);
#   40|   
#   41|->   return BBs;
#   42|   }
#   43|   } // namespace

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:137: var_decl: Declaring variable "RearrangedBBSet".
llvm-17.0.6.src/lib/ExecutionEngine/Orc/SpeculateAnalyses.cpp:145: uninit_use: Using uninitialized value "RearrangedBBSet". Field "RearrangedBBSet.InlineElts" is uninitialized.
#  143|     assert(RearrangedBBSet.size() == BBList.size() &&
#  144|            "BasicBlock missing while rearranging?");
#  145|->   return RearrangedBBSet;
#  146|   }
#  147|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:1470: move: "O" is moved (indicated by "std::move(O)").
llvm-17.0.6.src/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:1472: use_after_move: "O" is used after it has been already moved.
# 1470|       OnEmitted(std::move(O), std::move(Info), std::move(Err));
# 1471|   
# 1472|->   RuntimeDyldImpl::finalizeAsync(std::move(RTDyld.Dyld), std::move(OnEmitted),
# 1473|                                    std::move(O), std::move(Info));
# 1474|   }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Frontend/OpenMP/OMPIRBuilder.cpp:55: constructor_uses_global_object: The constructor of global object "OptimisticAttributes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptimisticAttributes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   
#   54|   static cl::opt<bool>
#   55|->     OptimisticAttributes("openmp-ir-builder-optimistic-attributes", cl::Hidden,
#   56|                            cl::desc("Use optimistic attributes describing "
#   57|                                     "'as-if' properties of runtime calls."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Frontend/OpenMP/OMPIRBuilder.cpp:60: constructor_uses_global_object: The constructor of global object "UnrollThresholdFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnrollThresholdFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|                            cl::init(false));
#   59|   
#   60|-> static cl::opt<double> UnrollThresholdFactor(
#   61|       "openmp-ir-builder-unroll-threshold-factor", cl::Hidden,
#   62|       cl::desc("Factor for the unroll threshold to account for code "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Frontend/OpenMP/OMPIRBuilder.cpp:933: var_decl: Declaring variable "Return" without initializer.
llvm-17.0.6.src/lib/Frontend/OpenMP/OMPIRBuilder.cpp:960: uninit_use_in_call: Using uninitialized value "Return" when calling "CreateIsNotNull".
#  958|     BasicBlock *OffloadContBlock =
#  959|         BasicBlock::Create(Builder.getContext(), "omp_offload.cont");
#  960|->   Value *Failed = Builder.CreateIsNotNull(Return);
#  961|     Builder.CreateCondBr(Failed, OffloadFailedBlock, OffloadContBlock);
#  962|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/FuzzMutate/OpDescriptor.cpp:30: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, 1UL)".
llvm-17.0.6.src/lib/FuzzMutate/OpDescriptor.cpp:30: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#   28|       auto &Sem = T->getFltSemantics();
#   29|       Cs.push_back(ConstantFP::get(Ctx, APFloat::getZero(Sem)));
#   30|->     Cs.push_back(ConstantFP::get(Ctx, APFloat(Sem, 1)));
#   31|       Cs.push_back(ConstantFP::get(Ctx, APFloat(Sem, 42)));
#   32|       Cs.push_back(ConstantFP::get(Ctx, APFloat::getLargest(Sem)));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/FuzzMutate/OpDescriptor.cpp:31: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, 42UL)".
llvm-17.0.6.src/lib/FuzzMutate/OpDescriptor.cpp:31: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#   29|       Cs.push_back(ConstantFP::get(Ctx, APFloat::getZero(Sem)));
#   30|       Cs.push_back(ConstantFP::get(Ctx, APFloat(Sem, 1)));
#   31|->     Cs.push_back(ConstantFP::get(Ctx, APFloat(Sem, 42)));
#   32|       Cs.push_back(ConstantFP::get(Ctx, APFloat::getLargest(Sem)));
#   33|       Cs.push_back(ConstantFP::get(Ctx, APFloat::getSmallest(Sem)));

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/lib/IR/AsmWriter.cpp:2512: extract: Calling "get" which extracts wrapped state from local "MachineStorage".
llvm-17.0.6.src/lib/IR/AsmWriter.cpp:2512: escape: The internal representation of local "MachineStorage" escapes into "WriterCtx.Machine", but is destroyed when it exits scope.
# 2510|       if (!WriterCtx.Machine) {
# 2511|         MachineStorage = std::make_unique<SlotTracker>(WriterCtx.Context);
# 2512|->       WriterCtx.Machine = MachineStorage.get();
# 2513|       }
# 2514|       int Slot = WriterCtx.Machine->getMetadataSlot(N);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/AutoUpgrade.cpp:49: constructor_uses_global_object: The constructor of global object "DisableAutoUpgradeDebugInfo" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableAutoUpgradeDebugInfo" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|   
#   48|   static cl::opt<bool>
#   49|->     DisableAutoUpgradeDebugInfo("disable-auto-upgrade-debug-info",
#   50|                                   cl::desc("Disable autoupgrade of debug info"));
#   51|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/IR/ConstantFold.cpp:151: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(DestTy->getFltSemantics(), CI->getValue())".
llvm-17.0.6.src/lib/IR/ConstantFold.cpp:151: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  149|       // See note below regarding the PPC_FP128 restriction.
#  150|       if (DestTy->isFloatingPointTy() && !DestTy->isPPC_FP128Ty())
#  151|->       return ConstantFP::get(DestTy->getContext(),
#  152|                                APFloat(DestTy->getFltSemantics(),
#  153|                                        CI->getValue()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/IR/DataLayout.cpp:1000: var_decl: Declaring variable "Indices".
llvm-17.0.6.src/lib/IR/DataLayout.cpp:1009: uninit_use: Using uninitialized value "Indices". Field "Indices.InlineElts" is uninitialized.
# 1007|     }
# 1008|   
# 1009|->   return Indices;
# 1010|   }
# 1011|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/DebugInfoMetadata.cpp:32: constructor_uses_global_object: The constructor of global object "llvm::EnableFSDiscriminator" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::EnableFSDiscriminator" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   namespace llvm {
#   31|   // Use FS-AFDO discriminator.
#   32|-> cl::opt<bool> EnableFSDiscriminator(
#   33|       "enable-fs-discriminator", cl::Hidden,
#   34|       cl::desc("Enable adding flow sensitive discriminators"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/DiagnosticHandler.cpp:46: constructor_uses_global_object: The constructor of global object "<unnamed>::PassRemarks[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::PassRemarks[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   // -pass-remarks
#   45|   //    Command line flag to enable emitOptimizationRemark()
#   46|-> static cl::opt<PassRemarksOpt, true, cl::parser<std::string>> PassRemarks(
#   47|       "pass-remarks", cl::value_desc("pattern"),
#   48|       cl::desc("Enable optimization remarks from passes whose name match "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/DiagnosticHandler.cpp:54: constructor_uses_global_object: The constructor of global object "<unnamed>::PassRemarksMissed[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::PassRemarksMissed[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   // -pass-remarks-missed
#   53|   //    Command line flag to enable emitOptimizationRemarkMissed()
#   54|-> static cl::opt<PassRemarksOpt, true, cl::parser<std::string>> PassRemarksMissed(
#   55|       "pass-remarks-missed", cl::value_desc("pattern"),
#   56|       cl::desc("Enable missed optimization remarks from passes whose name match "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/DiagnosticHandler.cpp:63: constructor_uses_global_object: The constructor of global object "<unnamed>::PassRemarksAnalysis[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::PassRemarksAnalysis[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   61|   //    Command line flag to enable emitOptimizationRemarkAnalysis()
#   62|   static cl::opt<PassRemarksOpt, true, cl::parser<std::string>>
#   63|->     PassRemarksAnalysis(
#   64|           "pass-remarks-analysis", cl::value_desc("pattern"),
#   65|           cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/Dominators.cpp:41: constructor_uses_global_object: The constructor of global object "VerifyDomInfoX" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyDomInfoX" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   bool llvm::VerifyDomInfo = false;
#   40|   static cl::opt<bool, true>
#   41|->     VerifyDomInfoX("verify-dom-info", cl::location(VerifyDomInfo), cl::Hidden,
#   42|                      cl::desc("Verify dominator info (time consuming)"));
#   43|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/Function.cpp:79: constructor_uses_global_object: The constructor of global object "NonGlobalValueMaxNameSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NonGlobalValueMaxNameSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   template class llvm::SymbolTableListTraits<BasicBlock>;
#   78|   
#   79|-> static cl::opt<unsigned> NonGlobalValueMaxNameSize(
#   80|       "non-global-value-max-name-size", cl::Hidden, cl::init(1024),
#   81|       cl::desc("Maximum size for the name of non-global values."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/Instructions.cpp:51: constructor_uses_global_object: The constructor of global object "DisableI2pP2iOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableI2pP2iOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|   using namespace llvm;
#   50|   
#   51|-> static cl::opt<bool> DisableI2pP2iOpt(
#   52|       "disable-i2p-p2i-opt", cl::init(false),
#   53|       cl::desc("Disables inttoptr/ptrtoint roundtrip optimization"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/IR/LLVMRemarkStreamer.cpp:62: var_decl: Declaring variable "R".
llvm-17.0.6.src/lib/IR/LLVMRemarkStreamer.cpp:78: uninit_use: Using uninitialized value "R". Field "R.Args.InlineElts" is uninitialized.
#   76|     }
#   77|   
#   78|->   return R;
#   79|   }
#   80|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/LegacyPassManager.cpp:50: constructor_uses_global_object: The constructor of global object "PassDebugging" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PassDebugging" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|   } // namespace
#   49|   
#   50|-> static cl::opt<enum PassDebugLevel> PassDebugging(
#   51|       "debug-pass", cl::Hidden,
#   52|       cl::desc("Print legacy PassManager debugging information"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/IR/Metadata.cpp:207: var_decl: Declaring variable "MDUsers".
llvm-17.0.6.src/lib/IR/Metadata.cpp:210: uninit_use: Using uninitialized value "MDUsers". Field "MDUsers.InlineElts" is uninitialized.
#  208|     for (auto *UserWithID : MDUsersWithID)
#  209|       MDUsers.push_back(cast<Metadata *>(UserWithID->first));
#  210|->   return MDUsers;
#  211|   }
#  212|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/ModuleSummaryIndex.cpp:29: constructor_uses_global_object: The constructor of global object "PropagateAttrs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PropagateAttrs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|             "Number of live global variables marked write only");
#   28|   
#   29|-> static cl::opt<bool> PropagateAttrs("propagate-attrs", cl::init(true),
#   30|                                       cl::Hidden,
#   31|                                       cl::desc("Propagate attributes in index"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/ModuleSummaryIndex.cpp:33: constructor_uses_global_object: The constructor of global object "ImportConstantsWithRefs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ImportConstantsWithRefs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|                                       cl::desc("Propagate attributes in index"));
#   32|   
#   33|-> static cl::opt<bool> ImportConstantsWithRefs(
#   34|       "import-constants-with-refs", cl::init(true), cl::Hidden,
#   35|       cl::desc("Import constant global variables with references"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/OptBisect.cpp:28: constructor_uses_global_object: The constructor of global object "OptBisectLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptBisectLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   }
#   27|   
#   28|-> static cl::opt<int> OptBisectLimit("opt-bisect-limit", cl::Hidden,
#   29|                                      cl::init(OptBisect::Disabled), cl::Optional,
#   30|                                      cl::cb<void, int>([](int Limit) {

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PassTimingInfo.cpp:40: constructor_uses_global_object: The constructor of global object "llvm::EnableTiming" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::EnableTiming" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   bool TimePassesPerRun = false;
#   39|   
#   40|-> static cl::opt<bool, true> EnableTiming(
#   41|       "time-passes", cl::location(TimePassesIsEnabled), cl::Hidden,
#   42|       cl::desc("Time each pass, printing elapsed time for each on exit"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PassTimingInfo.cpp:44: constructor_uses_global_object: The constructor of global object "llvm::EnableTimingPerRun" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::EnableTimingPerRun" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|       cl::desc("Time each pass, printing elapsed time for each on exit"));
#   43|   
#   44|-> static cl::opt<bool, true> EnableTimingPerRun(
#   45|       "time-passes-per-run", cl::location(TimePassesPerRun), cl::Hidden,
#   46|       cl::desc("Time each pass run, printing elapsed time for each run on exit"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:21: constructor_uses_global_object: The constructor of global object "PrintBefore[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintBefore[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   19|   // Print IR out before/after specified passes.
#   20|   static cl::list<std::string>
#   21|->     PrintBefore("print-before",
#   22|                   llvm::cl::desc("Print IR before specified passes"),
#   23|                   cl::CommaSeparated, cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:26: constructor_uses_global_object: The constructor of global object "PrintAfter[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintAfter[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   
#   25|   static cl::list<std::string>
#   26|->     PrintAfter("print-after", llvm::cl::desc("Print IR after specified passes"),
#   27|                  cl::CommaSeparated, cl::Hidden);
#   28|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:29: constructor_uses_global_object: The constructor of global object "PrintBeforeAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintBeforeAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|                  cl::CommaSeparated, cl::Hidden);
#   28|   
#   29|-> static cl::opt<bool> PrintBeforeAll("print-before-all",
#   30|                                       llvm::cl::desc("Print IR before each pass"),
#   31|                                       cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:32: constructor_uses_global_object: The constructor of global object "PrintAfterAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintAfterAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|                                       llvm::cl::desc("Print IR before each pass"),
#   31|                                       cl::init(false), cl::Hidden);
#   32|-> static cl::opt<bool> PrintAfterAll("print-after-all",
#   33|                                      llvm::cl::desc("Print IR after each pass"),
#   34|                                      cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:60: constructor_uses_global_object: The constructor of global object "llvm::PrintChanged" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PrintChanged" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|   // have the necessary facilities, the error message will be shown in place of
#   59|   // the expected output.
#   60|-> cl::opt<ChangePrinter> llvm::PrintChanged(
#   61|       "print-changed", cl::desc("Print changed IRs"), cl::Hidden,
#   62|       cl::ValueOptional, cl::init(ChangePrinter::None),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:82: constructor_uses_global_object: The constructor of global object "DiffBinary[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DiffBinary[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   // An option for specifying the diff used by print-changed=[diff | diff-quiet]
#   81|   static cl::opt<std::string>
#   82|->     DiffBinary("print-changed-diff-path", cl::Hidden, cl::init("diff"),
#   83|                  cl::desc("system diff used by change reporters"));
#   84|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:86: constructor_uses_global_object: The constructor of global object "PrintModuleScope" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintModuleScope" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|   
#   85|   static cl::opt<bool>
#   86|->     PrintModuleScope("print-module-scope",
#   87|                        cl::desc("When printing IR for print-[before|after]{-all} "
#   88|                                 "always print a module IR"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:93: constructor_uses_global_object: The constructor of global object "FilterPasses[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FilterPasses[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   91|   // See the description for -print-changed for an explanation of the use
#   92|   // of this option.
#   93|-> static cl::list<std::string> FilterPasses(
#   94|       "filter-passes", cl::value_desc("pass names"),
#   95|       cl::desc("Only consider IR changes for passes whose names "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/PrintPasses.cpp:100: constructor_uses_global_object: The constructor of global object "PrintFuncsList[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintFuncsList[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   98|   
#   99|   static cl::list<std::string>
#  100|->     PrintFuncsList("filter-print-funcs", cl::value_desc("function names"),
#  101|                      cl::desc("Only print IR for functions whose name "
#  102|                               "match this for all print-[before|after][-all] "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/SafepointIRVerifier.cpp:58: constructor_uses_global_object: The constructor of global object "PrintOnly" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintOnly" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|   /// when verification fails, report a message to the console (for FileCheck
#   57|   /// usage) and continue execution as if nothing happened.
#   58|-> static cl::opt<bool> PrintOnly("safepoint-ir-verifier-print-only",
#   59|                                  cl::init(false));
#   60|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/Value.cpp:39: constructor_uses_global_object: The constructor of global object "UseDerefAtPointSemantics" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseDerefAtPointSemantics" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   using namespace llvm;
#   38|   
#   39|-> static cl::opt<unsigned> UseDerefAtPointSemantics(
#   40|       "use-dereferenceable-at-point-semantics", cl::Hidden, cl::init(false),
#   41|       cl::desc("Deref attributes and metadata infer facts at definition only"));

Error: USE_AFTER_FREE (CWE-416):
llvm-17.0.6.src/lib/IR/Value.cpp:1147: identity_transfer: Member function call "Handles->getPointerIntoBucketsArray()" returns field "Buckets".
llvm-17.0.6.src/lib/IR/Value.cpp:1147: assign: Assigning: "OldBucketPtr" = "Handles->getPointerIntoBucketsArray()".
llvm-17.0.6.src/lib/IR/Value.cpp:1149: freed_arg: "operator []" frees "Handles.Buckets".
llvm-17.0.6.src/lib/IR/Value.cpp:1156: pass_freed_arg: Passing freed pointer "OldBucketPtr" as an argument to "isPointerIntoBucketsArray".
# 1154|     // If reallocation didn't happen or if this was the first insertion, don't
# 1155|     // walk the table.
# 1156|->   if (Handles.isPointerIntoBucketsArray(OldBucketPtr) ||
# 1157|         Handles.size() == 1) {
# 1158|       return;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/IR/Verifier.cpp:128: constructor_uses_global_object: The constructor of global object "VerifyNoAliasScopeDomination" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyNoAliasScopeDomination" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|   using namespace llvm;
#  127|   
#  128|-> static cl::opt<bool> VerifyNoAliasScopeDomination(
#  129|       "verify-noalias-scope-decl-dom", cl::Hidden, cl::init(false),
#  130|       cl::desc("Ensure that llvm.experimental.noalias.scope.decl for identical "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/IR/Verifier.cpp:3728: var_decl: Declaring variable "Copy".
llvm-17.0.6.src/lib/IR/Verifier.cpp:3740: uninit_use: Using uninitialized value "Copy". Field "Copy.Attrs.InlineElts" is uninitialized.
# 3738|          Attrs.hasParamAttr(I, Attribute::ByRef)))
# 3739|       Copy.addAlignmentAttr(Attrs.getParamAlignment(I));
# 3740|->   return Copy;
# 3741|   }
# 3742|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/IR/Verifier.cpp:5216: assignment: Assigning: "Kind" = "llvm::Attribute::getAttrKindFromName(Elem.Tag->getKey())". The value of "Kind" is now between 0 and 87 (inclusive).
llvm-17.0.6.src/lib/IR/Verifier.cpp:5231: cond_between: Checking "Kind == None" implies that "Kind" is between 1 and 87 (inclusive) on the false branch.
llvm-17.0.6.src/lib/IR/Verifier.cpp:5237: overrun-call: Overrunning callee's array of size 84 by passing argument "Kind" (which evaluates to 87) in call to "canUseAsParamAttr".
# 5235|           Check(isa<ConstantInt>(Call.getOperand(Elem.Begin + 1)),
# 5236|                 "the second argument should be a constant integral value", Call);
# 5237|->       } else if (Attribute::canUseAsParamAttr(Kind)) {
# 5238|           Check((ArgCount) == 1, "this attribute should have one argument", Call);
# 5239|         } else if (Attribute::canUseAsFnAttr(Kind)) {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/IR/Verifier.cpp:5216: assignment: Assigning: "Kind" = "llvm::Attribute::getAttrKindFromName(Elem.Tag->getKey())". The value of "Kind" is now between 0 and 87 (inclusive).
llvm-17.0.6.src/lib/IR/Verifier.cpp:5231: cond_between: Checking "Kind == None" implies that "Kind" is between 1 and 87 (inclusive) on the false branch.
llvm-17.0.6.src/lib/IR/Verifier.cpp:5239: overrun-call: Overrunning callee's array of size 84 by passing argument "Kind" (which evaluates to 87) in call to "canUseAsFnAttr".
# 5237|         } else if (Attribute::canUseAsParamAttr(Kind)) {
# 5238|           Check((ArgCount) == 1, "this attribute should have one argument", Call);
# 5239|->       } else if (Attribute::canUseAsFnAttr(Kind)) {
# 5240|           Check((ArgCount) == 0, "this attribute has no argument", Call);
# 5241|         }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTO.cpp:69: constructor_uses_global_object: The constructor of global object "DumpThinCGSCCs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DumpThinCGSCCs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|   
#   68|   static cl::opt<bool>
#   69|->     DumpThinCGSCCs("dump-thin-cg-sccs", cl::init(false), cl::Hidden,
#   70|                      cl::desc("Dump the SCCs in the ThinLTO index's callgraph"));
#   71|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTO.cpp:74: constructor_uses_global_object: The constructor of global object "llvm::EnableLTOInternalization" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::EnableLTOInternalization" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   namespace llvm {
#   73|   /// Enable global value internalization in LTO.
#   74|-> cl::opt<bool> EnableLTOInternalization(
#   75|       "enable-lto-internalization", cl::init(true), cl::Hidden,
#   76|       cl::desc("Enable global value internalization in LTO"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOBackend.cpp:61: constructor_uses_global_object: The constructor of global object "EmbedBitcode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EmbedBitcode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   59|   };
#   60|   
#   61|-> static cl::opt<LTOBitcodeEmbedding> EmbedBitcode(
#   62|       "lto-embed-bitcode", cl::init(LTOBitcodeEmbedding::DoNotEmbed),
#   63|       cl::values(clEnumValN(LTOBitcodeEmbedding::DoNotEmbed, "none",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOBackend.cpp:72: constructor_uses_global_object: The constructor of global object "ThinLTOAssumeMerged" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ThinLTOAssumeMerged" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   70|       cl::desc("Embed LLVM bitcode in object files produced by LTO"));
#   71|   
#   72|-> static cl::opt<bool> ThinLTOAssumeMerged(
#   73|       "thinlto-assume-merged", cl::init(false),
#   74|       cl::desc("Assume the input has already undergone ThinLTO function "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:74: constructor_uses_global_object: The constructor of global object "llvm::LTODiscardValueNames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::LTODiscardValueNames" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   
#   73|   namespace llvm {
#   74|-> cl::opt<bool> LTODiscardValueNames(
#   75|       "lto-discard-value-names",
#   76|       cl::desc("Strip names from Value during LTO (other than GlobalValue)."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:84: constructor_uses_global_object: The constructor of global object "llvm::RemarksWithHotness" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::RemarksWithHotness" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   82|       cl::Hidden);
#   83|   
#   84|-> cl::opt<bool> RemarksWithHotness(
#   85|       "lto-pass-remarks-with-hotness",
#   86|       cl::desc("With PGO, include profile count in optimization remarks"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:90: constructor_uses_global_object: The constructor of global object "llvm::RemarksHotnessThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::RemarksHotnessThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   88|   
#   89|   cl::opt<std::optional<uint64_t>, false, remarks::HotnessThresholdParser>
#   90|->     RemarksHotnessThreshold(
#   91|           "lto-pass-remarks-hotness-threshold",
#   92|           cl::desc("Minimum profile count required for an "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:98: constructor_uses_global_object: The constructor of global object "llvm::RemarksFilename[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::RemarksFilename[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   96|   
#   97|   cl::opt<std::string>
#   98|->     RemarksFilename("lto-pass-remarks-output",
#   99|                       cl::desc("Output filename for pass remarks"),
#  100|                       cl::value_desc("filename"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:103: constructor_uses_global_object: The constructor of global object "llvm::RemarksPasses[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::RemarksPasses[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  101|   
#  102|   cl::opt<std::string>
#  103|->     RemarksPasses("lto-pass-remarks-filter",
#  104|                     cl::desc("Only record optimization remarks from passes whose "
#  105|                              "names match the given regular expression"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:108: constructor_uses_global_object: The constructor of global object "llvm::RemarksFormat[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::RemarksFormat[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|                     cl::value_desc("regex"));
#  107|   
#  108|-> cl::opt<std::string> RemarksFormat(
#  109|       "lto-pass-remarks-format",
#  110|       cl::desc("The format used for serializing remarks (default: YAML)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:113: constructor_uses_global_object: The constructor of global object "llvm::LTOStatsFile[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::LTOStatsFile[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  111|       cl::value_desc("format"), cl::init("yaml"));
#  112|   
#  113|-> cl::opt<std::string> LTOStatsFile(
#  114|       "lto-stats-file",
#  115|       cl::desc("Save statistics to the specified file"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:118: constructor_uses_global_object: The constructor of global object "llvm::AIXSystemAssemblerPath[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::AIXSystemAssemblerPath[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  116|       cl::Hidden);
#  117|   
#  118|-> cl::opt<std::string> AIXSystemAssemblerPath(
#  119|       "lto-aix-system-assembler",
#  120|       cl::desc("Path to a system assembler, picked up on AIX only"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:124: constructor_uses_global_object: The constructor of global object "llvm::LTORunCSIRInstr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::LTORunCSIRInstr" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  122|   
#  123|   cl::opt<bool>
#  124|->     LTORunCSIRInstr("cs-profile-generate",
#  125|                       cl::desc("Perform context sensitive PGO instrumentation"));
#  126|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/LTOCodeGenerator.cpp:128: constructor_uses_global_object: The constructor of global object "llvm::LTOCSIRProfile[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::LTOCSIRProfile[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|   
#  127|   cl::opt<std::string>
#  128|->     LTOCSIRProfile("cs-profile-path",
#  129|                      cl::desc("Context sensitive profile file path"));
#  130|   } // namespace llvm

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/SummaryBasedOptimizations.cpp:22: constructor_uses_global_object: The constructor of global object "ThinLTOSynthesizeEntryCounts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ThinLTOSynthesizeEntryCounts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   20|   using namespace llvm;
#   21|   
#   22|-> static cl::opt<bool> ThinLTOSynthesizeEntryCounts(
#   23|       "thinlto-synthesize-entry-counts", cl::init(false), cl::Hidden,
#   24|       cl::desc("Synthesize entry counts based on the summary"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/LTO/ThinLTOCodeGenerator.cpp:92: constructor_uses_global_object: The constructor of global object "<unnamed>::ThreadCount" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ThreadCount" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   90|   // thred per core, as indicated by the usage of
#   91|   // heavyweight_hardware_concurrency() below.
#   92|-> static cl::opt<int> ThreadCount("threads", cl::init(0));
#   93|   
#   94|   // Simple helper to save temporary files for debug.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/MC/MCAsmInfo.cpp:27: constructor_uses_global_object: The constructor of global object "DwarfExtendedLoc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DwarfExtendedLoc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   enum DefaultOnOff { Default, Enable, Disable };
#   26|   }
#   27|-> static cl::opt<DefaultOnOff> DwarfExtendedLoc(
#   28|       "dwarf-extended-loc", cl::Hidden,
#   29|       cl::desc("Disable emission of the extended flags in .loc directives."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/MC/MCAsmInfo.cpp:35: constructor_uses_global_object: The constructor of global object "llvm::UseLEB128Directives" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::UseLEB128Directives" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   namespace llvm {
#   35|-> cl::opt<cl::boolOrDefault> UseLEB128Directives(
#   36|       "use-leb128-directives", cl::Hidden,
#   37|       cl::desc(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCCodeView.cpp:506: var_decl: Declaring variable "CurSourceLoc" without initializer.
llvm-17.0.6.src/lib/MC/MCCodeView.cpp:586: uninit_use: Using uninitialized value "CurSourceLoc". Field "CurSourceLoc.Col" is uninitialized.
#  584|   
#  585|       LastLabel = Loc.getLabel();
#  586|->     LastSourceLoc = CurSourceLoc;
#  587|     }
#  588|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/AsmParser.cpp:3260: var_decl: Declaring variable "Value".
llvm-17.0.6.src/lib/MC/MCParser/AsmParser.cpp:3269: uninit_use_in_call: Using uninitialized value "Value.U" when calling "~APFloat".
# 3267|         Value = APFloat::getNaN(Semantics, false, ~0);
# 3268|       else
# 3269|->       return TokError("invalid floating point literal");
# 3270|     } else if (errorToBool(
# 3271|                    Value.convertFromString(IDVal, APFloat::rmNearestTiesToEven)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/AsmParser.cpp:3260: var_decl: Declaring variable "Value".
llvm-17.0.6.src/lib/MC/MCParser/AsmParser.cpp:3270: uninit_use_in_call: Using uninitialized value "Value.U" when calling "convertFromString".
# 3268|       else
# 3269|         return TokError("invalid floating point literal");
# 3270|->   } else if (errorToBool(
# 3271|                    Value.convertFromString(IDVal, APFloat::rmNearestTiesToEven)
# 3272|                        .takeError()))

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/MC/MCParser/MCAsmParser.cpp:25: constructor_uses_global_object: The constructor of global object "llvm::AsmMacroMaxNestingDepth" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::AsmMacroMaxNestingDepth" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   23|   
#   24|   namespace llvm {
#   25|-> cl::opt<unsigned> AsmMacroMaxNestingDepth(
#   26|       "asm-macro-max-nesting-depth", cl::init(20), cl::Hidden,
#   27|       cl::desc("The maximum nesting depth allowed for assembly macros."));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:1489: var_decl: Declaring variable "Refs".
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:1508: uninit_use: Using uninitialized value "Refs". Field "Refs.InlineElts" is uninitialized.
# 1506|     }
# 1507|     Refs.emplace_back(Start, getTok().getLoc().getPointer() - Start);
# 1508|->   return Refs;
# 1509|   }
# 1510|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3834: var_decl: Declaring variable "Value".
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3844: uninit_use_in_call: Using uninitialized value "Value.U" when calling "~APFloat".
# 3842|         Value = APFloat::getZero(Semantics);
# 3843|       else
# 3844|->       return TokError("invalid floating point literal");
# 3845|     } else if (IDVal.consume_back("r") || IDVal.consume_back("R")) {
# 3846|       // MASM hexadecimal floating-point literal; no APFloat conversion needed.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3834: var_decl: Declaring variable "Value".
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3850: uninit_use_in_call: Using uninitialized value "Value.U" when calling "~APFloat".
# 3848|       unsigned SizeInBits = Value.getSizeInBits(Semantics);
# 3849|       if (SizeInBits != (IDVal.size() << 2))
# 3850|->       return TokError("invalid floating point literal");
# 3851|   
# 3852|       // Consume the numeric token.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3834: var_decl: Declaring variable "Value".
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3857: uninit_use_in_call: Using uninitialized value "Value.U" when calling "~APFloat".
# 3855|       Res = APInt(SizeInBits, IDVal, 16);
# 3856|       if (SignLoc.isValid())
# 3857|->       return Warning(SignLoc, "MASM-style hex floats ignore explicit sign");
# 3858|       return false;
# 3859|     } else if (errorToBool(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3834: var_decl: Declaring variable "Value".
llvm-17.0.6.src/lib/MC/MCParser/MasmParser.cpp:3859: uninit_use_in_call: Using uninitialized value "Value.U" when calling "convertFromString".
# 3857|         return Warning(SignLoc, "MASM-style hex floats ignore explicit sign");
# 3858|       return false;
# 3859|->   } else if (errorToBool(
# 3860|                    Value.convertFromString(IDVal, APFloat::rmNearestTiesToEven)
# 3861|                        .takeError())) {

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/MC/MCSectionMachO.cpp:119: assignment: Assigning: "SectionType" = "this->getType()". The value of "SectionType" may now be up to 255.
llvm-17.0.6.src/lib/MC/MCSectionMachO.cpp:123: illegal_address: "SectionTypeDescriptors + SectionType" evaluates to an address that is at byte offset 8160 of an array of 736 bytes.
#  121|            "Invalid SectionType specified!");
#  122|   
#  123|->   if (!SectionTypeDescriptors[SectionType].AssemblerName.empty()) {
#  124|       OS << ',';
#  125|       OS << SectionTypeDescriptors[SectionType].AssemblerName;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/WasmObjectWriter.cpp:1657: var_decl: Declaring variable "Global".
llvm-17.0.6.src/lib/MC/WasmObjectWriter.cpp:1682: uninit_use_in_call: Using uninitialized value "Global". Field "Global.InitExpr.Inst.Value" is uninitialized when calling "push_back".
# 1680|             assert(WasmIndices.count(&WS) == 0);
# 1681|             WasmIndices[&WS] = Global.Index;
# 1682|->           Globals.push_back(Global);
# 1683|           } else {
# 1684|             // An import; the index was assigned above

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/MC/WasmObjectWriter.cpp:1805: var_decl: Declaring variable "Info".
llvm-17.0.6.src/lib/MC/WasmObjectWriter.cpp:1817: uninit_use_in_call: Using uninitialized value "Info". Field "Info" is uninitialized when calling "emplace_back".
# 1815|       }
# 1816|       WS.setIndex(SymbolInfos.size());
# 1817|->     SymbolInfos.emplace_back(Info);
# 1818|     }
# 1819|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/MC/WinCOFFObjectWriter.cpp:672: assignment: Assigning: "SymbolSize" = "this->UseBigObj ? Symbol32Size : Symbol16Size". The value of "SymbolSize" is now 20.
llvm-17.0.6.src/lib/MC/WinCOFFObjectWriter.cpp:685: cond_between: Checking "Length > SymbolSize" implies that "Length" is between 1 and 20 (inclusive) on the false branch.
llvm-17.0.6.src/lib/MC/WinCOFFObjectWriter.cpp:690: overrun-local: Overrunning array of 20 bytes at byte offset 20 by dereferencing pointer "(char *)&Aux.Aux + Length".
#  688|         } else {
#  689|           memcpy(&Aux.Aux, Name.c_str() + Offset, Length);
#  690|->         memset((char *)&Aux.Aux + Length, 0, SymbolSize - Length);
#  691|           break;
#  692|         }

Error: Y2K38_SAFETY (CWE-197):
llvm-17.0.6.src/lib/MC/WinCOFFObjectWriter.cpp:1136: store_truncates_time_t: A "time_t" value is stored in an integer with too few bits to accommodate it.  The expression "getTime()" is cast to "uint32_t".
# 1134|     // /INCREMENTAL feature.
# 1135|     if (Asm.isIncrementalLinkerCompatible()) {
# 1136|->     Header.TimeDateStamp = getTime();
# 1137|     } else {
# 1138|       // Have deterministic output if /INCREMENTAL isn't needed. Also matches GNU.

Error: BUFFER_SIZE (CWE-170):
llvm-17.0.6.src/lib/ObjCopy/COFF/COFFWriter.cpp:151: buffer_size_warning: Calling "strncpy" with a maximum size argument of 8 bytes on destination array "S.Sym.Name.ShortName" of size 8 bytes might leave the destination string unterminated.
#  149|         S.Sym.Name.Offset.Offset = StrTabBuilder.getOffset(S.Name);
#  150|       } else {
#  151|->       strncpy(S.Sym.Name.ShortName, S.Name.data(), COFF::NameSize);
#  152|       }
#  153|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:701: var_decl: Declaring variable "Sym".
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:718: uninit_use_in_call: Using uninitialized value "Sym.NameIndex" when calling "make_unique".
#  716|     Sym.Size = SymbolSize;
#  717|     Sym.Index = Symbols.size();
#  718|->   Symbols.emplace_back(std::make_unique<Symbol>(Sym));
#  719|     Size += this->EntrySize;
#  720|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:701: var_decl: Declaring variable "Sym".
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:718: uninit_use_in_call: Using uninitialized value "Sym.NameIndex" when calling "make_unique".
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:718: uninit_use_in_call: Using uninitialized value "Sym.ShndxType" when calling "make_unique".
#  716|     Sym.Size = SymbolSize;
#  717|     Sym.Index = Symbols.size();
#  718|->   Symbols.emplace_back(std::make_unique<Symbol>(Sym));
#  719|     Size += this->EntrySize;
#  720|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:1629: var_decl: Declaring variable "ToAdd".
llvm-17.0.6.src/lib/ObjCopy/ELF/ELFObject.cpp:1648: uninit_use_in_call: Using uninitialized value "ToAdd". Field "ToAdd.Addend" is uninitialized when calling "addRelocation".
# 1646|       }
# 1647|   
# 1648|->     Relocs->addRelocation(ToAdd);
# 1649|     }
# 1650|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/MachO/MachOObjcopy.cpp:306: var_decl: Declaring variable "Sec".
llvm-17.0.6.src/lib/ObjCopy/MachO/MachOObjcopy.cpp:318: uninit_use_in_call: Using uninitialized value "Sec.Index" when calling "make_unique".
#  316|         for (const std::unique_ptr<Section> &S : LC.Sections)
#  317|           Addr = std::max(Addr, S->Addr + S->Size);
#  318|->       LC.Sections.push_back(std::make_unique<Section>(Sec));
#  319|         LC.Sections.back()->Addr = Addr;
#  320|         return Error::success();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/MachO/MachOObjcopy.cpp:306: var_decl: Declaring variable "Sec".
llvm-17.0.6.src/lib/ObjCopy/MachO/MachOObjcopy.cpp:328: uninit_use_in_call: Using uninitialized value "Sec.Index" when calling "make_unique".
#  326|     LoadCommand &NewSegment =
#  327|         Obj.addSegment(TargetSegName, alignTo(Sec.Size, 16384));
#  328|->   NewSegment.Sections.push_back(std::make_unique<Section>(Sec));
#  329|     NewSegment.Sections.back()->Addr = *NewSegment.getSegmentVMAddr();
#  330|     return Error::success();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/MachO/MachOReader.cpp:223: var_decl: Declaring variable "SE".
llvm-17.0.6.src/lib/ObjCopy/MachO/MachOReader.cpp:229: uninit_use: Using uninitialized value "SE". Field "SE.Index" is uninitialized.
#  227|     SE.n_desc = nlist.n_desc;
#  228|     SE.n_value = nlist.n_value;
#  229|->   return SE;
#  230|   }
#  231|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjCopy/wasm/WasmWriter.cpp:25: var_decl: Declaring variable "Header".
llvm-17.0.6.src/lib/ObjCopy/wasm/WasmWriter.cpp:45: uninit_use: Using uninitialized value "Header". Field "Header.InlineElts" is uninitialized.
#   43|     // the LEB-encoded size.
#   44|     SectionSize = SectionSize + 1 + HeaderSecSizeEncodingLen;
#   45|->   return Header;
#   46|   }
#   47|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Object/IRSymtab.cpp:44: constructor_uses_global_object: The constructor of global object "DisableBitcodeVersionUpgrade" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBitcodeVersionUpgrade" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   using namespace irsymtab;
#   43|   
#   44|-> static cl::opt<bool> DisableBitcodeVersionUpgrade(
#   45|       "disable-bitcode-version-upgrade", cl::Hidden,
#   46|       cl::desc("Disable automatic bitcode upgrade for version mismatch"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Object/MachOObjectFile.cpp:4348: var_decl: Declaring variable "CurSegAddress" without initializer.
llvm-17.0.6.src/lib/Object/MachOObjectFile.cpp:4366: uninit_use: Using uninitialized value "CurSegAddress".
# 4364|       }
# 4365|       Info.SegmentIndex = CurSegIndex - 1;
# 4366|->     Info.OffsetInSegment = Info.Address - CurSegAddress;
# 4367|       Info.SegmentStartAddress = CurSegAddress;
# 4368|       Sections.push_back(Info);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Object/MachOObjectFile.cpp:4488: var_decl: Declaring variable "Finish".
llvm-17.0.6.src/lib/Object/MachOObjectFile.cpp:4491: uninit_use_in_call: Using uninitialized value "Finish.Kind" when calling "MachOChainedFixupEntry".
# 4489|     Finish.moveToEnd();
# 4490|   
# 4491|->   return make_range(fixup_iterator(Start), fixup_iterator(Finish));
# 4492|   }
# 4493|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:160: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:160: leaked_storage: Ignoring storage allocated by "ChildOrErr.get()->release()" leaks it.
#  158|         }
#  159|         if (!MFO) {
#  160|->         ChildOrErr.get().release();
#  161|           MFO.reset(O);
#  162|         }

Error: MULTIPLE_INIT_SMART_PTRS (CWE-1341):
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:128: get_raw_ptr: Function "get" returns a pointer managed by "ChildOrErr.get()".
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:128: assign: Assigning: "Bin" = "ChildOrErr.get()->get()".
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:136: identity_transfer: Passing "Bin" as argument 1 to function "cast", which returns that argument.
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:136: assign: Assigning: "O" = "llvm::cast(Bin)".
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:161: multiple_init_smart_ptr: Function "reset" sets "MFO" with "O", but it is already managed by another smart pointer.
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:161: remediation: Either release the raw pointer from the smart pointer, or share/transfer the raw pointer by using a copy/move/assignment operation.
#  159|         if (!MFO) {
#  160|           ChildOrErr.get().release();
#  161|->         MFO.reset(O);
#  162|         }
#  163|       } else if (Bin->isIR()) {

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:194: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:194: leaked_storage: Ignoring storage allocated by "ChildOrErr.get()->release()" leaks it.
#  192|           }
#  193|         } else {
#  194|->         ChildOrErr.get().release();
#  195|           IRFO.reset(O);
#  196|         }

Error: MULTIPLE_INIT_SMART_PTRS (CWE-1341):
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:128: get_raw_ptr: Function "get" returns a pointer managed by "ChildOrErr.get()".
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:128: assign: Assigning: "Bin" = "ChildOrErr.get()->get()".
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:164: identity_transfer: Passing "Bin" as argument 1 to function "cast", which returns that argument.
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:164: assign: Assigning: "O" = "llvm::cast(Bin)".
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:195: multiple_init_smart_ptr: Function "reset" sets "IRFO" with "O", but it is already managed by another smart pointer.
llvm-17.0.6.src/lib/Object/MachOUniversalWriter.cpp:195: remediation: Either release the raw pointer from the smart pointer, or share/transfer the raw pointer by using a copy/move/assignment operation.
#  193|         } else {
#  194|           ChildOrErr.get().release();
#  195|->         IRFO.reset(O);
#  196|         }
#  197|       } else

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Object/WasmObjectFile.cpp:251: var_decl: Declaring variable "Result" without initializer.
llvm-17.0.6.src/lib/Object/WasmObjectFile.cpp:256: uninit_use: Using uninitialized value "Result". Field "Result.Maximum" is uninitialized.
#  254|     if (Result.Flags & wasm::WASM_LIMITS_FLAG_HAS_MAX)
#  255|       Result.Maximum = readVaruint64(Ctx);
#  256|->   return Result;
#  257|   }
#  258|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Object/WasmObjectFile.cpp:626: var_decl: Declaring variable "Info".
llvm-17.0.6.src/lib/Object/WasmObjectFile.cpp:798: uninit_use_in_call: Using uninitialized value "Info". Field "Info" is uninitialized when calling "emplace_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  796|                                                   Twine(Info.Name),
#  797|                                               object_error::parse_failed);
#  798|->     LinkingData.SymbolTable.emplace_back(Info);
#  799|       Symbols.emplace_back(LinkingData.SymbolTable.back(), GlobalType, TableType,
#  800|                            Signature);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Object/WasmObjectFile.cpp:1195: var_decl: Declaring variable "F".
llvm-17.0.6.src/lib/Object/WasmObjectFile.cpp:1197: uninit_use_in_call: Using uninitialized value "F". Field "F.Index" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1195|       wasm::WasmFunction F;
# 1196|       F.SigIndex = Type;
# 1197|->     Functions.push_back(F);
# 1198|     }
# 1199|     if (Ctx.Ptr != Ctx.End)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjectYAML/CodeViewYAMLSymbols.cpp:646: var_decl: Declaring variable "Kind" without initializer.
llvm-17.0.6.src/lib/ObjectYAML/CodeViewYAMLSymbols.cpp:649: uninit_use_in_call: Using uninitialized value "Kind" when calling "mapRequired".
#  647|     if (IO.outputting())
#  648|       Kind = Obj.Symbol->Kind;
#  649|->   IO.mapRequired("Kind", Kind);
#  650|   
#  651|   #define SYMBOL_RECORD(EnumName, EnumVal, ClassName)                            \

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjectYAML/ELFYAML.cpp:1547: var_decl: Declaring variable "Type" without initializer.
llvm-17.0.6.src/lib/ObjectYAML/ELFYAML.cpp:1581: uninit_use_in_call: Using uninitialized value "Type.value" when calling "operator ==".
# 1579|   
# 1580|     const auto &Obj = *static_cast<ELFYAML::Object *>(IO.getContext());
# 1581|->   if (Obj.getMachine() == ELF::EM_MIPS && Type == ELF::SHT_MIPS_ABIFLAGS) {
# 1582|       if (!IO.outputting())
# 1583|         Section.reset(new ELFYAML::MipsABIFlags());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjectYAML/ELFYAML.cpp:1547: var_decl: Declaring variable "Type" without initializer.
llvm-17.0.6.src/lib/ObjectYAML/ELFYAML.cpp:1588: uninit_use_in_call: Using uninitialized value "Type.value" when calling "operator ==".
# 1586|     }
# 1587|   
# 1588|->   if (Obj.getMachine() == ELF::EM_ARM && Type == ELF::SHT_ARM_EXIDX) {
# 1589|       if (!IO.outputting())
# 1590|         Section.reset(new ELFYAML::ARMIndexTableSection());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjectYAML/MachOEmitter.cpp:109: var_decl: Declaring variable "TempSec" without initializer.
llvm-17.0.6.src/lib/ObjectYAML/MachOEmitter.cpp:121: uninit_use: Using uninitialized value "TempSec". Field "TempSec.reserved3" is uninitialized.
#  119|     TempSec.reserved1 = Sec.reserved1;
#  120|     TempSec.reserved2 = Sec.reserved2;
#  121|->   return TempSec;
#  122|   }
#  123|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjectYAML/MachOEmitter.cpp:693: var_decl: Declaring variable "FatArch" without initializer.
llvm-17.0.6.src/lib/ObjectYAML/MachOEmitter.cpp:699: uninit_use: Using uninitialized value "FatArch". Field "FatArch.reserved" is uninitialized.
#  697|     FatArch.size = Arch.size;
#  698|     FatArch.align = Arch.align;
#  699|->   return FatArch;
#  700|   }
#  701|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ObjectYAML/MinidumpYAML.cpp:402: var_decl: Declaring variable "Type" without initializer.
llvm-17.0.6.src/lib/ObjectYAML/MinidumpYAML.cpp:405: uninit_use_in_call: Using uninitialized value "Type" when calling "mapRequired".
#  403|     if (IO.outputting())
#  404|       Type = S->Type;
#  405|->   IO.mapRequired("Type", Type);
#  406|   
#  407|     if (!IO.outputting())

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilder.cpp:271: constructor_uses_global_object: The constructor of global object "llvm::PrintPipelinePasses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::PrintPipelinePasses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  269|   
#  270|   namespace llvm {
#  271|-> cl::opt<bool> PrintPipelinePasses(
#  272|       "print-pipeline-passes",
#  273|       cl::desc("Print a '-passes' compatible string describing the pipeline "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:138: constructor_uses_global_object: The constructor of global object "UseInlineAdvisor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseInlineAdvisor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  136|   using namespace llvm;
#  137|   
#  138|-> static cl::opt<InliningAdvisorMode> UseInlineAdvisor(
#  139|       "enable-ml-inliner", cl::init(InliningAdvisorMode::Default), cl::Hidden,
#  140|       cl::desc("Enable ML policy for inliner. Currently trained for -Oz only"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:148: constructor_uses_global_object: The constructor of global object "EnableSyntheticCounts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSyntheticCounts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  146|                             "Use release mode (AOT-compiled model)")));
#  147|   
#  148|-> static cl::opt<bool> EnableSyntheticCounts(
#  149|       "enable-npm-synthetic-counts", cl::Hidden,
#  150|       cl::desc("Run synthetic function entry count generation "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:155: constructor_uses_global_object: The constructor of global object "EnablePGOInlineDeferral" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePGOInlineDeferral" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  153|   /// Flag to enable inline deferral during PGO.
#  154|   static cl::opt<bool>
#  155|->     EnablePGOInlineDeferral("enable-npm-pgo-inline-deferral", cl::init(true),
#  156|                               cl::Hidden,
#  157|                               cl::desc("Enable inline deferral during PGO"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:159: constructor_uses_global_object: The constructor of global object "EnableModuleInliner" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableModuleInliner" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  157|                               cl::desc("Enable inline deferral during PGO"));
#  158|   
#  159|-> static cl::opt<bool> EnableModuleInliner("enable-module-inliner",
#  160|                                            cl::init(false), cl::Hidden,
#  161|                                            cl::desc("Enable module inliner"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:163: constructor_uses_global_object: The constructor of global object "PerformMandatoryInliningsFirst" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PerformMandatoryInliningsFirst" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  161|                                            cl::desc("Enable module inliner"));
#  162|   
#  163|-> static cl::opt<bool> PerformMandatoryInliningsFirst(
#  164|       "mandatory-inlining-first", cl::init(true), cl::Hidden,
#  165|       cl::desc("Perform mandatory inlinings module-wide, before performing "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:168: constructor_uses_global_object: The constructor of global object "EnableEagerlyInvalidateAnalyses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableEagerlyInvalidateAnalyses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  166|                "inlining"));
#  167|   
#  168|-> static cl::opt<bool> EnableEagerlyInvalidateAnalyses(
#  169|       "eagerly-invalidate-analyses", cl::init(true), cl::Hidden,
#  170|       cl::desc("Eagerly invalidate more analyses in default pipelines"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:172: constructor_uses_global_object: The constructor of global object "EnableMergeFunctions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMergeFunctions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  170|       cl::desc("Eagerly invalidate more analyses in default pipelines"));
#  171|   
#  172|-> static cl::opt<bool> EnableMergeFunctions(
#  173|       "enable-merge-functions", cl::init(false), cl::Hidden,
#  174|       cl::desc("Enable function merging as part of the optimization pipeline"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:176: constructor_uses_global_object: The constructor of global object "EnablePostPGOLoopRotation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePostPGOLoopRotation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  174|       cl::desc("Enable function merging as part of the optimization pipeline"));
#  175|   
#  176|-> static cl::opt<bool> EnablePostPGOLoopRotation(
#  177|       "enable-post-pgo-loop-rotation", cl::init(true), cl::Hidden,
#  178|       cl::desc("Run the loop rotation transformation after PGO instrumentation"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:180: constructor_uses_global_object: The constructor of global object "EnableGlobalAnalyses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalAnalyses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  178|       cl::desc("Run the loop rotation transformation after PGO instrumentation"));
#  179|   
#  180|-> static cl::opt<bool> EnableGlobalAnalyses(
#  181|       "enable-global-analyses", cl::init(true), cl::Hidden,
#  182|       cl::desc("Enable inter-procedural analyses"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:185: constructor_uses_global_object: The constructor of global object "RunPartialInlining" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RunPartialInlining" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  183|   
#  184|   static cl::opt<bool>
#  185|->     RunPartialInlining("enable-partial-inlining", cl::init(false), cl::Hidden,
#  186|                          cl::desc("Run Partial inlinining pass"));
#  187|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:188: constructor_uses_global_object: The constructor of global object "ExtraVectorizerPasses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExtraVectorizerPasses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  186|                          cl::desc("Run Partial inlinining pass"));
#  187|   
#  188|-> static cl::opt<bool> ExtraVectorizerPasses(
#  189|       "extra-vectorizer-passes", cl::init(false), cl::Hidden,
#  190|       cl::desc("Run cleanup optimization passes after vectorization"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:192: constructor_uses_global_object: The constructor of global object "RunNewGVN" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RunNewGVN" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  190|       cl::desc("Run cleanup optimization passes after vectorization"));
#  191|   
#  192|-> static cl::opt<bool> RunNewGVN("enable-newgvn", cl::init(false), cl::Hidden,
#  193|                                  cl::desc("Run the NewGVN pass"));
#  194|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:195: constructor_uses_global_object: The constructor of global object "EnableLoopInterchange" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLoopInterchange" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  193|                                  cl::desc("Run the NewGVN pass"));
#  194|   
#  195|-> static cl::opt<bool> EnableLoopInterchange(
#  196|       "enable-loopinterchange", cl::init(false), cl::Hidden,
#  197|       cl::desc("Enable the experimental LoopInterchange Pass"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:199: constructor_uses_global_object: The constructor of global object "EnableUnrollAndJam" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableUnrollAndJam" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  197|       cl::desc("Enable the experimental LoopInterchange Pass"));
#  198|   
#  199|-> static cl::opt<bool> EnableUnrollAndJam("enable-unroll-and-jam",
#  200|                                           cl::init(false), cl::Hidden,
#  201|                                           cl::desc("Enable Unroll And Jam Pass"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:203: constructor_uses_global_object: The constructor of global object "EnableLoopFlatten" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLoopFlatten" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  201|                                           cl::desc("Enable Unroll And Jam Pass"));
#  202|   
#  203|-> static cl::opt<bool> EnableLoopFlatten("enable-loop-flatten", cl::init(false),
#  204|                                          cl::Hidden,
#  205|                                          cl::desc("Enable the LoopFlatten Pass"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:208: constructor_uses_global_object: The constructor of global object "EnableDFAJumpThreading" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableDFAJumpThreading" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  206|   
#  207|   static cl::opt<bool>
#  208|->     EnableDFAJumpThreading("enable-dfa-jump-thread",
#  209|                              cl::desc("Enable DFA jump threading"),
#  210|                              cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:213: constructor_uses_global_object: The constructor of global object "EnableHotColdSplit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableHotColdSplit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  211|   
#  212|   static cl::opt<bool>
#  213|->     EnableHotColdSplit("hot-cold-split",
#  214|                          cl::desc("Enable hot-cold splitting pass"));
#  215|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:216: constructor_uses_global_object: The constructor of global object "EnableIROutliner" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableIROutliner" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  214|                          cl::desc("Enable hot-cold splitting pass"));
#  215|   
#  216|-> static cl::opt<bool> EnableIROutliner("ir-outliner", cl::init(false),
#  217|                                         cl::Hidden,
#  218|                                         cl::desc("Enable ir outliner pass"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:221: constructor_uses_global_object: The constructor of global object "DisablePreInliner" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePreInliner" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  219|   
#  220|   static cl::opt<bool>
#  221|->     DisablePreInliner("disable-preinline", cl::init(false), cl::Hidden,
#  222|                         cl::desc("Disable pre-instrumentation inliner"));
#  223|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:224: constructor_uses_global_object: The constructor of global object "PreInlineThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PreInlineThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  222|                         cl::desc("Disable pre-instrumentation inliner"));
#  223|   
#  224|-> static cl::opt<int> PreInlineThreshold(
#  225|       "preinline-threshold", cl::Hidden, cl::init(75),
#  226|       cl::desc("Control the amount of inlining in pre-instrumentation inliner "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:230: constructor_uses_global_object: The constructor of global object "EnableGVNHoist" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGVNHoist" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  228|   
#  229|   static cl::opt<bool>
#  230|->     EnableGVNHoist("enable-gvn-hoist",
#  231|                      cl::desc("Enable the GVN hoisting pass (default = off)"));
#  232|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:234: constructor_uses_global_object: The constructor of global object "EnableGVNSink" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGVNSink" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  232|   
#  233|   static cl::opt<bool>
#  234|->     EnableGVNSink("enable-gvn-sink",
#  235|                     cl::desc("Enable the GVN sinking pass (default = off)"));
#  236|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:240: constructor_uses_global_object: The constructor of global object "EnableCHR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCHR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  238|   // profile loading.
#  239|   static cl::opt<bool>
#  240|->     EnableCHR("enable-chr", cl::init(true), cl::Hidden,
#  241|                 cl::desc("Enable control height reduction optimization (CHR)"));
#  242|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:243: constructor_uses_global_object: The constructor of global object "FlattenedProfileUsed" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FlattenedProfileUsed" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  241|                 cl::desc("Enable control height reduction optimization (CHR)"));
#  242|   
#  243|-> static cl::opt<bool> FlattenedProfileUsed(
#  244|       "flattened-profile-used", cl::init(false), cl::Hidden,
#  245|       cl::desc("Indicate the sample profile being used is flattened, i.e., "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:248: constructor_uses_global_object: The constructor of global object "EnableOrderFileInstrumentation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableOrderFileInstrumentation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  246|                "no inline hierachy exists in the profile"));
#  247|   
#  248|-> static cl::opt<bool> EnableOrderFileInstrumentation(
#  249|       "enable-order-file-instrumentation", cl::init(false), cl::Hidden,
#  250|       cl::desc("Enable order file instrumentation (default = off)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:253: constructor_uses_global_object: The constructor of global object "EnableMatrix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMatrix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  251|   
#  252|   static cl::opt<bool>
#  253|->     EnableMatrix("enable-matrix", cl::init(false), cl::Hidden,
#  254|                    cl::desc("Enable lowering of the matrix intrinsics"));
#  255|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:256: constructor_uses_global_object: The constructor of global object "EnableConstraintElimination" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableConstraintElimination" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  254|                    cl::desc("Enable lowering of the matrix intrinsics"));
#  255|   
#  256|-> static cl::opt<bool> EnableConstraintElimination(
#  257|       "enable-constraint-elimination", cl::init(true), cl::Hidden,
#  258|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:261: constructor_uses_global_object: The constructor of global object "AttributorRun" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AttributorRun" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  259|           "Enable pass to eliminate conditions based on linear constraints"));
#  260|   
#  261|-> static cl::opt<AttributorRunOption> AttributorRun(
#  262|       "attributor-enable", cl::Hidden, cl::init(AttributorRunOption::NONE),
#  263|       cl::desc("Enable the attributor inter-procedural deduction pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/PassBuilderPipelines.cpp:273: constructor_uses_global_object: The constructor of global object "EnableMemProfContextDisambiguation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMemProfContextDisambiguation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  271|                             "disable attributor runs")));
#  272|   
#  273|-> cl::opt<bool> EnableMemProfContextDisambiguation(
#  274|       "enable-memprof-context-disambiguation", cl::init(false), cl::Hidden,
#  275|       cl::ZeroOrMore, cl::desc("Enable MemProf context disambiguation"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:47: constructor_uses_global_object: The constructor of global object "VerifyAnalysisInvalidation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyAnalysisInvalidation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   using namespace llvm;
#   46|   
#   47|-> static cl::opt<bool> VerifyAnalysisInvalidation("verify-analysis-invalidation",
#   48|                                                   cl::Hidden,
#   49|   #ifdef EXPENSIVE_CHECKS

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:60: constructor_uses_global_object: The constructor of global object "PrintChangedBefore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintChangedBefore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|   // of this option.  Note that this option has no effect without -print-changed.
#   59|   static cl::opt<bool>
#   60|->     PrintChangedBefore("print-before-changed",
#   61|                          cl::desc("Print before passes that change them"),
#   62|                          cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:67: constructor_uses_global_object: The constructor of global object "DotBinary[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DotBinary[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   // print-changed=[dot-cfg | dot-cfg-quiet]
#   66|   static cl::opt<std::string>
#   67|->     DotBinary("print-changed-dot-path", cl::Hidden, cl::init("dot"),
#   68|                 cl::desc("system dot used by change reporters"));
#   69|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:74: constructor_uses_global_object: The constructor of global object "BeforeColour[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BeforeColour[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   // https://graphviz.org/pdf/dotguide.pdf
#   73|   static cl::opt<std::string>
#   74|->     BeforeColour("dot-cfg-before-color",
#   75|                    cl::desc("Color for dot-cfg before elements"), cl::Hidden,
#   76|                    cl::init("red"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:81: constructor_uses_global_object: The constructor of global object "AfterColour[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AfterColour[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   79|   // https://graphviz.org/pdf/dotguide.pdf
#   80|   static cl::opt<std::string>
#   81|->     AfterColour("dot-cfg-after-color",
#   82|                   cl::desc("Color for dot-cfg after elements"), cl::Hidden,
#   83|                   cl::init("forestgreen"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:88: constructor_uses_global_object: The constructor of global object "CommonColour[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CommonColour[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   86|   // https://graphviz.org/pdf/dotguide.pdf
#   87|   static cl::opt<std::string>
#   88|->     CommonColour("dot-cfg-common-color",
#   89|                    cl::desc("Color for dot-cfg common elements"), cl::Hidden,
#   90|                    cl::init("black"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:94: constructor_uses_global_object: The constructor of global object "DotCfgDir[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DotCfgDir[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   92|   // An option that determines where the generated website file (named
#   93|   // passes.html) and the associated pdf files (named diff_*.pdf) are saved.
#   94|-> static cl::opt<std::string> DotCfgDir(
#   95|       "dot-cfg-dir",
#   96|       cl::desc("Generate dot files into specified directory for changed IRs"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:100: constructor_uses_global_object: The constructor of global object "PrintOnCrashPath[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintOnCrashPath[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   98|   
#   99|   // Options to print the IR that was being processed when a pass crashes.
#  100|-> static cl::opt<std::string> PrintOnCrashPath(
#  101|       "print-on-crash-path",
#  102|       cl::desc("Print the last form of the IR before crash to a file"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:105: constructor_uses_global_object: The constructor of global object "PrintOnCrash" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintOnCrash" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  103|       cl::Hidden);
#  104|   
#  105|-> static cl::opt<bool> PrintOnCrash(
#  106|       "print-on-crash",
#  107|       cl::desc("Print the last form of the IR before crash (use -print-on-crash-path to dump to a file)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:110: constructor_uses_global_object: The constructor of global object "OptBisectPrintIRPath[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptBisectPrintIRPath[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  108|       cl::Hidden);
#  109|   
#  110|-> static cl::opt<std::string> OptBisectPrintIRPath(
#  111|       "opt-bisect-print-ir-path",
#  112|       cl::desc("Print IR to path when opt-bisect-limit is reached"), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:114: constructor_uses_global_object: The constructor of global object "PrintPassNumbers" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintPassNumbers" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|       cl::desc("Print IR to path when opt-bisect-limit is reached"), cl::Hidden);
#  113|   
#  114|-> static cl::opt<bool> PrintPassNumbers(
#  115|       "print-pass-numbers", cl::init(false), cl::Hidden,
#  116|       cl::desc("Print pass names and their ordinals"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:119: constructor_uses_global_object: The constructor of global object "PrintAtPassNumber" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PrintAtPassNumber" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|   
#  118|   static cl::opt<unsigned>
#  119|->     PrintAtPassNumber("print-at-pass-number", cl::init(0), cl::Hidden,
#  120|                   cl::desc("Print IR at pass with this number as "
#  121|                            "reported by print-passes-names"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:133: constructor_uses_global_object: The constructor of global object "<unnamed>::TestChanged[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::TestChanged[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  131|   // The usual modifier options work as expected.
#  132|   static cl::opt<std::string>
#  133|->     TestChanged("exec-on-ir-change", cl::Hidden, cl::init(""),
#  134|                   cl::desc("exe called with module IR after each pass that "
#  135|                            "changes it"));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:1139: var_decl: Declaring variable "Functions".
llvm-17.0.6.src/lib/Passes/StandardInstrumentations.cpp:1147: uninit_use: Using uninitialized value "Functions". Field "Functions.InlineElts" is uninitialized.
# 1145|         Functions.push_back(&F);
# 1146|     }
# 1147|->   return Functions;
# 1148|   }
# 1149|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/InstrProf.cpp:61: constructor_uses_global_object: The constructor of global object "StaticFuncFullModulePrefix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StaticFuncFullModulePrefix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   59|   using namespace llvm;
#   60|   
#   61|-> static cl::opt<bool> StaticFuncFullModulePrefix(
#   62|       "static-func-full-module-prefix", cl::init(true), cl::Hidden,
#   63|       cl::desc("Use full module build paths in the profile counter names for "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/InstrProf.cpp:74: constructor_uses_global_object: The constructor of global object "StaticFuncStripDirNamePrefix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StaticFuncStripDirNamePrefix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   // the source directory name not being stripped. A non-zero option value here
#   73|   // can potentially prevent some inter-module indirect-call-promotions.
#   74|-> static cl::opt<unsigned> StaticFuncStripDirNamePrefix(
#   75|       "static-func-strip-dirname-prefix", cl::init(0), cl::Hidden,
#   76|       cl::desc("Strip specified level of directory name from source path in "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/InstrProf.cpp:213: constructor_uses_global_object: The constructor of global object "llvm::DoInstrProfNameCompression" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DoInstrProfNameCompression" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  211|   namespace llvm {
#  212|   
#  213|-> cl::opt<bool> DoInstrProfNameCompression(
#  214|       "enable-name-compression",
#  215|       cl::desc("Enable name/filename string compression"), cl::init(true));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ProfileData/InstrProf.cpp:1389: var_decl: Declaring variable "H" without initializer.
llvm-17.0.6.src/lib/ProfileData/InstrProf.cpp:1425: uninit_use_in_call: Using uninitialized value "H". Field "H.Unused" is uninitialized when calling "Expected".
# 1423|     }
# 1424|   
# 1425|->   return H;
# 1426|   }
# 1427|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/lib/ProfileData/InstrProfCorrelator.cpp:74: extract: Calling "get" which extracts wrapped state from temporary of type "std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >".
llvm-17.0.6.src/lib/ProfileData/InstrProfCorrelator.cpp:74: assign: Assigning: "<temporary>" = "llvm::InstrProfCorrelator::get(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >(std::move(*BufferOrErr)))".
llvm-17.0.6.src/lib/ProfileData/InstrProfCorrelator.cpp:74: escape: The internal representation of temporary of type "std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >" escapes, but is destroyed when it exits scope.
#   72|       return std::move(Err);
#   73|   
#   74|->   return get(std::move(*BufferOrErr));
#   75|   }
#   76|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ProfileData/MemProf.cpp:39: var_decl: Declaring variable "Record".
llvm-17.0.6.src/lib/ProfileData/MemProf.cpp:70: uninit_use: Using uninitialized value "Record". Field "Record.AllocSites.InlineElts" is uninitialized.
#   68|     }
#   69|   
#   70|->   return Record;
#   71|   }
#   72|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:22: constructor_uses_global_object: The constructor of global object "llvm::UseContextLessSummary" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::UseContextLessSummary" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   20|   
#   21|   namespace llvm {
#   22|-> cl::opt<bool> UseContextLessSummary(
#   23|       "profile-summary-contextless", cl::Hidden,
#   24|       cl::desc("Merge context profiles before calculating thresholds."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:33: constructor_uses_global_object: The constructor of global object "llvm::ProfileSummaryCutoffHot" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileSummaryCutoffHot" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   // threshold for determining cold count (everything <= this threshold is
#   32|   // considered cold).
#   33|-> cl::opt<int> ProfileSummaryCutoffHot(
#   34|       "profile-summary-cutoff-hot", cl::Hidden, cl::init(990000),
#   35|       cl::desc("A count is hot if it exceeds the minimum count to"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:38: constructor_uses_global_object: The constructor of global object "llvm::ProfileSummaryCutoffCold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileSummaryCutoffCold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|                " reach this percentile of total counts."));
#   37|   
#   38|-> cl::opt<int> ProfileSummaryCutoffCold(
#   39|       "profile-summary-cutoff-cold", cl::Hidden, cl::init(999999),
#   40|       cl::desc("A count is cold if it is below the minimum count"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:43: constructor_uses_global_object: The constructor of global object "llvm::ProfileSummaryHugeWorkingSetSizeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileSummaryHugeWorkingSetSizeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|                " to reach this percentile of total counts."));
#   42|   
#   43|-> cl::opt<unsigned> ProfileSummaryHugeWorkingSetSizeThreshold(
#   44|       "profile-summary-huge-working-set-size-threshold", cl::Hidden,
#   45|       cl::init(15000),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:50: constructor_uses_global_object: The constructor of global object "llvm::ProfileSummaryLargeWorkingSetSizeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileSummaryLargeWorkingSetSizeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|                " percentile exceeds this count."));
#   49|   
#   50|-> cl::opt<unsigned> ProfileSummaryLargeWorkingSetSizeThreshold(
#   51|       "profile-summary-large-working-set-size-threshold", cl::Hidden,
#   52|       cl::init(12500),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:59: constructor_uses_global_object: The constructor of global object "llvm::ProfileSummaryHotCount" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileSummaryHotCount" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|   // The next two options override the counts derived from summary computation and
#   58|   // are useful for debugging purposes.
#   59|-> cl::opt<uint64_t> ProfileSummaryHotCount(
#   60|       "profile-summary-hot-count", cl::ReallyHidden,
#   61|       cl::desc("A fixed hot count that overrides the count derived from"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/ProfileSummaryBuilder.cpp:64: constructor_uses_global_object: The constructor of global object "llvm::ProfileSummaryColdCount" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::ProfileSummaryColdCount" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   62|                " profile-summary-cutoff-hot"));
#   63|   
#   64|-> cl::opt<uint64_t> ProfileSummaryColdCount(
#   65|       "profile-summary-cold-count", cl::ReallyHidden,
#   66|       cl::desc("A fixed cold count that overrides the count derived from"

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ProfileData/RawMemProfReader.cpp:90: var_decl: Declaring variable "Items".
llvm-17.0.6.src/lib/ProfileData/RawMemProfReader.cpp:95: uninit_use: Using uninitialized value "Items". Field "Items.InlineElts" is uninitialized.
#   93|           Ptr + I * sizeof(SegmentEntry)));
#   94|     }
#   95|->   return Items;
#   96|   }
#   97|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/ProfileData/RawMemProfReader.cpp:104: var_decl: Declaring variable "Items".
llvm-17.0.6.src/lib/ProfileData/RawMemProfReader.cpp:112: uninit_use: Using uninitialized value "Items". Field "Items.InlineElts" is uninitialized.
#  110|       Ptr += sizeof(MemInfoBlock);
#  111|     }
#  112|->   return Items;
#  113|   }
#  114|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/SampleProf.cpp:30: constructor_uses_global_object: The constructor of global object "ProfileSymbolListCutOff" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ProfileSymbolListCutOff" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   using namespace sampleprof;
#   29|   
#   30|-> static cl::opt<uint64_t> ProfileSymbolListCutOff(
#   31|       "profile-symbol-list-cutoff", cl::Hidden, cl::init(-1),
#   32|       cl::desc("Cutoff value about how many symbols in profile symbol list "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/SampleProf.cpp:35: constructor_uses_global_object: The constructor of global object "GenerateMergedBaseProfiles" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GenerateMergedBaseProfiles" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|                "will be used. This is very useful for performance debugging"));
#   34|   
#   35|-> static cl::opt<bool> GenerateMergedBaseProfiles(
#   36|       "generate-merged-base-profiles",
#   37|       cl::desc("When generating nested context-sensitive profiles, always "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/ProfileData/SampleProfReader.cpp:56: constructor_uses_global_object: The constructor of global object "ProfileIsFSDisciminator" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ProfileIsFSDisciminator" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   // It only applies to text, and binary format profiles.
#   55|   // For ext-binary format profiles, the flag is set in the summary.
#   56|-> static cl::opt<bool> ProfileIsFSDisciminator(
#   57|       "profile-isfs", cl::Hidden, cl::init(false),
#   58|       cl::desc("Profile uses flow sensitive discriminators"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Remarks/RemarkStreamer.cpp:20: constructor_uses_global_object: The constructor of global object "EnableRemarksSection" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRemarksSection" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   18|   using namespace llvm::remarks;
#   19|   
#   20|-> static cl::opt<cl::boolOrDefault> EnableRemarksSection(
#   21|       "remarks-section",
#   22|       cl::desc(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFixedPoint.cpp:143: var_decl: Declaring variable "F".
llvm-17.0.6.src/lib/Support/APFixedPoint.cpp:144: uninit_use_in_call: Using uninitialized value "F.U" when calling "convertFromAPInt".
#  142|     APSInt MaxInt = APFixedPoint::getMax(*this).getValue();
#  143|     APFloat F(FloatSema);
#  144|->   APFloat::opStatus Status = F.convertFromAPInt(MaxInt, MaxInt.isSigned(),
#  145|                                                   APFloat::rmNearestTiesToAway);
#  146|     if ((Status & APFloat::opOverflow) || !isSigned())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFixedPoint.cpp:503: var_decl: Declaring variable "Flt".
llvm-17.0.6.src/lib/Support/APFixedPoint.cpp:504: uninit_use_in_call: Using uninitialized value "Flt.U" when calling "convertFromAPInt".
#  502|     // given mode.
#  503|     APFloat Flt(*OpSema);
#  504|->   APFloat::opStatus S = Flt.convertFromAPInt(Val, Sema.isSigned(), RM);
#  505|   
#  506|     // If we cared about checking for precision loss, we could look at this

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFixedPoint.cpp:581: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(std::pow(2, DstFXSema->getLsbWeight()))".
llvm-17.0.6.src/lib/Support/APFixedPoint.cpp:581: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  579|     // representable range of the fixed-point semantic even though no overflow
#  580|     // would occur had we rounded first.
#  581|->   ScaleFactor = APFloat(std::pow(2, DstFXSema.getLsbWeight()));
#  582|     ScaleFactor.convert(*OpSema, LosslessRM, &Ignored);
#  583|     Val.roundToIntegral(RM);

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Support/APFloat.cpp:749: assignment: Assigning: "n" = "0U".
llvm-17.0.6.src/lib/Support/APFloat.cpp:756: overrun-local: Overrunning array "partsCount" of 16 4-byte elements at element index 4294967295 (byte offset 17179869183) using index "n - 1U" (which evaluates to 4294967295).
#  754|       /* Calculate pow(5,pow(2,n+3)) if we haven't yet.  */
#  755|       if (pc == 0) {
#  756|->       pc = partsCount[n - 1];
#  757|         APInt::tcFullMultiply(pow5, pow5 - pc, pow5 - pc, pc, pc);
#  758|         pc *= 2;

Error: NO_EFFECT (CWE-398):
llvm-17.0.6.src/lib/Support/APFloat.cpp:3270: bad_memset: Function "memset" with fill value "'0'" (the zero character) in "memset(dst, 48, hexDigits - 1U)".
llvm-17.0.6.src/lib/Support/APFloat.cpp:3270: remediation: Did you intend to use 0 (the value zero)?
# 3268|       if (hexDigits > 1) {
# 3269|         *dst++ = '.';
# 3270|->       memset (dst, '0', hexDigits - 1);
# 3271|         dst += hexDigits - 1;
# 3272|       }

Error: NO_EFFECT (CWE-398):
llvm-17.0.6.src/lib/Support/APFloat.cpp:3374: bad_memset: Function "memset" with fill value "'0'" (the zero character) in "memset(dst, 48, outputDigits)".
llvm-17.0.6.src/lib/Support/APFloat.cpp:3374: remediation: Did you intend to use 0 (the value zero)?
# 3372|     } else {
# 3373|       /* Add trailing zeroes.  */
# 3374|->     memset (dst, '0', outputDigits);
# 3375|       dst += outputDigits;
# 3376|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4825: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(RHS->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4825: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4823|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4824|     APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());
# 4825|->   auto Ret =
# 4826|         Tmp.divide(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()), RM);
# 4827|     *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4834: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(RHS->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4834: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4832|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4833|     APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());
# 4834|->   auto Ret =
# 4835|         Tmp.remainder(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));
# 4836|     *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4843: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(RHS->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4843: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4841|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4842|     APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());
# 4843|->   auto Ret = Tmp.mod(APFloat(semPPCDoubleDoubleLegacy, RHS.bitcastToAPInt()));
# 4844|     *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());
# 4845|     return Ret;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4854: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(Addend->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4854: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4852|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4853|     APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());
# 4854|->   auto Ret = Tmp.fusedMultiplyAdd(
# 4855|         APFloat(semPPCDoubleDoubleLegacy, Multiplicand.bitcastToAPInt()),
# 4856|         APFloat(semPPCDoubleDoubleLegacy, Addend.bitcastToAPInt()), RM);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4913: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semIEEEdouble, llvm::APInt(64U, 9218868437227405311UL, false))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4913: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4911|   void DoubleAPFloat::makeLargest(bool Neg) {
# 4912|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4913|->   Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));
# 4914|     Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));
# 4915|     if (Neg)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4914: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semIEEEdouble, llvm::APInt(64U, 8975674057349398526UL, false))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4914: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4912|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4913|     Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x7fefffffffffffffull));
# 4914|->   Floats[1] = APFloat(semIEEEdouble, APInt(64, 0x7c8ffffffffffffeull));
# 4915|     if (Neg)
# 4916|       changeSign();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4927: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semIEEEdouble, llvm::APInt(64U, 243194379878006784UL, false))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4927: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4925|   void DoubleAPFloat::makeSmallestNormalized(bool Neg) {
# 4926|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4927|->   Floats[0] = APFloat(semIEEEdouble, APInt(64, 0x0360000000000000ull));
# 4928|     if (Neg)
# 4929|       Floats[0].changeSign();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:4988: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(this->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:4988: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4986|                                   roundingMode RM, bool *IsExact) const {
# 4987|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 4988|->   return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())
# 4989|         .convertToInteger(Input, Width, IsSigned, RM, IsExact);
# 4990|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5007: var_decl: Declaring variable "Tmp".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5008: uninit_use_in_call: Using uninitialized value "Tmp.U" when calling "convertFromSignExtendedInteger".
# 5006|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 5007|     APFloat Tmp(semPPCDoubleDoubleLegacy);
# 5008|->   auto Ret = Tmp.convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM);
# 5009|     *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());
# 5010|     return Ret;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5018: var_decl: Declaring variable "Tmp".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5019: uninit_use_in_call: Using uninitialized value "Tmp.U" when calling "convertFromZeroExtendedInteger".
# 5017|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 5018|     APFloat Tmp(semPPCDoubleDoubleLegacy);
# 5019|->   auto Ret = Tmp.convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM);
# 5020|     *this = DoubleAPFloat(semPPCDoubleDouble, Tmp.bitcastToAPInt());
# 5021|     return Ret;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5029: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(this->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5029: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5027|                                                  roundingMode RM) const {
# 5028|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 5029|->   return APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())
# 5030|         .convertToHexString(DST, HexDigits, UpperCase, RM);
# 5031|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5075: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDoubleLegacy, llvm::APInt(this->bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5075: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5073|                                bool TruncateZero) const {
# 5074|     assert(Semantics == &semPPCDoubleDouble && "Unexpected Semantics");
# 5075|->   APFloat(semPPCDoubleDoubleLegacy, bitcastToAPInt())
# 5076|         .toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero);
# 5077|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5081: var_decl: Declaring variable "Tmp".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5083: uninit_use_in_call: Using uninitialized value "Tmp.U" when calling "~APFloat".
# 5081|     APFloat Tmp(semPPCDoubleDoubleLegacy, bitcastToAPInt());
# 5082|     if (!inv)
# 5083|->     return Tmp.getExactInverse(nullptr);
# 5084|     APFloat Inv(semPPCDoubleDoubleLegacy);
# 5085|     auto Ret = Tmp.getExactInverse(&Inv);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5086: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semPPCDoubleDouble, llvm::APInt(Inv.bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5086: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5084|     APFloat Inv(semPPCDoubleDoubleLegacy);
# 5085|     auto Ret = Tmp.getExactInverse(&Inv);
# 5086|->   *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());
# 5087|     return Ret;
# 5088|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5081: var_decl: Declaring variable "Tmp".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5087: uninit_use_in_call: Using uninitialized value "Tmp.U" when calling "~APFloat".
# 5085|     auto Ret = Tmp.getExactInverse(&Inv);
# 5086|     *inv = APFloat(semPPCDoubleDouble, Inv.bitcastToAPInt());
# 5087|->   return Ret;
# 5088|   }
# 5089|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5116: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::semIEEEdouble)".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5116: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5114|     if (usesLayout<DoubleAPFloat>(Semantics)) {
# 5115|       const fltSemantics& S = F.getSemantics();
# 5116|->     new (&Double)
# 5117|           DoubleAPFloat(Semantics, APFloat(std::move(F), S),
# 5118|                         APFloat(semIEEEdouble));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5137: uninit_in_ctor: Fields of "this" are uninitialized at the beginning of the constructor.
llvm-17.0.6.src/lib/Support/APFloat.cpp:5139: uninit_use_in_call: Using uninitialized value "this->U" when calling "convertFromString".
# 5137|   APFloat::APFloat(const fltSemantics &Semantics, StringRef S)
# 5138|       : APFloat(Semantics) {
# 5139|->   auto StatusOrErr = convertFromString(S, rmNearestTiesToEven);
# 5140|     assert(StatusOrErr && "Invalid floating point representation");
# 5141|     consumeError(StatusOrErr.takeError());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/APFloat.cpp:5170: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(ToSemantics, llvm::APInt(this->U.IEEE.bitcastToAPInt()))".
llvm-17.0.6.src/lib/Support/APFloat.cpp:5170: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5168|       assert(&ToSemantics == &semPPCDoubleDouble);
# 5169|       auto Ret = U.IEEE.convert(semPPCDoubleDoubleLegacy, RM, losesInfo);
# 5170|->     *this = APFloat(ToSemantics, U.IEEE.bitcastToAPInt());
# 5171|       return Ret;
# 5172|     }

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Support/ConvertUTFWrapper.cpp:66: address_of: Taking address with "&Source" yields a singleton pointer.
llvm-17.0.6.src/lib/Support/ConvertUTFWrapper.cpp:66: assign: Assigning: "SourceStart" = "&Source".
llvm-17.0.6.src/lib/Support/ConvertUTFWrapper.cpp:67: ptr_arith: Using "SourceStart" as an array.  This might corrupt or misinterpret adjacent memory locations.
#   65|   bool ConvertCodePointToUTF8(unsigned Source, char *&ResultPtr) {
#   66|     const UTF32 *SourceStart = &Source;
#   67|->   const UTF32 *SourceEnd = SourceStart + 1;
#   68|     UTF8 *TargetStart = reinterpret_cast<UTF8 *>(ResultPtr);
#   69|     UTF8 *TargetEnd = TargetStart + 4;

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Support/DJB.cpp:31: address_of: Taking address with "&C" yields a singleton pointer.
llvm-17.0.6.src/lib/Support/DJB.cpp:31: ptr_arith: Using "&C" as an array.  This might corrupt or misinterpret adjacent memory locations.
#   29|     // non-empty input.
#   30|     assert(!Buffer.empty());
#   31|->   ConvertUTF8toUTF32(&Begin8, reinterpret_cast<const UTF8 *>(Buffer.end()),
#   32|                        &Begin32, &C + 1, lenientConversion);
#   33|     Buffer = Buffer.drop_front(Begin8 - Begin8Const);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Support/DJB.cpp:38: address_of: Taking address with "&C" yields a singleton pointer.
llvm-17.0.6.src/lib/Support/DJB.cpp:38: assign: Assigning: "Begin32" = "&C".
llvm-17.0.6.src/lib/Support/DJB.cpp:43: callee_ptr_arith: Passing "Begin32" via argument "&Begin32" to function "ConvertUTF32toUTF8" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#   41|     // The case-folded output should always be a valid unicode character, so use
#   42|     // strict mode here.
#   43|->   ConversionResult CR = ConvertUTF32toUTF8(&Begin32, &C + 1, &Begin8,
#   44|                                              Storage.end(), strictConversion);
#   45|     assert(CR == conversionOK && "Case folding produced invalid char?");

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Support/DJB.cpp:43: address_of: Taking address with "&C" yields a singleton pointer.
llvm-17.0.6.src/lib/Support/DJB.cpp:43: ptr_arith: Using "&C" as an array.  This might corrupt or misinterpret adjacent memory locations.
#   41|     // The case-folded output should always be a valid unicode character, so use
#   42|     // strict mode here.
#   43|->   ConversionResult CR = ConvertUTF32toUTF8(&Begin32, &C + 1, &Begin8,
#   44|                                              Storage.end(), strictConversion);
#   45|     assert(CR == conversionOK && "Case folding produced invalid char?");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/MD5.cpp:282: var_decl: Declaring variable "Str".
llvm-17.0.6.src/lib/Support/MD5.cpp:284: uninit_use: Using uninitialized value "Str". Field "Str.InlineElts" is uninitialized.
#  282|     SmallString<32> Str;
#  283|     toHex(*this, /*LowerCase*/ true, Str);
#  284|->   return Str;
#  285|   }
#  286|   

Error: NO_EFFECT (CWE-398):
llvm-17.0.6.src/lib/Support/NativeFormatting.cpp:151: bad_memset: Function "memset" with fill value "'0'" (the zero character) in "memset(NumberBuffer, 48, 128UL)".
llvm-17.0.6.src/lib/Support/NativeFormatting.cpp:151: remediation: Did you intend to use 0 (the value zero)?
#  149|   
#  150|     char NumberBuffer[kMaxWidth];
#  151|->   ::memset(NumberBuffer, '0', std::size(NumberBuffer));
#  152|     if (Prefix)
#  153|       NumberBuffer[1] = 'x';

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Parallel.cpp:125: var_decl: Declaring variable "Lock".
llvm-17.0.6.src/lib/Support/Parallel.cpp:140: uninit_use_in_call: Using uninitialized value "Lock._M_device" when calling "unlock".
llvm-17.0.6.src/lib/Support/Parallel.cpp:140: uninit_use_in_call: Using uninitialized value "Lock._M_owns" when calling "unlock".
#  138|         auto Task = std::move(Queue.back());
#  139|         Queue.pop_back();
#  140|->       Lock.unlock();
#  141|         Task();
#  142|         if (Sequential)

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Support/Path.cpp:1002: tainted_data_return: Called function "write(WriteFD, Buf, BytesRead)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Support/Path.cpp:1002: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Support/Path.cpp:1005: overflow: The expression "BytesRead" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Support/Path.cpp:1002: overflow_sink: "BytesRead", which might be negative, is passed to "write(WriteFD, Buf, BytesRead)".
# 1000|         break;
# 1001|       while (BytesRead) {
# 1002|->       BytesWritten = write(WriteFD, Buf, BytesRead);
# 1003|         if (BytesWritten < 0)
# 1004|           break;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/Path.cpp:1020: open_arg: "openFileForRead" opens handle stored into "ReadFD".
llvm-17.0.6.src/lib/Support/Path.cpp:1021: leaked_handle: Handle variable "ReadFD" going out of scope leaks the handle.
# 1019|     int ReadFD, WriteFD;
# 1020|     if (std::error_code EC = openFileForRead(From, ReadFD, OF_None))
# 1021|->     return EC;
# 1022|     if (std::error_code EC =
# 1023|             openFileForWrite(To, WriteFD, CD_CreateAlways, OF_None)) {

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/Path.cpp:1039: open_arg: "openFileForRead" opens handle stored into "ReadFD".
llvm-17.0.6.src/lib/Support/Path.cpp:1040: leaked_handle: Handle variable "ReadFD" going out of scope leaks the handle.
# 1038|     int ReadFD;
# 1039|     if (std::error_code EC = openFileForRead(From, ReadFD, OF_None))
# 1040|->     return EC;
# 1041|   
# 1042|     std::error_code EC = copy_file_internal(ReadFD, ToFD);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/Path.cpp:1071: open_arg: "openFileForRead" opens handle stored into "FD".
llvm-17.0.6.src/lib/Support/Path.cpp:1072: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
# 1070|     int FD;
# 1071|     if (auto EC = openFileForRead(Path, FD, OF_None))
# 1072|->     return EC;
# 1073|   
# 1074|     auto Result = md5_contents(FD);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/ScaledNumber.cpp:185: var_decl: Declaring variable "Float".
llvm-17.0.6.src/lib/Support/ScaledNumber.cpp:187: uninit_use_in_call: Using uninitialized value "Float.U" when calling "toString".
#  185|     APFloat Float(APFloat::x87DoubleExtended(), APInt(80, RawBits));
#  186|     SmallVector<char, 24> Chars;
#  187|->   Float.toString(Chars, Precision, 0);
#  188|     return std::string(Chars.begin(), Chars.end());
#  189|   }

Error: CTOR_DTOR_LEAK (CWE-401):
llvm-17.0.6.src/lib/Support/StringMap.cpp:54: alloc_fn: Calling allocation function "init".
llvm-17.0.6.src/lib/Support/StringMap.cpp:54: ctor_dtor_leak: The constructor allocates field "TheTable" of "llvm::StringMapImpl" but there is no destructor.
#   52|       // buckets. To guarantee that "InitSize" number of entries can be inserted
#   53|       // in the table without growing, we allocate just what is needed here.
#   54|->     init(getMinBucketToReserveForEntries(InitSize));
#   55|       return;
#   56|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/StringRef.cpp:605: var_decl: Declaring variable "F".
llvm-17.0.6.src/lib/Support/StringRef.cpp:606: uninit_use_in_call: Using uninitialized value "F.U" when calling "convertFromString".
#  604|   bool StringRef::getAsDouble(double &Result, bool AllowInexact) const {
#  605|     APFloat F(0.0);
#  606|->   auto StatusOrErr = F.convertFromString(*this, APFloat::rmNearestTiesToEven);
#  607|     if (errorToBool(StatusOrErr.takeError()))
#  608|       return true;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/Unix/Path.inc:1119: open_arg: "openFile" opens handle stored into "FD".
llvm-17.0.6.src/lib/Support/Unix/Path.inc:1121: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
# 1119|     std::error_code EC = openFile(Name, FD, Disp, Access, Flags, Mode);
# 1120|     if (EC)
# 1121|->     return errorCodeToError(EC);
# 1122|     return FD;
# 1123|   }

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/Unix/Path.inc:1170: open_arg: "openFileForRead" opens handle stored into "ResultFD".
llvm-17.0.6.src/lib/Support/Unix/Path.inc:1172: leaked_handle: Handle variable "ResultFD" going out of scope leaks the handle.
# 1170|     std::error_code EC = openFileForRead(Name, ResultFD, Flags, RealPath);
# 1171|     if (EC)
# 1172|->     return errorCodeToError(EC);
# 1173|     return ResultFD;
# 1174|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Unix/Program.inc:416: var_decl: Declaring variable "WaitResult".
llvm-17.0.6.src/lib/Support/Unix/Program.inc:428: uninit_use: Using uninitialized value "WaitResult". Field "WaitResult.Process" is uninitialized.
#  426|       if (WaitResult.Pid == 0) {
#  427|         // Non-blocking wait.
#  428|->       return WaitResult;
#  429|       } else {
#  430|         if (SecondsToWait && errno == EINTR && !Polling) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Unix/Program.inc:416: var_decl: Declaring variable "WaitResult".
llvm-17.0.6.src/lib/Support/Unix/Program.inc:447: uninit_use: Using uninitialized value "WaitResult". Field "WaitResult.Process" is uninitialized.
#  445|   
#  446|           WaitResult.ReturnCode = -2; // Timeout detected
#  447|->         return WaitResult;
#  448|         } else if (errno != EINTR) {
#  449|           MakeErrMsg(ErrMsg, "Error waiting for child process");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Unix/Program.inc:416: var_decl: Declaring variable "WaitResult".
llvm-17.0.6.src/lib/Support/Unix/Program.inc:451: uninit_use: Using uninitialized value "WaitResult". Field "WaitResult.Process" is uninitialized.
#  449|           MakeErrMsg(ErrMsg, "Error waiting for child process");
#  450|           WaitResult.ReturnCode = -1;
#  451|->         return WaitResult;
#  452|         }
#  453|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Unix/Program.inc:416: var_decl: Declaring variable "WaitResult".
llvm-17.0.6.src/lib/Support/Unix/Program.inc:483: uninit_use: Using uninitialized value "WaitResult". Field "WaitResult.Process" is uninitialized.
#  481|           *ErrMsg = llvm::sys::StrError(ENOENT);
#  482|         WaitResult.ReturnCode = -1;
#  483|->       return WaitResult;
#  484|       }
#  485|       if (result == 126) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Unix/Program.inc:416: var_decl: Declaring variable "WaitResult".
llvm-17.0.6.src/lib/Support/Unix/Program.inc:489: uninit_use: Using uninitialized value "WaitResult". Field "WaitResult.Process" is uninitialized.
#  487|           *ErrMsg = "Program could not be executed";
#  488|         WaitResult.ReturnCode = -1;
#  489|->       return WaitResult;
#  490|       }
#  491|     } else if (WIFSIGNALED(status)) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Support/Unix/Program.inc:416: var_decl: Declaring variable "WaitResult".
llvm-17.0.6.src/lib/Support/Unix/Program.inc:503: uninit_use: Using uninitialized value "WaitResult". Field "WaitResult.Process" is uninitialized.
#  501|       WaitResult.ReturnCode = -2;
#  502|     }
#  503|->   return WaitResult;
#  504|   }
#  505|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:122: alloc_fn: Storage is returned from allocation function "operator new".
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:122: var_assign: Assigning: "NewHead" = storage returned from "new <unnamed>::FileToRemoveList(Filename)".
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:125: noescape: Resource "NewHead" is not freed or pointed-to in "compare_exchange_strong".
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:129: leaked_storage: Variable "NewHead" going out of scope leaks the storage it points to.
#  127|         OldHead = nullptr;
#  128|       }
#  129|->   }
#  130|   
#  131|     // Not signal-safe.

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:267: tainted_data_return: Called function "sysconf(_SC_SIGSTKSZ)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:267: overflow: The expression "sysconf(_SC_SIGSTKSZ) + 65536L" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:267: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Support/Unix/Signals.inc:279: overflow_sink: "AltStackSize", which might be negative, is passed to "llvm::safe_malloc(AltStackSize)".
#  277|   
#  278|     stack_t AltStack = {};
#  279|->   AltStack.ss_sp = static_cast<char *>(safe_malloc(AltStackSize));
#  280|     NewAltStackPointer = AltStack.ss_sp; // Save to avoid reporting a leak.
#  281|     AltStack.ss_size = AltStackSize;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Support/raw_ostream.cpp:589: open_arg: "openFileForReadWrite" opens handle stored into "FD".
llvm-17.0.6.src/lib/Support/raw_ostream.cpp:593: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
#  591|       EC = sys::fs::openFileForWrite(Filename, FD, Disp, Flags);
#  592|     if (EC)
#  593|->     return -1;
#  594|   
#  595|     return FD;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:41: constructor_uses_global_object: The constructor of global object "OutputFilename[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OutputFilename[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   
#   40|   static cl::opt<std::string>
#   41|-> OutputFilename("o", cl::desc("Output filename"), cl::value_desc("filename"),
#   42|                  cl::init("-"));
#   43|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:45: constructor_uses_global_object: The constructor of global object "DependFilename[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DependFilename[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|   
#   44|   static cl::opt<std::string>
#   45|-> DependFilename("d",
#   46|                  cl::desc("Dependency filename"),
#   47|                  cl::value_desc("filename"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:51: constructor_uses_global_object: The constructor of global object "InputFilename[abi:cxx11]" itself makes use of global object "GlobalParser" defined in another compilation unit.  The order of construction is unspecified, so "InputFilename[abi:cxx11]" might be created before "GlobalParser" is available.
#   49|   
#   50|   static cl::opt<std::string>
#   51|-> InputFilename(cl::Positional, cl::desc("<input file>"), cl::init("-"));
#   52|   
#   53|   static cl::list<std::string>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:54: constructor_uses_global_object: The constructor of global object "IncludeDirs[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IncludeDirs[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   
#   53|   static cl::list<std::string>
#   54|-> IncludeDirs("I", cl::desc("Directory of include files"),
#   55|               cl::value_desc("directory"), cl::Prefix);
#   56|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:58: constructor_uses_global_object: The constructor of global object "MacroNames[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MacroNames[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|   
#   57|   static cl::list<std::string>
#   58|-> MacroNames("D", cl::desc("Name of the macro to be defined"),
#   59|               cl::value_desc("macro name"), cl::Prefix);
#   60|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:62: constructor_uses_global_object: The constructor of global object "WriteIfChanged" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "WriteIfChanged" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   
#   61|   static cl::opt<bool>
#   62|-> WriteIfChanged("write-if-changed", cl::desc("Only write output if it changed"));
#   63|   
#   64|   static cl::opt<bool>

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:65: constructor_uses_global_object: The constructor of global object "TimePhases" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TimePhases" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|   
#   64|   static cl::opt<bool>
#   65|-> TimePhases("time-phases", cl::desc("Time phases of parser and backend"));
#   66|   
#   67|   static cl::opt<bool> NoWarnOnUnusedTemplateArgs(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/Main.cpp:67: constructor_uses_global_object: The constructor of global object "NoWarnOnUnusedTemplateArgs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoWarnOnUnusedTemplateArgs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   TimePhases("time-phases", cl::desc("Time phases of parser and backend"));
#   66|   
#   67|-> static cl::opt<bool> NoWarnOnUnusedTemplateArgs(
#   68|       "no-warn-on-unused-template-args",
#   69|       cl::desc("Disable unused template argument warnings."));

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/TableGen/Record.cpp:239: new_object: Calling single-object form of 'new': "new (Mem) llvm::RecordRecTy(RK, Classes.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:239: assign: Assigning: "Ty" = "new (Mem) llvm::RecordRecTy(RK, Classes.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:240: callee_ptr_arith: Passing "Ty" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  238|         totalSizeToAlloc<Record *>(Classes.size()), alignof(RecordRecTy));
#  239|     RecordRecTy *Ty = new (Mem) RecordRecTy(RK, Classes.size());
#  240|->   std::uninitialized_copy(Classes.begin(), Classes.end(),
#  241|                             Ty->getTrailingObjects<Record *>());
#  242|     ThePool.InsertNode(Ty, IP);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/TableGen/Record.cpp:447: new_object: Calling single-object form of 'new': "new (Mem) llvm::BitsInit(RK, Range.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:447: assign: Assigning: "I" = "new (Mem) llvm::BitsInit(RK, Range.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:448: callee_ptr_arith: Passing "I" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  446|                                           alignof(BitsInit));
#  447|     BitsInit *I = new (Mem) BitsInit(RK, Range.size());
#  448|->   std::uninitialized_copy(Range.begin(), Range.end(),
#  449|                             I->getTrailingObjects<Init *>());
#  450|     RKImpl.TheBitsInitPool.InsertNode(I, IP);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/TableGen/Record.cpp:674: new_object: Calling single-object form of 'new': "new (Mem) llvm::ListInit(Range.size(), EltTy)".
llvm-17.0.6.src/lib/TableGen/Record.cpp:674: assign: Assigning: "I" = "new (Mem) llvm::ListInit(Range.size(), EltTy)".
llvm-17.0.6.src/lib/TableGen/Record.cpp:675: callee_ptr_arith: Passing "I" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  673|                                       alignof(ListInit));
#  674|     ListInit *I = new (Mem) ListInit(Range.size(), EltTy);
#  675|->   std::uninitialized_copy(Range.begin(), Range.end(),
#  676|                             I->getTrailingObjects<Init *>());
#  677|     RK.TheListInitPool.InsertNode(I, IP);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/TableGen/Record.cpp:2199: new_object: Calling single-object form of 'new': "new (Mem) llvm::VarDefInit(Class, Args.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:2199: assign: Assigning: "I" = "new (Mem) llvm::VarDefInit(Class, Args.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:2200: callee_ptr_arith: Passing "I" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 2198|         totalSizeToAlloc<ArgumentInit *>(Args.size()), alignof(VarDefInit));
# 2199|     VarDefInit *I = new (Mem) VarDefInit(Class, Args.size());
# 2200|->   std::uninitialized_copy(Args.begin(), Args.end(),
# 2201|                             I->getTrailingObjects<ArgumentInit *>());
# 2202|     RK.TheVarDefInitPool.InsertNode(I, IP);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/TableGen/Record.cpp:2391: new_object: Calling single-object form of 'new': "new (Mem) llvm::CondOpInit(CondRange.size(), Ty)".
llvm-17.0.6.src/lib/TableGen/Record.cpp:2391: assign: Assigning: "I" = "new (Mem) llvm::CondOpInit(CondRange.size(), Ty)".
llvm-17.0.6.src/lib/TableGen/Record.cpp:2393: callee_ptr_arith: Passing "I" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 2391|     CondOpInit *I = new(Mem) CondOpInit(CondRange.size(), Ty);
# 2392|   
# 2393|->   std::uninitialized_copy(CondRange.begin(), CondRange.end(),
# 2394|                             I->getTrailingObjects<Init *>());
# 2395|     std::uninitialized_copy(ValRange.begin(), ValRange.end(),

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/TableGen/Record.cpp:2515: new_object: Calling single-object form of 'new': "new (Mem) llvm::DagInit(V, VN, ArgRange.size(), NameRange.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:2515: assign: Assigning: "I" = "new (Mem) llvm::DagInit(V, VN, ArgRange.size(), NameRange.size())".
llvm-17.0.6.src/lib/TableGen/Record.cpp:2516: callee_ptr_arith: Passing "I" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
# 2514|         alignof(BitsInit));
# 2515|     DagInit *I = new (Mem) DagInit(V, VN, ArgRange.size(), NameRange.size());
# 2516|->   std::uninitialized_copy(ArgRange.begin(), ArgRange.end(),
# 2517|                             I->getTrailingObjects<Init *>());
# 2518|     std::uninitialized_copy(NameRange.begin(), NameRange.end(),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:742: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:751: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  749|       Result.Rec = ParseClassID();
#  750|     }
#  751|->   if (!Result.Rec) return Result;
#  752|   
#  753|     // If there is no template arg list, we're done.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:742: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:756: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  754|     if (!consume(tgtok::less)) {
#  755|       Result.RefRange.End = Lex.getLoc();
#  756|->     return Result;
#  757|     }
#  758|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:742: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:762: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  760|                                   isDefm)) {
#  761|       Result.Rec = nullptr; // Error parsing value list.
#  762|->     return Result;
#  763|     }
#  764|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:742: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:772: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  770|   
#  771|     Result.RefRange.End = Lex.getLoc();
#  772|->   return Result;
#  773|   }
#  774|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:784: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:788: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  786|   
#  787|     Result.MC = ParseMultiClassID();
#  788|->   if (!Result.MC) return Result;
#  789|   
#  790|     // If there is no template arg list, we're done.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:784: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:793: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  791|     if (!consume(tgtok::less)) {
#  792|       Result.RefRange.End = Lex.getLoc();
#  793|->     return Result;
#  794|     }
#  795|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:784: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:799: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  797|                                   &Result.MC->Rec, true)) {
#  798|       Result.MC = nullptr; // Error parsing value list.
#  799|->     return Result;
#  800|     }
#  801|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:784: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/TableGen/TGParser.cpp:804: uninit_use: Using uninitialized value "Result". Field "Result.TemplateArgs.InlineElts" is uninitialized.
#  802|     Result.RefRange.End = Lex.getLoc();
#  803|   
#  804|->   return Result;
#  805|   }
#  806|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/TableGenBackendSkeleton.cpp:64: constructor_uses_global_object: The constructor of global object "Y" itself makes use of global object "llvm::TableGen::Emitter::Action" defined in another compilation unit.  The order of construction is unspecified, so "Y" might be created before "llvm::TableGen::Emitter::Action" is available.
#   62|   }
#   63|   
#   64|-> static TableGen::Emitter::Opt Y("gen-skeleton-entry", EmitSkeleton,
#   65|                                   "Generate example skeleton entry");

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/TableGen/TableGenBackendSkeleton.cpp:64: constructor_uses_global_object: The constructor of global object "Y" itself makes use of global object "llvm::cl::AllSubCommands" defined in another compilation unit.  The order of construction is unspecified, so "Y" might be created before "llvm::cl::AllSubCommands" is available.
#   62|   }
#   63|   
#   64|-> static TableGen::Emitter::Opt Y("gen-skeleton-entry", EmitSkeleton,
#   65|                                   "Generate example skeleton entry");

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:52: constructor_uses_global_object: The constructor of global object "TransformAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TransformAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|   // destination register is the correct color. Used for testing.
#   51|   static cl::opt<bool>
#   52|-> TransformAll("aarch64-a57-fp-load-balancing-force-all",
#   53|                cl::desc("Always modify dest registers regardless of color"),
#   54|                cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:59: constructor_uses_global_object: The constructor of global object "OverrideBalance" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OverrideBalance" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|   // color always. Used for testing.
#   58|   static cl::opt<unsigned>
#   59|-> OverrideBalance("aarch64-a57-fp-load-balancing-override",
#   60|                 cl::desc("Ignore balance information, always return "
#   61|                          "(1: Even, 2: Odd)."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp:54: constructor_uses_global_object: The constructor of global object "TransformAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TransformAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   // them. For stress-testing the transformation function.
#   53|   static cl::opt<bool>
#   54|-> TransformAll("aarch64-simd-scalar-force-all",
#   55|                cl::desc("Force use of AdvSIMD scalar instructions everywhere"),
#   56|                cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ConditionalCompares.cpp:46: constructor_uses_global_object: The constructor of global object "BlockInstrLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BlockInstrLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   // Absolute maximum number of instructions allowed per speculated block.
#   45|   // This bypasses all other heuristics, so it should be set fairly high.
#   46|-> static cl::opt<unsigned> BlockInstrLimit(
#   47|       "aarch64-ccmp-limit", cl::init(30), cl::Hidden,
#   48|       cl::desc("Maximum number of instructions per speculated block."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ConditionalCompares.cpp:51: constructor_uses_global_object: The constructor of global object "Stress" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Stress" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|   
#   50|   // Stress testing mode - disable heuristics.
#   51|-> static cl::opt<bool> Stress("aarch64-stress-ccmp", cl::Hidden,
#   52|                               cl::desc("Turn all knobs to 11"));
#   53|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64FrameLowering.cpp:238: constructor_uses_global_object: The constructor of global object "EnableRedZone" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRedZone" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  236|   #define DEBUG_TYPE "frame-info"
#  237|   
#  238|-> static cl::opt<bool> EnableRedZone("aarch64-redzone",
#  239|                                      cl::desc("enable use of redzone on AArch64"),
#  240|                                      cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64FrameLowering.cpp:243: constructor_uses_global_object: The constructor of global object "ReverseCSRRestoreSeq" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReverseCSRRestoreSeq" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  241|   
#  242|   static cl::opt<bool>
#  243|->     ReverseCSRRestoreSeq("reverse-csr-restore-seq",
#  244|                            cl::desc("reverse the CSR restore sequence"),
#  245|                            cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64FrameLowering.cpp:247: constructor_uses_global_object: The constructor of global object "StackTaggingMergeSetTag" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "StackTaggingMergeSetTag" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  245|                            cl::init(false), cl::Hidden);
#  246|   
#  247|-> static cl::opt<bool> StackTaggingMergeSetTag(
#  248|       "stack-tagging-merge-settag",
#  249|       cl::desc("merge settag instruction in function epilog"), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64FrameLowering.cpp:252: constructor_uses_global_object: The constructor of global object "OrderFrameObjects" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OrderFrameObjects" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  250|       cl::Hidden);
#  251|   
#  252|-> static cl::opt<bool> OrderFrameObjects("aarch64-order-frame-objects",
#  253|                                          cl::desc("sort stack allocations"),
#  254|                                          cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64FrameLowering.cpp:256: constructor_uses_global_object: The constructor of global object "EnableHomogeneousPrologEpilog" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableHomogeneousPrologEpilog" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  254|                                          cl::init(true), cl::Hidden);
#  255|   
#  256|-> cl::opt<bool> EnableHomogeneousPrologEpilog(
#  257|       "homogeneous-prolog-epilog", cl::Hidden,
#  258|       cl::desc("Emit homogeneous prologue and epilogue for the size "

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:961: overrun-call: Overrunning callee's array of size 8 by passing argument "llvm::cast(Use)->getSuccessOrdering()" (which evaluates to 15) in call to "isStrongerThanMonotonic".
#  959|       // ldar and stlr have much more restrictive addressing modes (just a
#  960|       // register).
#  961|->     if (isStrongerThanMonotonic(cast<MemSDNode>(Use)->getSuccessOrdering()))
#  962|         return false;
#  963|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:3631: var_decl: Declaring variable "FVal".
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:3638: uninit_use_in_call: Using uninitialized value "FVal.U" when calling "~APFloat".
# 3636|       if (LN->getOperand(1).getOpcode() != AArch64ISD::ADDlow ||
# 3637|           !isa<ConstantPoolSDNode>(LN->getOperand(1)->getOperand(1)))
# 3638|->       return false;
# 3639|   
# 3640|       ConstantPoolSDNode *CN =

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:114: constructor_uses_global_object: The constructor of global object "EnableAArch64ELFLocalDynamicTLSGeneration" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAArch64ELFLocalDynamicTLSGeneration" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|   // well in the GNU bfd and gold linkers at the moment. Therefore, by
#  113|   // default, for now, fall back to GeneralDynamic code generation.
#  114|-> cl::opt<bool> EnableAArch64ELFLocalDynamicTLSGeneration(
#  115|       "aarch64-elf-ldtls-generation", cl::Hidden,
#  116|       cl::desc("Allow AArch64 Local Dynamic TLS code generation"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:120: constructor_uses_global_object: The constructor of global object "EnableOptimizeLogicalImm" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableOptimizeLogicalImm" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  118|   
#  119|   static cl::opt<bool>
#  120|-> EnableOptimizeLogicalImm("aarch64-enable-logical-imm", cl::Hidden,
#  121|                            cl::desc("Enable AArch64 logical imm instruction "
#  122|                                     "optimization"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:130: constructor_uses_global_object: The constructor of global object "EnableCombineMGatherIntrinsics" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCombineMGatherIntrinsics" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|   // than the GLD1 nodes added for the SVE gather load intrinsics.
#  129|   static cl::opt<bool>
#  130|-> EnableCombineMGatherIntrinsics("aarch64-enable-mgather-combine", cl::Hidden,
#  131|                                   cl::desc("Combine extends of AArch64 masked "
#  132|                                            "gather intrinsics"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:138: constructor_uses_global_object: The constructor of global object "MaxXors" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxXors" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  136|   // bottleneck after this transform on high end CPU. So this max leaf node
#  137|   // limitation is guard cmp+ccmp will be profitable.
#  138|-> static cl::opt<unsigned> MaxXors("aarch64-max-xors", cl::init(16), cl::Hidden,
#  139|                                    cl::desc("Maximum of xors"));
#  140|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:60: constructor_uses_global_object: The constructor of global object "TBZDisplacementBits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "TBZDisplacementBits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|   #include "AArch64GenInstrInfo.inc"
#   59|   
#   60|-> static cl::opt<unsigned> TBZDisplacementBits(
#   61|       "aarch64-tbz-offset-bits", cl::Hidden, cl::init(14),
#   62|       cl::desc("Restrict range of TB[N]Z instructions (DEBUG)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:64: constructor_uses_global_object: The constructor of global object "CBZDisplacementBits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CBZDisplacementBits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   62|       cl::desc("Restrict range of TB[N]Z instructions (DEBUG)"));
#   63|   
#   64|-> static cl::opt<unsigned> CBZDisplacementBits(
#   65|       "aarch64-cbz-offset-bits", cl::Hidden, cl::init(19),
#   66|       cl::desc("Restrict range of CB[N]Z instructions (DEBUG)"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:69: constructor_uses_global_object: The constructor of global object "BCCDisplacementBits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BCCDisplacementBits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|   
#   68|   static cl::opt<unsigned>
#   69|->     BCCDisplacementBits("aarch64-bcc-offset-bits", cl::Hidden, cl::init(19),
#   70|                           cl::desc("Restrict range of Bcc instructions (DEBUG)"));
#   71|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7276: extract: Calling "operator []" which extracts wrapped state from parameter "RepeatedSequenceLocs".
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7276: assign: Assigning: "FirstCand" = "RepeatedSequenceLocs[0UL]".
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7565: invalidate: Calling "operator =" invalidates the internal representation of parameter "RepeatedSequenceLocs".
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7639: use_after_free: Using invalidated internal representation of parameter "RepeatedSequenceLocs".
# 7637|       // link register.
# 7638|       bool ModStackToSaveLR = false;
# 7639|->     if (std::any_of(FirstCand.front(), FirstCand.back(),
# 7640|                       [](const MachineInstr &MI) { return MI.isCall(); }))
# 7641|         ModStackToSaveLR = true;
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7639: note: trimmed 1 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7708: var_decl: Declaring variable "Ranges".
llvm-17.0.6.src/lib/Target/AArch64/AArch64InstrInfo.cpp:7782: uninit_use: Using uninitialized value "Ranges". Field "Ranges.InlineElts" is uninitialized.
# 7780|     // If we exhausted the entire block, we have no safe ranges to outline.
# 7781|     if (FirstPossibleEndPt == MBB.instr_rend())
# 7782|->     return Ranges;
# 7783|     // Current range.
# 7784|     CreateNewRangeStartingAt(FirstPossibleEndPt->getIterator());

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:71: constructor_uses_global_object: The constructor of global object "LdStLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LdStLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|   
#   70|   // The LdStLimit limits how far we search for load/store pairs.
#   71|-> static cl::opt<unsigned> LdStLimit("aarch64-load-store-scan-limit",
#   72|                                      cl::init(20), cl::Hidden);
#   73|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:76: constructor_uses_global_object: The constructor of global object "UpdateLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UpdateLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   74|   // The UpdateLimit limits how far we search for update instructions when we form
#   75|   // pre-/post-index instructions.
#   76|-> static cl::opt<unsigned> UpdateLimit("aarch64-update-scan-limit", cl::init(100),
#   77|                                        cl::Hidden);
#   78|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:80: constructor_uses_global_object: The constructor of global object "EnableRenaming" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRenaming" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   78|   
#   79|   // Enable register renaming to find additional store pairing opportunities.
#   80|-> static cl::opt<bool> EnableRenaming("aarch64-load-store-renaming",
#   81|                                       cl::init(true), cl::Hidden);
#   82|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp:37: constructor_uses_global_object: The constructor of global object "FrameHelperSizeThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FrameHelperSizeThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|     "AArch64 homogeneous prolog/epilog lowering pass"
#   36|   
#   37|-> cl::opt<int> FrameHelperSizeThreshold(
#   38|       "frame-helper-size-threshold", cl::init(2), cl::Hidden,
#   39|       cl::desc("The minimum number of instructions that are outlined in a frame "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64PromoteConstant.cpp:56: constructor_uses_global_object: The constructor of global object "Stress" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Stress" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   
#   55|   // Stress testing mode - disable heuristics.
#   56|-> static cl::opt<bool> Stress("aarch64-stress-promote-const", cl::Hidden,
#   57|                               cl::desc("Promote all vector constants"));
#   58|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/AArch64SLSHardening.cpp:364: assignment: Assigning: "FirstOpIdxToRemove" = "std::max(ImpLROpIdx, ImpSPOpIdx)". The value of "FirstOpIdxToRemove" is now -1.
llvm-17.0.6.src/lib/Target/AArch64/AArch64SLSHardening.cpp:366: overrun-buffer-arg: Calling "removeOperand" with "BL->Operands" and "FirstOpIdxToRemove" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  364|     int FirstOpIdxToRemove = std::max(ImpLROpIdx, ImpSPOpIdx);
#  365|     int SecondOpIdxToRemove = std::min(ImpLROpIdx, ImpSPOpIdx);
#  366|->   BL->removeOperand(FirstOpIdxToRemove);
#  367|     BL->removeOperand(SecondOpIdxToRemove);
#  368|     // Now copy over the implicit operands from the original BLR

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/AArch64SLSHardening.cpp:365: assignment: Assigning: "SecondOpIdxToRemove" = "std::min(ImpLROpIdx, ImpSPOpIdx)". The value of "SecondOpIdxToRemove" is now -1.
llvm-17.0.6.src/lib/Target/AArch64/AArch64SLSHardening.cpp:367: overrun-buffer-arg: Calling "removeOperand" with "BL->Operands" and "SecondOpIdxToRemove" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  365|     int SecondOpIdxToRemove = std::min(ImpLROpIdx, ImpSPOpIdx);
#  366|     BL->removeOperand(FirstOpIdxToRemove);
#  367|->   BL->removeOperand(SecondOpIdxToRemove);
#  368|     // Now copy over the implicit operands from the original BLR
#  369|     BL->copyImplicitOps(MF, BLR);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64SpeculationHardening.cpp:119: constructor_uses_global_object: The constructor of global object "HardenLoads" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "HardenLoads" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|   #define AARCH64_SPECULATION_HARDENING_NAME "AArch64 speculation hardening pass"
#  118|   
#  119|-> static cl::opt<bool> HardenLoads("aarch64-slh-loads", cl::Hidden,
#  120|                                    cl::desc("Sanitize loads from memory."),
#  121|                                    cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTagging.cpp:66: constructor_uses_global_object: The constructor of global object "ClMergeInit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClMergeInit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   64|   #define DEBUG_TYPE "aarch64-stack-tagging"
#   65|   
#   66|-> static cl::opt<bool> ClMergeInit(
#   67|       "stack-tagging-merge-init", cl::Hidden, cl::init(true),
#   68|       cl::desc("merge stack variable initializers with tagging when possible"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTagging.cpp:71: constructor_uses_global_object: The constructor of global object "ClUseStackSafety" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClUseStackSafety" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|   
#   70|   static cl::opt<bool>
#   71|->     ClUseStackSafety("stack-tagging-use-stack-safety", cl::Hidden,
#   72|                        cl::init(true),
#   73|                        cl::desc("Use Stack Safety analysis results"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTagging.cpp:75: constructor_uses_global_object: The constructor of global object "ClScanLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClScanLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   73|                        cl::desc("Use Stack Safety analysis results"));
#   74|   
#   75|-> static cl::opt<unsigned> ClScanLimit("stack-tagging-merge-init-scan-limit",
#   76|                                        cl::init(40), cl::Hidden);
#   77|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTagging.cpp:79: constructor_uses_global_object: The constructor of global object "ClMergeInitSizeLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClMergeInitSizeLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   
#   78|   static cl::opt<unsigned>
#   79|->     ClMergeInitSizeLimit("stack-tagging-merge-init-size-limit", cl::init(272),
#   80|                            cl::Hidden);
#   81|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTagging.cpp:82: constructor_uses_global_object: The constructor of global object "ClMaxLifetimes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClMaxLifetimes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|                            cl::Hidden);
#   81|   
#   82|-> static cl::opt<size_t> ClMaxLifetimes(
#   83|       "stack-tagging-max-lifetimes-for-alloca", cl::Hidden, cl::init(3),
#   84|       cl::ReallyHidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp:38: constructor_uses_global_object: The constructor of global object "ClUncheckedLdSt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClUncheckedLdSt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   enum UncheckedLdStMode { UncheckedNever, UncheckedSafe, UncheckedAlways };
#   37|   
#   38|-> cl::opt<UncheckedLdStMode> ClUncheckedLdSt(
#   39|       "stack-tagging-unchecked-ld-st", cl::Hidden,
#   40|       cl::init(UncheckedSafe),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp:52: constructor_uses_global_object: The constructor of global object "ClFirstSlot" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ClFirstSlot" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|   
#   51|   static cl::opt<bool>
#   52|->     ClFirstSlot("stack-tagging-first-slot-opt", cl::Hidden, cl::init(true),
#   53|                   cl::desc("Apply first slot optimization for stack tagging "
#   54|                            "(eliminate ADDG Rt, Rn, 0, 0)."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:38: constructor_uses_global_object: The constructor of global object "EnableEarlyIfConvert" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableEarlyIfConvert" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   
#   37|   static cl::opt<bool>
#   38|-> EnableEarlyIfConvert("aarch64-early-ifcvt", cl::desc("Enable the early if "
#   39|                        "converter pass"), cl::init(true), cl::Hidden);
#   40|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:43: constructor_uses_global_object: The constructor of global object "UseAddressTopByteIgnored" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseAddressTopByteIgnored" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   // If OS supports TBI, use this flag to enable it.
#   42|   static cl::opt<bool>
#   43|-> UseAddressTopByteIgnored("aarch64-use-tbi", cl::desc("Assume that top byte of "
#   44|                            "an address is ignored"), cl::init(false), cl::Hidden);
#   45|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:47: constructor_uses_global_object: The constructor of global object "UseNonLazyBind" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseNonLazyBind" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   
#   46|   static cl::opt<bool>
#   47|->     UseNonLazyBind("aarch64-enable-nonlazybind",
#   48|                      cl::desc("Call nonlazybind functions via direct GOT load"),
#   49|                      cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:51: constructor_uses_global_object: The constructor of global object "UseAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|                      cl::init(false), cl::Hidden);
#   50|   
#   51|-> static cl::opt<bool> UseAA("aarch64-use-aa", cl::init(true),
#   52|                              cl::desc("Enable the use of AA during codegen."));
#   53|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:54: constructor_uses_global_object: The constructor of global object "OverrideVectorInsertExtractBaseCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OverrideVectorInsertExtractBaseCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|                              cl::desc("Enable the use of AA during codegen."));
#   53|   
#   54|-> static cl::opt<unsigned> OverrideVectorInsertExtractBaseCost(
#   55|       "aarch64-insert-extract-base-cost",
#   56|       cl::desc("Base cost of vector insert/extract element"), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:62: constructor_uses_global_object: The constructor of global object "ReservedRegsForRA[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReservedRegsForRA[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   // to function call.
#   61|   static cl::list<std::string>
#   62|-> ReservedRegsForRA("reserve-regs-for-regalloc", cl::desc("Reserve physical "
#   63|                     "registers, so they can't be used by register allocator. "
#   64|                     "Should only be used for testing register allocator."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64Subtarget.cpp:67: constructor_uses_global_object: The constructor of global object "ForceStreamingCompatibleSVE" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceStreamingCompatibleSVE" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|                     cl::CommaSeparated, cl::Hidden);
#   66|   
#   67|-> static cl::opt<bool> ForceStreamingCompatibleSVE(
#   68|       "force-streaming-compatible-sve",
#   69|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:58: constructor_uses_global_object: The constructor of global object "EnableCCMP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCCMP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|   using namespace llvm;
#   57|   
#   58|-> static cl::opt<bool> EnableCCMP("aarch64-enable-ccmp",
#   59|                                   cl::desc("Enable the CCMP formation pass"),
#   60|                                   cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:63: constructor_uses_global_object: The constructor of global object "EnableCondBrTuning" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCondBrTuning" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   61|   
#   62|   static cl::opt<bool>
#   63|->     EnableCondBrTuning("aarch64-enable-cond-br-tune",
#   64|                          cl::desc("Enable the conditional branch tuning pass"),
#   65|                          cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:67: constructor_uses_global_object: The constructor of global object "EnableAArch64CopyPropagation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAArch64CopyPropagation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|                          cl::init(true), cl::Hidden);
#   66|   
#   67|-> static cl::opt<bool> EnableAArch64CopyPropagation(
#   68|       "aarch64-enable-copy-propagation",
#   69|       cl::desc("Enable the copy propagation with AArch64 copy instr"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:72: constructor_uses_global_object: The constructor of global object "EnableMCR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMCR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   70|       cl::init(true), cl::Hidden);
#   71|   
#   72|-> static cl::opt<bool> EnableMCR("aarch64-enable-mcr",
#   73|                                  cl::desc("Enable the machine combiner pass"),
#   74|                                  cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:76: constructor_uses_global_object: The constructor of global object "EnableStPairSuppress" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableStPairSuppress" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   74|                                  cl::init(true), cl::Hidden);
#   75|   
#   76|-> static cl::opt<bool> EnableStPairSuppress("aarch64-enable-stp-suppress",
#   77|                                             cl::desc("Suppress STP for AArch64"),
#   78|                                             cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:80: constructor_uses_global_object: The constructor of global object "EnableAdvSIMDScalar" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAdvSIMDScalar" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   78|                                             cl::init(true), cl::Hidden);
#   79|   
#   80|-> static cl::opt<bool> EnableAdvSIMDScalar(
#   81|       "aarch64-enable-simd-scalar",
#   82|       cl::desc("Enable use of AdvSIMD scalar integer instructions"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:86: constructor_uses_global_object: The constructor of global object "EnablePromoteConstant" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePromoteConstant" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|   
#   85|   static cl::opt<bool>
#   86|->     EnablePromoteConstant("aarch64-enable-promote-const",
#   87|                             cl::desc("Enable the promote constant pass"),
#   88|                             cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:90: constructor_uses_global_object: The constructor of global object "EnableCollectLOH" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCollectLOH" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   88|                             cl::init(true), cl::Hidden);
#   89|   
#   90|-> static cl::opt<bool> EnableCollectLOH(
#   91|       "aarch64-enable-collect-loh",
#   92|       cl::desc("Enable the pass that emits the linker optimization hints (LOH)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:96: constructor_uses_global_object: The constructor of global object "EnableDeadRegisterElimination" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableDeadRegisterElimination" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   94|   
#   95|   static cl::opt<bool>
#   96|->     EnableDeadRegisterElimination("aarch64-enable-dead-defs", cl::Hidden,
#   97|                                     cl::desc("Enable the pass that removes dead"
#   98|                                              " definitons and replaces stores to"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:103: constructor_uses_global_object: The constructor of global object "EnableRedundantCopyElimination" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRedundantCopyElimination" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  101|                                     cl::init(true));
#  102|   
#  103|-> static cl::opt<bool> EnableRedundantCopyElimination(
#  104|       "aarch64-enable-copyelim",
#  105|       cl::desc("Enable the redundant copy elimination pass"), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:108: constructor_uses_global_object: The constructor of global object "EnableLoadStoreOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLoadStoreOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  106|       cl::Hidden);
#  107|   
#  108|-> static cl::opt<bool> EnableLoadStoreOpt("aarch64-enable-ldst-opt",
#  109|                                           cl::desc("Enable the load/store pair"
#  110|                                                    " optimization pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:113: constructor_uses_global_object: The constructor of global object "EnableAtomicTidy" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAtomicTidy" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  111|                                           cl::init(true), cl::Hidden);
#  112|   
#  113|-> static cl::opt<bool> EnableAtomicTidy(
#  114|       "aarch64-enable-atomic-cfg-tidy", cl::Hidden,
#  115|       cl::desc("Run SimplifyCFG after expanding atomic operations"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:120: constructor_uses_global_object: The constructor of global object "EnableEarlyIfConversion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableEarlyIfConversion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  118|   
#  119|   static cl::opt<bool>
#  120|-> EnableEarlyIfConversion("aarch64-enable-early-ifcvt", cl::Hidden,
#  121|                           cl::desc("Run early if-conversion"),
#  122|                           cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:125: constructor_uses_global_object: The constructor of global object "EnableCondOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCondOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  123|   
#  124|   static cl::opt<bool>
#  125|->     EnableCondOpt("aarch64-enable-condopt",
#  126|                     cl::desc("Enable the condition optimizer pass"),
#  127|                     cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:130: constructor_uses_global_object: The constructor of global object "EnableGEPOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGEPOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|   
#  129|   static cl::opt<bool>
#  130|->     EnableGEPOpt("aarch64-enable-gep-opt", cl::Hidden,
#  131|                    cl::desc("Enable optimizations on complex GEPs"),
#  132|                    cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:135: constructor_uses_global_object: The constructor of global object "EnableSelectOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSelectOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|   
#  134|   static cl::opt<bool>
#  135|->     EnableSelectOpt("aarch64-select-opt", cl::Hidden,
#  136|                       cl::desc("Enable select to branch optimizations"),
#  137|                       cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:140: constructor_uses_global_object: The constructor of global object "BranchRelaxation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BranchRelaxation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|   
#  139|   static cl::opt<bool>
#  140|->     BranchRelaxation("aarch64-enable-branch-relax", cl::Hidden, cl::init(true),
#  141|                        cl::desc("Relax out of range conditional branches"));
#  142|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:143: constructor_uses_global_object: The constructor of global object "EnableCompressJumpTables" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableCompressJumpTables" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  141|                        cl::desc("Relax out of range conditional branches"));
#  142|   
#  143|-> static cl::opt<bool> EnableCompressJumpTables(
#  144|       "aarch64-enable-compress-jump-tables", cl::Hidden, cl::init(true),
#  145|       cl::desc("Use smallest entry possible for jump tables"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:149: constructor_uses_global_object: The constructor of global object "EnableGlobalMerge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalMerge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  147|   // FIXME: Unify control over GlobalMerge.
#  148|   static cl::opt<cl::boolOrDefault>
#  149|->     EnableGlobalMerge("aarch64-enable-global-merge", cl::Hidden,
#  150|                         cl::desc("Enable the global merge pass"));
#  151|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:153: constructor_uses_global_object: The constructor of global object "EnableLoopDataPrefetch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLoopDataPrefetch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  151|   
#  152|   static cl::opt<bool>
#  153|->     EnableLoopDataPrefetch("aarch64-enable-loop-data-prefetch", cl::Hidden,
#  154|                              cl::desc("Enable the loop data prefetch pass"),
#  155|                              cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:157: constructor_uses_global_object: The constructor of global object "EnableGlobalISelAtO" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalISelAtO" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  155|                              cl::init(true));
#  156|   
#  157|-> static cl::opt<int> EnableGlobalISelAtO(
#  158|       "aarch64-enable-global-isel-at-O", cl::Hidden,
#  159|       cl::desc("Enable GlobalISel at or below an opt level (-1 to disable)"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:163: constructor_uses_global_object: The constructor of global object "EnableSVEIntrinsicOpts" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSVEIntrinsicOpts" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  161|   
#  162|   static cl::opt<bool>
#  163|->     EnableSVEIntrinsicOpts("aarch64-enable-sve-intrinsic-opts", cl::Hidden,
#  164|                              cl::desc("Enable SVE intrinsic opts"),
#  165|                              cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:167: constructor_uses_global_object: The constructor of global object "EnableFalkorHWPFFix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFalkorHWPFFix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  165|                              cl::init(true));
#  166|   
#  167|-> static cl::opt<bool> EnableFalkorHWPFFix("aarch64-enable-falkor-hwpf-fix",
#  168|                                            cl::init(true), cl::Hidden);
#  169|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:171: constructor_uses_global_object: The constructor of global object "EnableBranchTargets" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableBranchTargets" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  169|   
#  170|   static cl::opt<bool>
#  171|->     EnableBranchTargets("aarch64-enable-branch-targets", cl::Hidden,
#  172|                           cl::desc("Enable the AArch64 branch target pass"),
#  173|                           cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:175: constructor_uses_global_object: The constructor of global object "SVEVectorBitsMaxOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SVEVectorBitsMaxOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  173|                           cl::init(true));
#  174|   
#  175|-> static cl::opt<unsigned> SVEVectorBitsMaxOpt(
#  176|       "aarch64-sve-vector-bits-max",
#  177|       cl::desc("Assume SVE vector registers are at most this big, "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:181: constructor_uses_global_object: The constructor of global object "SVEVectorBitsMinOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SVEVectorBitsMinOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  179|       cl::init(0), cl::Hidden);
#  180|   
#  181|-> static cl::opt<unsigned> SVEVectorBitsMinOpt(
#  182|       "aarch64-sve-vector-bits-min",
#  183|       cl::desc("Assume SVE vector registers are at least this big, "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:189: constructor_uses_global_object: The constructor of global object "EnableGISelLoadStoreOptPreLegal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGISelLoadStoreOptPreLegal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  187|   extern cl::opt<bool> EnableHomogeneousPrologEpilog;
#  188|   
#  189|-> static cl::opt<bool> EnableGISelLoadStoreOptPreLegal(
#  190|       "aarch64-enable-gisel-ldst-prelegal",
#  191|       cl::desc("Enable GlobalISel's pre-legalizer load/store optimization pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetMachine.cpp:194: constructor_uses_global_object: The constructor of global object "EnableGISelLoadStoreOptPostLegal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGISelLoadStoreOptPostLegal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  192|       cl::init(true), cl::Hidden);
#  193|   
#  194|-> static cl::opt<bool> EnableGISelLoadStoreOptPostLegal(
#  195|       "aarch64-enable-gisel-ldst-postlegal",
#  196|       cl::desc("Enable GlobalISel's post-legalizer load/store optimization pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:33: constructor_uses_global_object: The constructor of global object "EnableFalkorHWPFUnrollFix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFalkorHWPFUnrollFix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   #define DEBUG_TYPE "aarch64tti"
#   32|   
#   33|-> static cl::opt<bool> EnableFalkorHWPFUnrollFix("enable-falkor-hwpf-unroll-fix",
#   34|                                                  cl::init(true), cl::Hidden);
#   35|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:36: constructor_uses_global_object: The constructor of global object "SVEGatherOverhead" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SVEGatherOverhead" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|                                                  cl::init(true), cl::Hidden);
#   35|   
#   36|-> static cl::opt<unsigned> SVEGatherOverhead("sve-gather-overhead", cl::init(10),
#   37|                                              cl::Hidden);
#   38|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:39: constructor_uses_global_object: The constructor of global object "SVEScatterOverhead" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SVEScatterOverhead" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|                                              cl::Hidden);
#   38|   
#   39|-> static cl::opt<unsigned> SVEScatterOverhead("sve-scatter-overhead",
#   40|                                               cl::init(10), cl::Hidden);
#   41|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:42: constructor_uses_global_object: The constructor of global object "SVETailFoldInsnThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SVETailFoldInsnThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|                                               cl::init(10), cl::Hidden);
#   41|   
#   42|-> static cl::opt<unsigned> SVETailFoldInsnThreshold("sve-tail-folding-insn-threshold",
#   43|                                                     cl::init(15), cl::Hidden);
#   44|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:46: constructor_uses_global_object: The constructor of global object "NeonNonConstStrideOverhead" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NeonNonConstStrideOverhead" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   
#   45|   static cl::opt<unsigned>
#   46|->     NeonNonConstStrideOverhead("neon-nonconst-stride-overhead", cl::init(10),
#   47|                                  cl::Hidden);
#   48|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:158: constructor_uses_global_object: The constructor of global object "SVETailFolding[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SVETailFolding[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  156|   TailFoldingOption TailFoldingOptionLoc;
#  157|   
#  158|-> cl::opt<TailFoldingOption, true, cl::parser<std::string>> SVETailFolding(
#  159|       "sve-tail-folding",
#  160|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:184: constructor_uses_global_object: The constructor of global object "EnableFixedwidthAutovecInStreamingMode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFixedwidthAutovecInStreamingMode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  182|   // code-generator is changed to use SVE instead of NEON for all fixed-width
#  183|   // operations.
#  184|-> static cl::opt<bool> EnableFixedwidthAutovecInStreamingMode(
#  185|       "enable-fixedwidth-autovec-in-streaming-mode", cl::init(false), cl::Hidden);
#  186|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:190: constructor_uses_global_object: The constructor of global object "EnableScalableAutovecInStreamingMode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableScalableAutovecInStreamingMode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  188|   // and code-generator have been changed to avoid using scalable vector
#  189|   // instructions that are not legal in streaming SVE mode.
#  190|-> static cl::opt<bool> EnableScalableAutovecInStreamingMode(
#  191|       "enable-scalable-autovec-in-streaming-mode", cl::init(false), cl::Hidden);
#  192|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:2864: var_decl: Declaring variable "Options".
llvm-17.0.6.src/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:2868: uninit_use: Using uninitialized value "Options". Field "Options.LoadSizes.InlineElts" is uninitialized.
# 2866|       // TODO: Add cost modeling for strict align. Misaligned loads expand to
# 2867|       // a bunch of instructions when strict align is enabled.
# 2868|->     return Options;
# 2869|     }
# 2870|     Options.AllowOverlappingLoads = true;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:95: var_decl: Declaring variable "Prefix".
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:129: uninit_use: Using uninitialized value "Prefix". Field "Prefix.ElementSize" is uninitialized.
#  127|         }
#  128|   
#  129|->       return Prefix;
#  130|       }
#  131|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:1474: var_decl: Declaring variable "RealVal".
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:1475: uninit_use_in_call: Using uninitialized value "RealVal.U" when calling "convertFromString".
# 1473|         // Calculate its FP value.
# 1474|         APFloat RealVal(APFloat::IEEEdouble());
# 1475|->       auto StatusOrErr =
# 1476|             RealVal.convertFromString(Desc->Repr, APFloat::rmTowardZero);
# 1477|         if (errorToBool(StatusOrErr.takeError()) || *StatusOrErr != APFloat::opOK)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3232: var_decl: Declaring variable "F".
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3235: uninit_use_in_call: Using uninitialized value "F.U" when calling "~APFloat".
# 3233|       Operands.push_back(
# 3234|           AArch64Operand::CreateFPImm(F, true, S, getContext()));
# 3235|->   } else {
# 3236|       // Parse FP representation.
# 3237|       APFloat RealVal(APFloat::IEEEdouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3237: var_decl: Declaring variable "RealVal".
llvm-17.0.6.src/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3238: uninit_use_in_call: Using uninitialized value "RealVal.U" when calling "convertFromString".
# 3236|       // Parse FP representation.
# 3237|       APFloat RealVal(APFloat::IEEEdouble());
# 3238|->     auto StatusOrErr =
# 3239|           RealVal.convertFromString(Tok.getString(), APFloat::rmTowardZero);
# 3240|       if (errorToBool(StatusOrErr.takeError()))

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:2877: return_constant: Function call "llvm::Log2_32(MemSizeInBytes)" may return 4294967295.
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:2877: overrun-local: Overrunning array "Opcodes" of 4 4-byte elements at element index 4294967295 (byte offset 17179869183) using index "llvm::Log2_32(MemSizeInBytes)" (which evaluates to 4294967295).
# 2875|             I.getOperand(0).setReg(NewVal);
# 2876|           }
# 2877|->         I.setDesc(TII.get(Opcodes[Log2_32(MemSizeInBytes)]));
# 2878|         }
# 2879|         constrainSelectedInstRegOperands(I, TII, TRI, RBI);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:3571: var_decl: Declaring variable "Mopcode" without initializer.
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:3595: uninit_use: Using uninitialized value "Mopcode".
# 3593|     const Register SizeCopy = MRI.cloneVirtualRegister(Size.getReg());
# 3594|   
# 3595|->   const bool IsSet = Mopcode == AArch64::MOPSMemorySetPseudo;
# 3596|     const auto &SrcValRegClass =
# 3597|         IsSet ? AArch64::GPR64RegClass : AArch64::GPR64commonRegClass;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:3942: return_constant: Function call "llvm::Log2_32(SrcEltSize / 8U)" may return 4294967295.
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:3942: assignment: Assigning: "EltIdx" = "llvm::Log2_32(SrcEltSize / 8U)". The value of "EltIdx" is now 4294967295.
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:3944: overrun-local: Overrunning array "OpcTable" of 4 144-byte elements at element index 4294967295 (byte offset 618475290623) using index "EltIdx" (which evaluates to 4294967295).
# 3942|     unsigned EltIdx = Log2_32(SrcEltSize / 8);
# 3943|     unsigned NumEltsIdx = Log2_32(NumElts / 2);
# 3944|->   unsigned Opc = OpcTable[EltIdx][NumEltsIdx][PredIdx];
# 3945|     if (!Opc) {
# 3946|       LLVM_DEBUG(dbgs() << "Could not map G_ICMP to cmp opcode");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:309: var_decl: Declaring variable "AltMappings".
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:319: uninit_use: Using uninitialized value "AltMappings". Field "AltMappings.InlineElts" is uninitialized.
#  317|       AltMappings.push_back(&GPRMapping);
#  318|       AltMappings.push_back(&FPRMapping);
#  319|->     return AltMappings;
#  320|     }
#  321|     case TargetOpcode::G_BITCAST: {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:331: var_decl: Declaring variable "AltMappings".
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:355: uninit_use: Using uninitialized value "AltMappings". Field "AltMappings.InlineElts" is uninitialized.
#  353|       AltMappings.push_back(&GPRToFPRMapping);
#  354|       AltMappings.push_back(&FPRToGPRMapping);
#  355|->     return AltMappings;
#  356|     }
#  357|     case TargetOpcode::G_LOAD: {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:367: var_decl: Declaring variable "AltMappings".
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp:383: uninit_use: Using uninitialized value "AltMappings". Field "AltMappings.InlineElts" is uninitialized.
#  381|       AltMappings.push_back(&GPRMapping);
#  382|       AltMappings.push_back(&FPRMapping);
#  383|->     return AltMappings;
#  384|     }
#  385|     default:

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:75: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:78: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:79: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#   77|   
#   78|       if (Kind < FirstTargetFixupKind)
#   79|->       return MCAsmBackend::getFixupKindInfo(Kind);
#   80|   
#   81|       assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:75: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:78: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64AsmBackend.cpp:83: illegal_address: "Infos[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 336 bytes.
#   81|       assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&
#   82|              "Invalid kind!");
#   83|->     return Infos[Kind - FirstTargetFixupKind];
#   84|     }
#   85|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64MCAsmInfo.cpp:27: constructor_uses_global_object: The constructor of global object "AsmWriterVariant" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AsmWriterVariant" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   };
#   26|   
#   27|-> static cl::opt<AsmWriterVariantTy> AsmWriterVariant(
#   28|       "aarch64-neon-syntax", cl::init(Default),
#   29|       cl::desc("Choose style of NEON code to emit from AArch64 backend:"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AArch64/MCTargetDesc/AArch64TargetStreamer.cpp:26: constructor_uses_global_object: The constructor of global object "MarkBTIProperty" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MarkBTIProperty" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   using namespace llvm;
#   25|   
#   26|-> static cl::opt<bool> MarkBTIProperty(
#   27|       "aarch64-mark-bti-property", cl::Hidden,
#   28|       cl::desc("Add .note.gnu.property with BTI to assembly files"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUAlwaysInlinePass.cpp:27: constructor_uses_global_object: The constructor of global object "<unnamed>::StressCalls" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::StressCalls" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   namespace {
#   26|   
#   27|-> static cl::opt<bool> StressCalls(
#   28|     "amdgpu-stress-function-calls",
#   29|     cl::Hidden,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUAttributor.cpp:949: var_decl: Declaring variable "AC".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUAttributor.cpp:957: uninit_use_in_call: Using uninitialized value "AC.OREGetter". Field "AC.OREGetter.callable" is uninitialized when calling "AttributorConfig".
#  955|       };
#  956|   
#  957|->     Attributor A(Functions, InfoCache, AC);
#  958|   
#  959|       for (Function &F : M) {

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:42: constructor_uses_global_object: The constructor of global object "<unnamed>::WidenLoads" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::WidenLoads" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|   namespace {
#   41|   
#   42|-> static cl::opt<bool> WidenLoads(
#   43|     "amdgpu-codegenprepare-widen-constant-loads",
#   44|     cl::desc("Widen sub-dword constant address space loads in AMDGPUCodeGenPrepare"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:48: constructor_uses_global_object: The constructor of global object "<unnamed>::Widen16BitOps" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::Widen16BitOps" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|     cl::init(false));
#   47|   
#   48|-> static cl::opt<bool> Widen16BitOps(
#   49|     "amdgpu-codegenprepare-widen-16-bit-ops",
#   50|     cl::desc("Widen uniform 16-bit instructions to 32-bit in AMDGPUCodeGenPrepare"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:55: constructor_uses_global_object: The constructor of global object "<unnamed>::ScalarizeLargePHIs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ScalarizeLargePHIs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   
#   54|   static cl::opt<bool>
#   55|->     ScalarizeLargePHIs("amdgpu-codegenprepare-break-large-phis",
#   56|                          cl::desc("Break large PHI nodes for DAGISel"),
#   57|                          cl::ReallyHidden, cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:60: constructor_uses_global_object: The constructor of global object "<unnamed>::ForceScalarizeLargePHIs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ForceScalarizeLargePHIs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|   
#   59|   static cl::opt<bool>
#   60|->     ForceScalarizeLargePHIs("amdgpu-codegenprepare-force-break-large-phis",
#   61|                               cl::desc("For testing purposes, always break large "
#   62|                                        "PHIs even if it isn't profitable."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:65: constructor_uses_global_object: The constructor of global object "<unnamed>::ScalarizeLargePHIsThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ScalarizeLargePHIsThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|                               cl::ReallyHidden, cl::init(false));
#   64|   
#   65|-> static cl::opt<unsigned> ScalarizeLargePHIsThreshold(
#   66|       "amdgpu-codegenprepare-break-large-phis-threshold",
#   67|       cl::desc("Minimum type size in bits for breaking large PHI nodes"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:70: constructor_uses_global_object: The constructor of global object "<unnamed>::UseMul24Intrin" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::UseMul24Intrin" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|       cl::ReallyHidden, cl::init(32));
#   69|   
#   70|-> static cl::opt<bool> UseMul24Intrin(
#   71|     "amdgpu-codegenprepare-mul24",
#   72|     cl::desc("Introduce mul24 intrinsics in AMDGPUCodeGenPrepare"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:77: constructor_uses_global_object: The constructor of global object "<unnamed>::ExpandDiv64InIR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ExpandDiv64InIR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|   
#   76|   // Legalize 64-bit division by using the generic IR expansion.
#   77|-> static cl::opt<bool> ExpandDiv64InIR(
#   78|     "amdgpu-codegenprepare-expand-div64",
#   79|     cl::desc("Expand 64-bit division in AMDGPUCodeGenPrepare"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:85: constructor_uses_global_object: The constructor of global object "<unnamed>::DisableIDivExpand" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DisableIDivExpand" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|   // Leave all division operations as they are. This supersedes ExpandDiv64InIR
#   84|   // and is used for testing the legalizer.
#   85|-> static cl::opt<bool> DisableIDivExpand(
#   86|     "amdgpu-codegenprepare-disable-idiv-expansion",
#   87|     cl::desc("Prevent expanding integer division in AMDGPUCodeGenPrepare"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:92: constructor_uses_global_object: The constructor of global object "<unnamed>::DisableFDivExpand" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DisableFDivExpand" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   90|   
#   91|   // Disable processing of fdiv so we can better test the backend implementations.
#   92|-> static cl::opt<bool> DisableFDivExpand(
#   93|     "amdgpu-codegenprepare-disable-fdiv-expansion",
#   94|     cl::desc("Prevent expanding floating point division in AMDGPUCodeGenPrepare"),

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUGenRegisterBankInfo.def:279: assignment: Assigning: "Idx" = "AGPRStartIdx".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUGenRegisterBankInfo.def:283: assignment: Assigning: "Idx" += "llvm::Log2_32_Ceil(Size)". The value of "Idx" may now be up to 70.
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUGenRegisterBankInfo.def:290: illegal_address: "&llvm::AMDGPU::ValMappings[Idx]" evaluates to an address that is at byte offset 1120 of an array of 784 bytes.
#  288|     assert(BankID == ValMappings[Idx].BreakDown->RegBank->getID());
#  289|   
#  290|->   return &ValMappings[Idx];
#  291|   }
#  292|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUHSAMetadataStreamer.cpp:41: constructor_uses_global_object: The constructor of global object "llvm::DumpHSAMetadata" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::DumpHSAMetadata" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   namespace llvm {
#   40|   
#   41|-> static cl::opt<bool> DumpHSAMetadata(
#   42|       "amdgpu-dump-hsa-metadata",
#   43|       cl::desc("Dump AMDGPU HSA Metadata"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUHSAMetadataStreamer.cpp:44: constructor_uses_global_object: The constructor of global object "llvm::VerifyHSAMetadata" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "llvm::VerifyHSAMetadata" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|       "amdgpu-dump-hsa-metadata",
#   43|       cl::desc("Dump AMDGPU HSA Metadata"));
#   44|-> static cl::opt<bool> VerifyHSAMetadata(
#   45|       "amdgpu-verify-hsa-metadata",
#   46|       cl::desc("Verify AMDGPU HSA Metadata"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:34: constructor_uses_global_object: The constructor of global object "<unnamed>::EnableExactSolver" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::EnableExactSolver" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   namespace {
#   33|   
#   34|-> static cl::opt<bool> EnableExactSolver(
#   35|       "amdgpu-igrouplp-exact-solver", cl::Hidden,
#   36|       cl::desc("Whether to use the exponential time solver to fit "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:41: constructor_uses_global_object: The constructor of global object "<unnamed>::CutoffForExact" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::CutoffForExact" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|       cl::init(false));
#   40|   
#   41|-> static cl::opt<unsigned> CutoffForExact(
#   42|       "amdgpu-igrouplp-exact-solver-cutoff", cl::init(0), cl::Hidden,
#   43|       cl::desc("The maximum number of scheduling group conflicts "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:50: constructor_uses_global_object: The constructor of global object "<unnamed>::MaxBranchesExplored" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::MaxBranchesExplored" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|                "the solver (e.g. by amdgpu-igrouplp-exact-solver"));
#   49|   
#   50|-> static cl::opt<uint64_t> MaxBranchesExplored(
#   51|       "amdgpu-igrouplp-exact-solver-max-branches", cl::init(0), cl::Hidden,
#   52|       cl::desc("The amount of branches that we are willing to explore with"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:55: constructor_uses_global_object: The constructor of global object "<unnamed>::UseCostHeur" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::UseCostHeur" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|                "the exact algorithm before giving up."));
#   54|   
#   55|-> static cl::opt<bool> UseCostHeur(
#   56|       "amdgpu-igrouplp-exact-solver-cost-heur", cl::init(true), cl::Hidden,
#   57|       cl::desc("Whether to use the cost heuristic to make choices as we "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:596: var_decl: Declaring variable "Match" without initializer.
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:603: uninit_use_in_call: Using uninitialized value "Match" when calling "isFull".
#  601|   
#  602|       if (UseCostHeur) {
#  603|->       if (Match->isFull()) {
#  604|           ReadyList.push_back(std::pair(*I, MissPenalty));
#  605|           continue;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:742: var_decl: Declaring variable "Match" without initializer.
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:751: uninit_use_in_call: Using uninitialized value "Match" when calling "isFull".
#  749|                         << (int)Match->getMask() << "\n");
#  750|   
#  751|->     if (Match->isFull()) {
#  752|         LLVM_DEBUG(dbgs() << "SGID # " << CandSGID << " is full\n");
#  753|         continue;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:34: constructor_uses_global_object: The constructor of global object "AMDGPUBypassSlowDiv" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AMDGPUBypassSlowDiv" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   #include "AMDGPUGenCallingConv.inc"
#   33|   
#   34|-> static cl::opt<bool> AMDGPUBypassSlowDiv(
#   35|     "amdgpu-bypass-slow-div",
#   36|     cl::desc("Skip 64-bit divide for dynamic 32-bit values"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:430: var_decl: Declaring variable "Val".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:431: uninit_use_in_call: Using uninitialized value "Val.U" when calling "divide".
#  429|         const APFloat &ArgVal = C->getValueAPF();
#  430|         APFloat Val(ArgVal.getSemantics(), 1);
#  431|->       Val.divide(ArgVal, APFloat::rmNearestTiesToEven);
#  432|   
#  433|         // This is more precise than the instruction may give.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:36: constructor_uses_global_object: The constructor of global object "AllowRiskySelect" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AllowRiskySelect" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   using namespace MIPatternMatch;
#   35|   
#   36|-> static cl::opt<bool> AllowRiskySelect(
#   37|     "amdgpu-global-isel-risky-select",
#   38|     cl::desc("Allow GlobalISel to select cases that are likely to not work yet"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp:35: constructor_uses_global_object: The constructor of global object "WidenLoads" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "WidenLoads" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   // only but not dword aligned.
#   34|   static cl::opt<bool>
#   35|->     WidenLoads("amdgpu-late-codegenprepare-widen-constant-loads",
#   36|                  cl::desc("Widen sub-dword constant address space loads in "
#   37|                           "AMDGPULateCodeGenPrepare"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:41: constructor_uses_global_object: The constructor of global object "EnableNewLegality" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableNewLegality" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|   
#   40|   // Hack until load/store selection patterns support any tuple of legal types.
#   41|-> static cl::opt<bool> EnableNewLegality(
#   42|     "amdgpu-global-isel-new-legality",
#   43|     cl::desc("Use GlobalISel desired legality, rather than try to use"

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:3711: var_decl: Declaring variable "CarryOut".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:3786: uninit_use: Using uninitialized value "CarryOut". Field "CarryOut.InlineElts" is uninitialized.
# 3784|           }
# 3785|   
# 3786|->         return CarryOut;
# 3787|         };
# 3788|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:4838: var_decl: Declaring variable "C0Val".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:4858: uninit_use_in_call: Using uninitialized value "C0Val.U" when calling "~APFloat".
# 4856|   
# 4857|     MI.eraseFromParent();
# 4858|->   return true;
# 4859|   }
# 4860|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:5906: zero_return: Function call "this->ST->getNSAMaxSize()" returns 0.
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:5906: assignment: Assigning: "NSAMaxSize" = "this->ST->getNSAMaxSize()". The value of "NSAMaxSize" is now 0.
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:5927: overrun-buffer-arg: Calling "slice" with "llvm::ArrayRef<llvm::Register>(PackedRegs).Data" and "NSAMaxSize - 1U" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
# 5925|           LLT PackedAddrTy =
# 5926|               LLT::fixed_vector(2 * (PackedRegs.size() - NSAMaxSize + 1), 16);
# 5927|->         auto Concat = B.buildConcatVectors(
# 5928|               PackedAddrTy, ArrayRef(PackedRegs).slice(NSAMaxSize - 1));
# 5929|           PackedRegs[NSAMaxSize - 1] = Concat.getReg(0);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibCalls.cpp:30: constructor_uses_global_object: The constructor of global object "EnablePreLink" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePreLink" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   using namespace llvm;
#   29|   
#   30|-> static cl::opt<bool> EnablePreLink("amdgpu-prelink",
#   31|     cl::desc("Enable pre-link mode optimizations"),
#   32|     cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibCalls.cpp:35: constructor_uses_global_object: The constructor of global object "UseNative[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseNative[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|     cl::Hidden);
#   34|   
#   35|-> static cl::list<std::string> UseNative("amdgpu-use-native",
#   36|     cl::desc("Comma separated list of functions to replace with native, or all"),
#   37|     cl::CommaSeparated, cl::ValueOptional,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibFunc.cpp:28: constructor_uses_global_object: The constructor of global object "EnableOCLManglingMismatchWA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableOCLManglingMismatchWA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   26|   using namespace llvm;
#   27|   
#   28|-> static cl::opt<bool> EnableOCLManglingMismatchWA(
#   29|       "amdgpu-enable-ocl-mangling-mismatch-workaround", cl::init(true),
#   30|       cl::ReallyHidden,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibFunc.cpp:380: var_decl: Declaring variable "P".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibFunc.cpp:381: uninit_use: Using uninitialized value "P". Field "P.Reserved" is uninitialized.
#  379|   AMDGPULibFunc::Param ParamIterator::getNextParam() {
#  380|     AMDGPULibFunc::Param P;
#  381|->   if (Index >= int(sizeof Rule.Param/sizeof Rule.Param[0])) return P;
#  382|   
#  383|     const char R = Rule.Param[Index];

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibFunc.cpp:380: var_decl: Declaring variable "P".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULibFunc.cpp:464: uninit_use: Using uninitialized value "P". Field "P.Reserved" is uninitialized.
#  462|     }
#  463|     ++Index;
#  464|->   return P;
#  465|   }
#  466|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:218: constructor_uses_global_object: The constructor of global object "<unnamed>::SuperAlignLDSGlobals" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::SuperAlignLDSGlobals" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  216|   namespace {
#  217|   
#  218|-> cl::opt<bool> SuperAlignLDSGlobals(
#  219|       "amdgpu-super-align-lds-globals",
#  220|       cl::desc("Increase alignment of LDS if it is not on align boundary"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:224: constructor_uses_global_object: The constructor of global object "<unnamed>::LoweringKindLoc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::LoweringKindLoc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  222|   
#  223|   enum class LoweringKind { module, table, kernel, hybrid };
#  224|-> cl::opt<LoweringKind> LoweringKindLoc(
#  225|       "amdgpu-lower-module-lds-strategy",
#  226|       cl::desc("Specify lowering strategy for function LDS access:"), cl::Hidden,

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:1340: var_decl: Declaring variable "F".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:1343: uninit_use_in_call: Using uninitialized value "F". Field "F.Scratch" is uninitialized when calling "emplace_back".
# 1341|                                        DL.getTypeAllocSize(GV->getValueType()),
# 1342|                                        AMDGPU::getAlign(DL, GV));
# 1343|->         LayoutFields.emplace_back(F);
# 1344|         }
# 1345|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp:2303: var_decl: Declaring variable "InnerRegion".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUMachineCFGStructurizer.cpp:2312: uninit_use_in_call: Using uninitialized value "InnerRegion.RMRT" when calling "rewriteLiveOutRegs".
# 2310|   
# 2311|       LLVM_DEBUG(InnerRegion.print(dbgs(), TRI));
# 2312|->     rewriteLiveOutRegs(IfBB, CodeBB, MergeBB, &InnerRegion, CurrentRegion);
# 2313|       extractKilledPHIs(CodeBB);
# 2314|       if (IsRegionEntryBB) {

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:35: constructor_uses_global_object: The constructor of global object "MemBoundThresh" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MemBoundThresh" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   static cl::opt<unsigned>
#   35|->     MemBoundThresh("amdgpu-membound-threshold", cl::init(50), cl::Hidden,
#   36|                      cl::desc("Function mem bound threshold in %"));
#   37|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:39: constructor_uses_global_object: The constructor of global object "LimitWaveThresh" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LimitWaveThresh" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   
#   38|   static cl::opt<unsigned>
#   39|->     LimitWaveThresh("amdgpu-limit-wave-threshold", cl::init(50), cl::Hidden,
#   40|                       cl::desc("Kernel limit wave threshold in %"));
#   41|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:43: constructor_uses_global_object: The constructor of global object "IAWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "IAWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   
#   42|   static cl::opt<unsigned>
#   43|->     IAWeight("amdgpu-indirect-access-weight", cl::init(1000), cl::Hidden,
#   44|                cl::desc("Indirect access memory instruction weight"));
#   45|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:47: constructor_uses_global_object: The constructor of global object "LSWeight" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LSWeight" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   
#   46|   static cl::opt<unsigned>
#   47|->     LSWeight("amdgpu-large-stride-weight", cl::init(1000), cl::Hidden,
#   48|                cl::desc("Large stride memory access weight"));
#   49|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:51: constructor_uses_global_object: The constructor of global object "LargeStrideThresh" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LargeStrideThresh" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|   
#   50|   static cl::opt<unsigned>
#   51|->     LargeStrideThresh("amdgpu-large-stride-threshold", cl::init(64), cl::Hidden,
#   52|                         cl::desc("Large stride memory access threshold"));
#   53|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPrintfRuntimeBinding.cpp:105: tainted_data_return: Called function "CurFmt.find_last_of(llvm::StringRef("%"), 18446744073709551615UL)", and a possible return value is known to be less than zero.
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPrintfRuntimeBinding.cpp:105: assign: Assigning: "pTag" = "CurFmt.find_last_of(llvm::StringRef("%"), 18446744073709551615UL)".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPrintfRuntimeBinding.cpp:108: overflow_sink: "--pTag", which might have underflowed, is passed to "CurFmt[--pTag]".
#  106|       if (pTag != StringRef::npos) {
#  107|         ArgDump = true;
#  108|->       while (pTag && CurFmt[--pTag] == '%') {
#  109|           ArgDump = !ArgDump;
#  110|         }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:53: constructor_uses_global_object: The constructor of global object "<unnamed>::DisablePromoteAllocaToVector" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DisablePromoteAllocaToVector" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|   
#   52|   static cl::opt<bool>
#   53|->     DisablePromoteAllocaToVector("disable-promote-alloca-to-vector",
#   54|                                    cl::desc("Disable promote alloca to vector"),
#   55|                                    cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:58: constructor_uses_global_object: The constructor of global object "<unnamed>::DisablePromoteAllocaToLDS" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::DisablePromoteAllocaToLDS" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|   
#   57|   static cl::opt<bool>
#   58|->     DisablePromoteAllocaToLDS("disable-promote-alloca-to-lds",
#   59|                                 cl::desc("Disable promote alloca to LDS"),
#   60|                                 cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:62: constructor_uses_global_object: The constructor of global object "<unnamed>::PromoteAllocaToVectorLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::PromoteAllocaToVectorLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|                                 cl::init(false));
#   61|   
#   62|-> static cl::opt<unsigned> PromoteAllocaToVectorLimit(
#   63|       "amdgpu-promote-alloca-to-vector-limit",
#   64|       cl::desc("Maximum byte size to consider promote alloca to vector"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:306: var_decl: Declaring variable "AltMappings".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:334: uninit_use: Using uninitialized value "AltMappings". Field "AltMappings.InlineElts" is uninitialized.
#  332|     }
#  333|   
#  334|->   return AltMappings;
#  335|   }
#  336|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:3587: assignment: Assigning: "ResultBank" = "InvalidRegBankID".
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:3613: overrun-buffer-arg: Calling "getRegBank" with "this->RegBanks" and "ResultBank" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
# 3611|       unsigned Size = MRI.getType(DstReg).getSizeInBits();
# 3612|   
# 3613|->     const ValueMapping &ValMap =
# 3614|           getValueMapping(0, Size, getRegBank(ResultBank));
# 3615|       return getInstructionMapping(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp:49: constructor_uses_global_object: The constructor of global object "AssumedStackSizeForExternalCall" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AssumedStackSizeForExternalCall" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|   // time if we don't know the true stack size. Assume a smaller number if this is
#   48|   // only due to dynamic / non-entry block allocas.
#   49|-> static cl::opt<uint32_t> AssumedStackSizeForExternalCall(
#   50|       "amdgpu-assume-external-call-stack-size",
#   51|       cl::desc("Assumed stack use of any external call (in bytes)"), cl::Hidden,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUResourceUsageAnalysis.cpp:54: constructor_uses_global_object: The constructor of global object "AssumedStackSizeForDynamicSizeObjects" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AssumedStackSizeForDynamicSizeObjects" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|       cl::init(16384));
#   53|   
#   54|-> static cl::opt<uint32_t> AssumedStackSizeForDynamicSizeObjects(
#   55|       "amdgpu-assume-dynamic-stack-object-size",
#   56|       cl::desc("Assumed extra stack use if there are any "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPURewriteOutArguments.cpp:62: constructor_uses_global_object: The constructor of global object "AnyAddressSpace" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AnyAddressSpace" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   using namespace llvm;
#   61|   
#   62|-> static cl::opt<bool> AnyAddressSpace(
#   63|     "amdgpu-any-address-space-out-arguments",
#   64|     cl::desc("Replace pointer out arguments with "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPURewriteOutArguments.cpp:69: constructor_uses_global_object: The constructor of global object "MaxNumRetRegs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxNumRetRegs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|     cl::init(false));
#   68|   
#   69|-> static cl::opt<unsigned> MaxNumRetRegs(
#   70|     "amdgpu-max-return-arg-num-regs",
#   71|     cl::desc("Approximately limit number of return registers for replacing out arguments"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUSetWavePriority.cpp:29: constructor_uses_global_object: The constructor of global object "DefaultVALUInstsThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DefaultVALUInstsThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|   #define DEBUG_TYPE "amdgpu-set-wave-priority"
#   28|   
#   29|-> static cl::opt<unsigned> DefaultVALUInstsThreshold(
#   30|       "amdgpu-set-wave-priority-valu-insts-threshold",
#   31|       cl::desc("VALU instruction count threshold for adjusting wave priority"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:43: constructor_uses_global_object: The constructor of global object "EnablePowerSched" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePowerSched" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   #undef AMDGPUSubtarget
#   42|   
#   43|-> static cl::opt<bool> EnablePowerSched(
#   44|     "amdgpu-enable-power-sched",
#   45|     cl::desc("Enable scheduling to minimize mAI power bursts"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:48: constructor_uses_global_object: The constructor of global object "EnableVGPRIndexMode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableVGPRIndexMode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|     cl::init(false));
#   47|   
#   48|-> static cl::opt<bool> EnableVGPRIndexMode(
#   49|     "amdgpu-vgpr-index-mode",
#   50|     cl::desc("Use GPR indexing mode instead of movrel for vector indexing"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:53: constructor_uses_global_object: The constructor of global object "UseAA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseAA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|     cl::init(false));
#   52|   
#   53|-> static cl::opt<bool> UseAA("amdgpu-use-aa-in-codegen",
#   54|                              cl::desc("Enable the use of AA during codegen."),
#   55|                              cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:57: constructor_uses_global_object: The constructor of global object "NSAThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NSAThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   55|                              cl::init(true));
#   56|   
#   57|-> static cl::opt<unsigned> NSAThreshold("amdgpu-nsa-threshold",
#   58|                                         cl::desc("Number of addresses from which to enable MIMG NSA."),
#   59|                                         cl::init(3), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:107: constructor_uses_global_object: The constructor of global object "<unnamed>::SGPRRegAlloc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::SGPRRegAlloc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  105|   static cl::opt<SGPRRegisterRegAlloc::FunctionPassCtor, false,
#  106|                  RegisterPassParser<SGPRRegisterRegAlloc>>
#  107|-> SGPRRegAlloc("sgpr-regalloc", cl::Hidden, cl::init(&useDefaultRegisterAllocator),
#  108|                cl::desc("Register allocator to use for SGPRs"));
#  109|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:112: constructor_uses_global_object: The constructor of global object "<unnamed>::VGPRRegAlloc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::VGPRRegAlloc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  110|   static cl::opt<VGPRRegisterRegAlloc::FunctionPassCtor, false,
#  111|                  RegisterPassParser<VGPRRegisterRegAlloc>>
#  112|-> VGPRRegAlloc("vgpr-regalloc", cl::Hidden, cl::init(&useDefaultRegisterAllocator),
#  113|                cl::desc("Register allocator to use for VGPRs"));
#  114|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:176: constructor_uses_global_object: The constructor of global object "EnableSROA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSROA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  174|   }
#  175|   
#  176|-> static cl::opt<bool> EnableSROA(
#  177|     "amdgpu-sroa",
#  178|     cl::desc("Run SROA after promote alloca pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:183: constructor_uses_global_object: The constructor of global object "EnableEarlyIfConversion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableEarlyIfConversion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  181|   
#  182|   static cl::opt<bool>
#  183|-> EnableEarlyIfConversion("amdgpu-early-ifcvt", cl::Hidden,
#  184|                           cl::desc("Run early if-conversion"),
#  185|                           cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:188: constructor_uses_global_object: The constructor of global object "OptExecMaskPreRA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptExecMaskPreRA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  186|   
#  187|   static cl::opt<bool>
#  188|-> OptExecMaskPreRA("amdgpu-opt-exec-mask-pre-ra", cl::Hidden,
#  189|               cl::desc("Run pre-RA exec mask optimizations"),
#  190|               cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:193: constructor_uses_global_object: The constructor of global object "LowerCtorDtor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LowerCtorDtor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  191|   
#  192|   static cl::opt<bool>
#  193|->     LowerCtorDtor("amdgpu-lower-global-ctor-dtor",
#  194|                     cl::desc("Lower GPU ctor / dtors to globals on the device."),
#  195|                     cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:198: constructor_uses_global_object: The constructor of global object "EnableLoadStoreVectorizer" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLoadStoreVectorizer" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  196|   
#  197|   // Option to disable vectorizer for tests.
#  198|-> static cl::opt<bool> EnableLoadStoreVectorizer(
#  199|     "amdgpu-load-store-vectorizer",
#  200|     cl::desc("Enable load store vectorizer"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:205: constructor_uses_global_object: The constructor of global object "ScalarizeGlobal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ScalarizeGlobal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  203|   
#  204|   // Option to control global loads scalarization
#  205|-> static cl::opt<bool> ScalarizeGlobal(
#  206|     "amdgpu-scalarize-global-loads",
#  207|     cl::desc("Enable global load scalarization"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:212: constructor_uses_global_object: The constructor of global object "InternalizeSymbols" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InternalizeSymbols" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  210|   
#  211|   // Option to run internalize pass.
#  212|-> static cl::opt<bool> InternalizeSymbols(
#  213|     "amdgpu-internalize-symbols",
#  214|     cl::desc("Enable elimination of non-kernel functions and unused globals"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:219: constructor_uses_global_object: The constructor of global object "EarlyInlineAll" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EarlyInlineAll" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  217|   
#  218|   // Option to inline all early.
#  219|-> static cl::opt<bool> EarlyInlineAll(
#  220|     "amdgpu-early-inline-all",
#  221|     cl::desc("Inline all functions early"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:225: constructor_uses_global_object: The constructor of global object "RemoveIncompatibleFunctions" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RemoveIncompatibleFunctions" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  223|     cl::Hidden);
#  224|   
#  225|-> static cl::opt<bool> RemoveIncompatibleFunctions(
#  226|       "amdgpu-enable-remove-incompatible-functions", cl::Hidden,
#  227|       cl::desc("Enable removal of functions when they"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:231: constructor_uses_global_object: The constructor of global object "EnableSDWAPeephole" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSDWAPeephole" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  229|       cl::init(true));
#  230|   
#  231|-> static cl::opt<bool> EnableSDWAPeephole(
#  232|     "amdgpu-sdwa-peephole",
#  233|     cl::desc("Enable SDWA peepholer"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:236: constructor_uses_global_object: The constructor of global object "EnableDPPCombine" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableDPPCombine" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  234|     cl::init(true));
#  235|   
#  236|-> static cl::opt<bool> EnableDPPCombine(
#  237|     "amdgpu-dpp-combine",
#  238|     cl::desc("Enable DPP combiner"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:242: constructor_uses_global_object: The constructor of global object "EnableAMDGPUAliasAnalysis" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAMDGPUAliasAnalysis" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  240|   
#  241|   // Enable address space based alias analysis
#  242|-> static cl::opt<bool> EnableAMDGPUAliasAnalysis("enable-amdgpu-aa", cl::Hidden,
#  243|     cl::desc("Enable AMDGPU Alias Analysis"),
#  244|     cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:247: constructor_uses_global_object: The constructor of global object "LateCFGStructurize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LateCFGStructurize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  245|   
#  246|   // Option to run late CFG structurizer
#  247|-> static cl::opt<bool, true> LateCFGStructurize(
#  248|     "amdgpu-late-structurize",
#  249|     cl::desc("Enable late CFG structurization"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:254: constructor_uses_global_object: The constructor of global object "EnableLibCallSimplify" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLibCallSimplify" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  252|   
#  253|   // Enable lib calls simplifications
#  254|-> static cl::opt<bool> EnableLibCallSimplify(
#  255|     "amdgpu-simplify-libcall",
#  256|     cl::desc("Enable amdgpu library simplifications"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:260: constructor_uses_global_object: The constructor of global object "EnableLowerKernelArguments" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLowerKernelArguments" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  258|     cl::Hidden);
#  259|   
#  260|-> static cl::opt<bool> EnableLowerKernelArguments(
#  261|     "amdgpu-ir-lower-kernel-arguments",
#  262|     cl::desc("Lower kernel argument loads in IR pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:266: constructor_uses_global_object: The constructor of global object "EnableRegReassign" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRegReassign" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  264|     cl::Hidden);
#  265|   
#  266|-> static cl::opt<bool> EnableRegReassign(
#  267|     "amdgpu-reassign-regs",
#  268|     cl::desc("Enable register reassign optimizations on gfx10+"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:272: constructor_uses_global_object: The constructor of global object "OptVGPRLiveRange" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OptVGPRLiveRange" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  270|     cl::Hidden);
#  271|   
#  272|-> static cl::opt<bool> OptVGPRLiveRange(
#  273|       "amdgpu-opt-vgpr-liverange",
#  274|       cl::desc("Enable VGPR liverange optimizations for if-else structure"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:277: constructor_uses_global_object: The constructor of global object "AMDGPUAtomicOptimizerStrategy" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AMDGPUAtomicOptimizerStrategy" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  275|       cl::init(true), cl::Hidden);
#  276|   
#  277|-> static cl::opt<ScanOptions> AMDGPUAtomicOptimizerStrategy(
#  278|       "amdgpu-atomic-optimizer-strategy",
#  279|       cl::desc("Select DPP or Iterative strategy for scan"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:288: constructor_uses_global_object: The constructor of global object "EnableSIModeRegisterPass" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSIModeRegisterPass" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  286|   
#  287|   // Enable Mode register optimization
#  288|-> static cl::opt<bool> EnableSIModeRegisterPass(
#  289|     "amdgpu-mode-register",
#  290|     cl::desc("Enable mode register pass"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:296: constructor_uses_global_object: The constructor of global object "EnableInsertDelayAlu" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableInsertDelayAlu" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  294|   // Enable GFX11+ s_delay_alu insertion
#  295|   static cl::opt<bool>
#  296|->     EnableInsertDelayAlu("amdgpu-enable-delay-alu",
#  297|                            cl::desc("Enable s_delay_alu insertion"),
#  298|                            cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:302: constructor_uses_global_object: The constructor of global object "EnableVOPD" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableVOPD" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  300|   // Enable GFX11+ VOPD
#  301|   static cl::opt<bool>
#  302|->     EnableVOPD("amdgpu-enable-vopd",
#  303|                  cl::desc("Enable VOPD, dual issue of VALU in wave32"),
#  304|                  cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:308: constructor_uses_global_object: The constructor of global object "EnableDCEInRA" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableDCEInRA" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  306|   // Option is used in lit tests to prevent deadcoding of patterns inspected.
#  307|   static cl::opt<bool>
#  308|-> EnableDCEInRA("amdgpu-dce-in-ra",
#  309|       cl::init(true), cl::Hidden,
#  310|       cl::desc("Enable machine DCE inside regalloc"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:312: constructor_uses_global_object: The constructor of global object "EnableSetWavePriority" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSetWavePriority" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  310|       cl::desc("Enable machine DCE inside regalloc"));
#  311|   
#  312|-> static cl::opt<bool> EnableSetWavePriority("amdgpu-set-wave-priority",
#  313|                                              cl::desc("Adjust wave priority"),
#  314|                                              cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:316: constructor_uses_global_object: The constructor of global object "EnableScalarIRPasses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableScalarIRPasses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  314|                                              cl::init(false), cl::Hidden);
#  315|   
#  316|-> static cl::opt<bool> EnableScalarIRPasses(
#  317|     "amdgpu-scalar-ir-passes",
#  318|     cl::desc("Enable scalar IR passes"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:322: constructor_uses_global_object: The constructor of global object "EnableStructurizerWorkarounds" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableStructurizerWorkarounds" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  320|     cl::Hidden);
#  321|   
#  322|-> static cl::opt<bool> EnableStructurizerWorkarounds(
#  323|       "amdgpu-enable-structurizer-workarounds",
#  324|       cl::desc("Enable workarounds for the StructurizeCFG pass"), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:327: constructor_uses_global_object: The constructor of global object "EnableLowerModuleLDS" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableLowerModuleLDS" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  325|       cl::Hidden);
#  326|   
#  327|-> static cl::opt<bool, true> EnableLowerModuleLDS(
#  328|       "amdgpu-enable-lower-module-lds", cl::desc("Enable lower module lds pass"),
#  329|       cl::location(AMDGPUTargetMachine::EnableLowerModuleLDS), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:332: constructor_uses_global_object: The constructor of global object "EnablePreRAOptimizations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePreRAOptimizations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  330|       cl::Hidden);
#  331|   
#  332|-> static cl::opt<bool> EnablePreRAOptimizations(
#  333|       "amdgpu-enable-pre-ra-optimizations",
#  334|       cl::desc("Enable Pre-RA optimizations pass"), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:337: constructor_uses_global_object: The constructor of global object "EnablePromoteKernelArguments" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePromoteKernelArguments" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  335|       cl::Hidden);
#  336|   
#  337|-> static cl::opt<bool> EnablePromoteKernelArguments(
#  338|       "amdgpu-enable-promote-kernel-arguments",
#  339|       cl::desc("Enable promotion of flat kernel pointer arguments to global"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:342: constructor_uses_global_object: The constructor of global object "EnableMaxIlpSchedStrategy" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMaxIlpSchedStrategy" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  340|       cl::Hidden, cl::init(true));
#  341|   
#  342|-> static cl::opt<bool> EnableMaxIlpSchedStrategy(
#  343|       "amdgpu-enable-max-ilp-scheduling-strategy",
#  344|       cl::desc("Enable scheduling strategy to maximize ILP for a single wave."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:347: constructor_uses_global_object: The constructor of global object "EnableRewritePartialRegUses" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableRewritePartialRegUses" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  345|       cl::Hidden, cl::init(false));
#  346|   
#  347|-> static cl::opt<bool> EnableRewritePartialRegUses(
#  348|       "amdgpu-enable-rewrite-partial-reg-uses",
#  349|       cl::desc("Enable rewrite partial reg uses pass"), cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:35: constructor_uses_global_object: The constructor of global object "UnrollThresholdPrivate" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnrollThresholdPrivate" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   #define DEBUG_TYPE "AMDGPUtti"
#   34|   
#   35|-> static cl::opt<unsigned> UnrollThresholdPrivate(
#   36|     "amdgpu-unroll-threshold-private",
#   37|     cl::desc("Unroll threshold for AMDGPU if private memory used in a loop"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:40: constructor_uses_global_object: The constructor of global object "UnrollThresholdLocal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnrollThresholdLocal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|     cl::init(2700), cl::Hidden);
#   39|   
#   40|-> static cl::opt<unsigned> UnrollThresholdLocal(
#   41|     "amdgpu-unroll-threshold-local",
#   42|     cl::desc("Unroll threshold for AMDGPU if local memory used in a loop"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:45: constructor_uses_global_object: The constructor of global object "UnrollThresholdIf" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnrollThresholdIf" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|     cl::init(1000), cl::Hidden);
#   44|   
#   45|-> static cl::opt<unsigned> UnrollThresholdIf(
#   46|     "amdgpu-unroll-threshold-if",
#   47|     cl::desc("Unroll threshold increment for AMDGPU for each if statement inside loop"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:50: constructor_uses_global_object: The constructor of global object "UnrollRuntimeLocal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnrollRuntimeLocal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|     cl::init(200), cl::Hidden);
#   49|   
#   50|-> static cl::opt<bool> UnrollRuntimeLocal(
#   51|     "amdgpu-unroll-runtime-local",
#   52|     cl::desc("Allow runtime unroll for AMDGPU if local memory used in a loop"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:55: constructor_uses_global_object: The constructor of global object "UnrollMaxBlockToAnalyze" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UnrollMaxBlockToAnalyze" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|     cl::init(true), cl::Hidden);
#   54|   
#   55|-> static cl::opt<unsigned> UnrollMaxBlockToAnalyze(
#   56|       "amdgpu-unroll-max-block-to-analyze",
#   57|       cl::desc("Inner loop block size threshold to analyze in unroll for AMDGPU"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:60: constructor_uses_global_object: The constructor of global object "ArgAllocaCost" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ArgAllocaCost" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|       cl::init(32), cl::Hidden);
#   59|   
#   60|-> static cl::opt<unsigned> ArgAllocaCost("amdgpu-inline-arg-alloca-cost",
#   61|                                          cl::Hidden, cl::init(4000),
#   62|                                          cl::desc("Cost of alloca argument"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:68: constructor_uses_global_object: The constructor of global object "ArgAllocaCutoff" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ArgAllocaCutoff" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|   // heuristic.
#   67|   static cl::opt<unsigned>
#   68|->     ArgAllocaCutoff("amdgpu-inline-arg-alloca-cutoff", cl::Hidden,
#   69|                       cl::init(256),
#   70|                       cl::desc("Maximum alloca size to use for inline cost"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:73: constructor_uses_global_object: The constructor of global object "InlineMaxBB" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InlineMaxBB" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   
#   72|   // Inliner constraint to achieve reasonable compilation time.
#   73|-> static cl::opt<size_t> InlineMaxBB(
#   74|       "amdgpu-inline-max-bb", cl::Hidden, cl::init(1100),
#   75|       cl::desc("Maximum number of BBs allowed in a function after inlining"

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:2894: var_decl: Declaring variable "RealVal".
llvm-17.0.6.src/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:2896: uninit_use_in_call: Using uninitialized value "RealVal.U" when calling "convertFromString".
# 2894|       APFloat RealVal(APFloat::IEEEdouble());
# 2895|       auto roundMode = APFloat::rmNearestTiesToEven;
# 2896|->     if (errorToBool(RealVal.convertFromString(Num, roundMode).takeError()))
# 2897|         return ParseStatus::Failure;
# 2898|       if (Negate)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:6284: var_decl: Declaring variable "OperandIdx" without initializer.
llvm-17.0.6.src/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:6325: uninit_use_in_call: Using uninitialized value "OperandIdx[1]" when calling "getOperand".
# 6323|     if (OptionalIdx.find(AMDGPUOperand::ImmTyExpCompr) != OptionalIdx.end()) {
# 6324|       Compr = true;
# 6325|->     Inst.getOperand(OperandIdx[1]) = Inst.getOperand(OperandIdx[2]);
# 6326|       Inst.getOperand(OperandIdx[2]).setReg(AMDGPU::NoRegister);
# 6327|       Inst.getOperand(OperandIdx[3]).setReg(AMDGPU::NoRegister);
llvm-17.0.6.src/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:6325: note: trimmed 1 message(s) with length over 512

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:42: constructor_uses_global_object: The constructor of global object "MFMAPaddingRatio" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MFMAPaddingRatio" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   40|   
#   41|   static cl::opt<unsigned, false, MFMAPaddingRatioParser>
#   42|->     MFMAPaddingRatio("amdgpu-mfma-padding-ratio", cl::init(0), cl::Hidden,
#   43|                        cl::desc("Fill a percentage of the latency between "
#   44|                                 "neighboring MFMA with s_nops."));

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:176: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:176: leaked_storage: Ignoring storage allocated by "this->Sch.SchedImpl.release()" leaks it.
#  174|       Sch.BaseClass::exitRegion();
#  175|       Sch.BaseClass::finishBlock();
#  176|->     Sch.SchedImpl.release();
#  177|       Sch.SchedImpl = std::move(SaveSchedImpl);
#  178|     }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNPreRALongBranchReg.cpp:30: constructor_uses_global_object: The constructor of global object "<unnamed>::LongBranchFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::LongBranchFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   namespace {
#   29|   
#   30|-> static cl::opt<double> LongBranchFactor(
#   31|       "amdgpu-long-branch-factor", cl::init(1.0), cl::Hidden,
#   32|       cl::desc("Factor to apply to what qualifies as a long branch "

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNRegPressure.cpp:192: var_decl: Declaring variable "Res".
llvm-17.0.6.src/lib/Target/AMDGPU/GCNRegPressure.cpp:209: uninit_use: Using uninitialized value "Res". Field "Res.InlineElts" is uninitialized.
#  207|         Res.push_back(RegisterMaskPair(Reg, UsedMask));
#  208|     }
#  209|->   return Res;
#  210|   }
#  211|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNSchedStrategy.cpp:36: constructor_uses_global_object: The constructor of global object "DisableUnclusterHighRP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableUnclusterHighRP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   
#   35|   static cl::opt<bool>
#   36|->     DisableUnclusterHighRP("amdgpu-disable-unclustred-high-rp-reschedule",
#   37|                              cl::Hidden,
#   38|                              cl::desc("Disable unclustred high register pressure "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNSchedStrategy.cpp:41: constructor_uses_global_object: The constructor of global object "ScheduleMetricBias" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ScheduleMetricBias" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   39|                                       "reduction scheduling stage."),
#   40|                              cl::init(false));
#   41|-> static cl::opt<unsigned> ScheduleMetricBias(
#   42|       "amdgpu-schedule-metric-bias", cl::Hidden,
#   43|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/GCNSchedStrategy.cpp:49: constructor_uses_global_object: The constructor of global object "RelaxedOcc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RelaxedOcc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|   
#   48|   static cl::opt<bool>
#   49|->     RelaxedOcc("amdgpu-schedule-relaxed-occupancy", cl::Hidden,
#   50|                  cl::desc("Relax occupancy targets for kernels which are memory "
#   51|                           "bound (amdgpu-membound-threshold), or "

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:182: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:185: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:186: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#  184|   
#  185|     if (Kind < FirstTargetFixupKind)
#  186|->     return MCAsmBackend::getFixupKindInfo(Kind);
#  187|   
#  188|     return Infos[Kind - FirstTargetFixupKind];

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:182: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:185: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUAsmBackend.cpp:188: illegal_address: "Infos[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 24 bytes.
#  186|       return MCAsmBackend::getFixupKindInfo(Kind);
#  187|   
#  188|->   return Infos[Kind - FirstTargetFixupKind];
#  189|   }
#  190|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp:27: constructor_uses_global_object: The constructor of global object "Keep16BitSuffixes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Keep16BitSuffixes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   25|   using namespace llvm::AMDGPU;
#   26|   
#   27|-> static cl::opt<bool> Keep16BitSuffixes(
#   28|     "amdgpu-keep-16-bit-reg-suffixes",
#   29|     cl::desc("Keep .l and .h suffixes in asm for debugging purposes"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp:268: var_decl: Declaring variable "DstMI" without initializer.
llvm-17.0.6.src/lib/Target/AMDGPU/R600ControlFlowFinalizer.cpp:295: uninit_use_in_call: Using uninitialized value "DstMI" when calling "insert". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  293|       }
#  294|       if ((DstRegs.find(SrcMI) == DstRegs.end())) {
#  295|->       DstRegs.insert(DstMI);
#  296|         return true;
#  297|       } else

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:258: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:282: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  280|         }
#  281|       }
#  282|->     return Result;
#  283|     }
#  284|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:258: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:313: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  311|       Result.push_back(std::pair(&MO, 0));
#  312|     }
#  313|->   return Result;
#  314|   }
#  315|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:1075: tainted_data_return: Called function "this->getIndirectIndexBegin(MF)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:1075: assign: Assigning: "Index" = "this->getIndirectIndexBegin(MF)".
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:1077: overflow: The expression "4 * Index" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:1077: overflow: The expression "4 * Index + Chan" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/AMDGPU/R600InstrInfo.cpp:1077: overflow_sink: "4 * Index + Chan", which might have underflowed, is passed to "llvm::R600::R600_TReg32RegClass.getRegister(4 * Index + Chan)".
# 1075|     for (int Index = getIndirectIndexBegin(MF); Index <= End; ++Index) {
# 1076|       for (unsigned Chan = 0; Chan < StackWidth; ++Chan) {
# 1077|->       unsigned Reg = R600::R600_TReg32RegClass.getRegister((4 * Index) + Chan);
# 1078|         TRI.reserveRegisterTuples(Reserved, Reg);
# 1079|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/R600OpenCLImageTypeLoweringPass.cpp:122: var_decl: Declaring variable "Res".
llvm-17.0.6.src/lib/Target/AMDGPU/R600OpenCLImageTypeLoweringPass.cpp:127: uninit_use: Using uninitialized value "Res". Field "Res.InlineElts" is uninitialized.
#  125|       Res.push_back(Node->getOperand(OpIdx));
#  126|     }
#  127|->   return Res;
#  128|   }
#  129|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/R600TargetMachine.cpp:26: constructor_uses_global_object: The constructor of global object "EnableR600StructurizeCFG" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableR600StructurizeCFG" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   
#   25|   static cl::opt<bool>
#   26|->     EnableR600StructurizeCFG("r600-ir-structurize",
#   27|                                cl::desc("Use StructurizeCFG IR pass"),
#   28|                                cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/R600TargetMachine.cpp:30: constructor_uses_global_object: The constructor of global object "EnableR600IfConvert" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableR600IfConvert" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|                                cl::init(true));
#   29|   
#   30|-> static cl::opt<bool> EnableR600IfConvert("r600-if-convert",
#   31|                                            cl::desc("Use if conversion pass"),
#   32|                                            cl::ReallyHidden, cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/R600TargetMachine.cpp:34: constructor_uses_global_object: The constructor of global object "EnableAMDGPUFunctionCallsOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAMDGPUFunctionCallsOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|                                            cl::ReallyHidden, cl::init(true));
#   33|   
#   34|-> static cl::opt<bool, true> EnableAMDGPUFunctionCallsOpt(
#   35|       "amdgpu-function-calls", cl::desc("Enable AMDGPU function call support"),
#   36|       cl::location(AMDGPUTargetMachine::EnableFunctionCalls), cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIFixSGPRCopies.cpp:79: constructor_uses_global_object: The constructor of global object "EnableM0Merge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableM0Merge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   #define DEBUG_TYPE "si-fix-sgpr-copies"
#   78|   
#   79|-> static cl::opt<bool> EnableM0Merge(
#   80|     "amdgpu-enable-merge-m0",
#   81|     cl::desc("Merge and hoist M0 initializations"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIFormMemoryClauses.cpp:29: constructor_uses_global_object: The constructor of global object "MaxClause" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxClause" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|   // and stall. They can stall even earlier if there are outstanding counters.
#   28|   static cl::opt<unsigned>
#   29|-> MaxClause("amdgpu-max-memory-clause", cl::Hidden, cl::init(15),
#   30|             cl::desc("Maximum length of a memory clause, instructions"));
#   31|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIFrameLowering.cpp:23: constructor_uses_global_object: The constructor of global object "EnableSpillVGPRToAGPR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSpillVGPRToAGPR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   #define DEBUG_TYPE "frame-info"
#   22|   
#   23|-> static cl::opt<bool> EnableSpillVGPRToAGPR(
#   24|     "amdgpu-spill-vgpr-to-agpr",
#   25|     cl::desc("Enable spilling VGPRs to AGPRs"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:51: constructor_uses_global_object: The constructor of global object "DisableLoopAlignment" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLoopAlignment" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|   STATISTIC(NumTailCalls, "Number of tail calls");
#   50|   
#   51|-> static cl::opt<bool> DisableLoopAlignment(
#   52|     "amdgpu-disable-loop-alignment",
#   53|     cl::desc("Do not align and prefetch loops"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:56: constructor_uses_global_object: The constructor of global object "UseDivergentRegisterIndexing" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseDivergentRegisterIndexing" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|     cl::init(false));
#   55|   
#   56|-> static cl::opt<bool> UseDivergentRegisterIndexing(
#   57|     "amdgpu-use-divergent-register-indexing",
#   58|     cl::Hidden,

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:6883: zero_return: Function call "ST->getNSAMaxSize()" returns 0.
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:6883: assignment: Assigning: "NSAMaxSize" = "ST->getNSAMaxSize()". The value of "NSAMaxSize" is now 0.
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:6893: overrun-buffer-arg: Calling "drop_front" with "llvm::ArrayRef<llvm::SDValue>(VAddrs).Data" and "NSAMaxSize - 1U" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
# 6891|     SDValue VAddr;
# 6892|     if (UsePartialNSA) {
# 6893|->     VAddr = getBuildDwordsVector(DAG, DL,
# 6894|                                    ArrayRef(VAddrs).drop_front(NSAMaxSize - 1));
# 6895|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:9408: var_decl: Declaring variable "K0Val".
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:9409: uninit_use_in_call: Using uninitialized value "K0Val.U" when calling "getConstantFP".
# 9407|   
# 9408|     const APFloat K0Val(0x1p+96f);
# 9409|->   const SDValue K0 = DAG.getConstantFP(K0Val, SL, MVT::f32);
# 9410|   
# 9411|     const APFloat K1Val(0x1p-32f);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:9411: var_decl: Declaring variable "K1Val".
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:9412: uninit_use_in_call: Using uninitialized value "K1Val.U" when calling "getConstantFP".
# 9410|   
# 9411|     const APFloat K1Val(0x1p-32f);
# 9412|->   const SDValue K1 = DAG.getConstantFP(K1Val, SL, MVT::f32);
# 9413|   
# 9414|     const SDValue One = DAG.getConstantFP(1.0, SL, MVT::f32);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:50: constructor_uses_global_object: The constructor of global object "ForceEmitZeroFlag" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceEmitZeroFlag" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|                 "Force emit s_waitcnt vmcnt(0) instrs");
#   49|   
#   50|-> static cl::opt<bool> ForceEmitZeroFlag(
#   51|     "amdgpu-waitcnt-forcezero",
#   52|     cl::desc("Force all waitcnt instrs to be emitted as s_waitcnt vmcnt(0) expcnt(0) lgkmcnt(0)"),

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:694: cond_at_most: Checking "Interval.first >= NUM_ALL_VGPRS" implies that "Interval.first" may be up to 512 on the false branch.
llvm-17.0.6.src/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:698: assignment: Assigning: "RegNo" = "Interval.first". The value of "RegNo" may now be up to 512.
llvm-17.0.6.src/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:698: incr: Incrementing "RegNo". The value of "RegNo" may now be up to 513.
llvm-17.0.6.src/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:699: overrun-local: Overrunning array "this->VgprVmemTypes" of 513 bytes at byte offset 513 using index "RegNo" (which evaluates to 513).
#  697|             VmemType V = getVmemType(Inst);
#  698|             for (int RegNo = Interval.first; RegNo < Interval.second; ++RegNo)
#  699|->             VgprVmemTypes[RegNo] |= 1 << V;
#  700|           }
#  701|         }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIInstrInfo.cpp:55: constructor_uses_global_object: The constructor of global object "BranchOffsetBits" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BranchOffsetBits" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   53|   // long branches.
#   54|   static cl::opt<unsigned>
#   55|-> BranchOffsetBits("amdgpu-s-branch-bits", cl::ReallyHidden, cl::init(16),
#   56|                    cl::desc("Restrict range of branch instructions (DEBUG)"));
#   57|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIInstrInfo.cpp:58: constructor_uses_global_object: The constructor of global object "Fix16BitCopies" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Fix16BitCopies" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|                    cl::desc("Restrict range of branch instructions (DEBUG)"));
#   57|   
#   58|-> static cl::opt<bool> Fix16BitCopies(
#   59|     "amdgpu-fix-16-bit-physreg-copies",
#   60|     cl::desc("Fix copies between 32 and 16 bit registers by extending to 32 bit"),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/AMDGPU/SIInstrInfo.cpp:8829: var_decl: Declaring variable "Mask" without initializer.
llvm-17.0.6.src/lib/Target/AMDGPU/SIInstrInfo.cpp:8847: uninit_use_in_call: Using uninitialized value "(uint64_t)Mask" when calling "countr_zero".
# 8845|         return false;
# 8846|   
# 8847|->     unsigned BitNo = llvm::countr_zero((uint64_t)Mask);
# 8848|       if (IsSigned && BitNo == SrcSize - 1)
# 8849|         return false;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SILowerControlFlow.cpp:66: constructor_uses_global_object: The constructor of global object "RemoveRedundantEndcf" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "RemoveRedundantEndcf" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   64|   
#   65|   static cl::opt<bool>
#   66|-> RemoveRedundantEndcf("amdgpu-remove-redundant-endcf",
#   67|       cl::init(true), cl::ReallyHidden);
#   68|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:33: constructor_uses_global_object: The constructor of global object "AmdgcnSkipCacheInvalidations" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AmdgcnSkipCacheInvalidations" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   #define PASS_NAME "SI Memory Legalizer"
#   32|   
#   33|-> static cl::opt<bool> AmdgcnSkipCacheInvalidations(
#   34|       "amdgcn-skip-cache-invalidations", cl::init(false), cl::Hidden,
#   35|       cl::desc("Use this to skip inserting cache invalidating instructions."));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIPreEmitPeephole.cpp:25: constructor_uses_global_object: The constructor of global object "SkipThresholdFlag" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SkipThresholdFlag" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   23|   static unsigned SkipThreshold;
#   24|   
#   25|-> static cl::opt<unsigned, true> SkipThresholdFlag(
#   26|       "amdgpu-skip-threshold", cl::Hidden,
#   27|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/SIRegisterInfo.cpp:32: constructor_uses_global_object: The constructor of global object "EnableSpillSGPRToVGPR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSpillSGPRToVGPR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   #include "AMDGPUGenRegisterInfo.inc"
#   31|   
#   32|-> static cl::opt<bool> EnableSpillSGPRToVGPR(
#   33|     "amdgpu-spill-sgpr-to-vgpr",
#   34|     cl::desc("Enable spilling SGPRs to VGPRs"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:36: constructor_uses_global_object: The constructor of global object "AmdhsaCodeObjectVersion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AmdhsaCodeObjectVersion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   34|   
#   35|   static llvm::cl::opt<unsigned>
#   36|->     AmdhsaCodeObjectVersion("amdhsa-code-object-version", llvm::cl::Hidden,
#   37|                               llvm::cl::desc("AMDHSA Code Object Version"),
#   38|                               llvm::cl::init(4));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:80: constructor_uses_global_object: The constructor of global object "EnableARM3Addr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableARM3Addr" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   78|   
#   79|   static cl::opt<bool>
#   80|-> EnableARM3Addr("enable-arm-3-addr-conv", cl::Hidden,
#   81|                  cl::desc("Enable ARM 2-addr to 3-addr conv"));
#   82|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:612: tainted_data_return: Called function "MI->findFirstPredOperandIdx()", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:612: assign: Assigning: "PIdx" = "MI->findFirstPredOperandIdx()".
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:616: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:616: overflow_sink: "PIdx + 1", which might have overflowed, is passed to "MI->getOperand(PIdx + 1)".
#  614|       MachineOperand &PMO = MI.getOperand(PIdx);
#  615|       PMO.setImm(Pred[0].getImm());
#  616|->     MI.getOperand(PIdx+1).setReg(Pred[1].getReg());
#  617|   
#  618|       // Thumb 1 arithmetic instructions do not set CPSR when executed inside an

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:2248: tainted_data_return: Called function "MI->findFirstPredOperandIdx()", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:2248: assign: Assigning: "PIdx" = "MI->findFirstPredOperandIdx()".
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:2254: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:2254: overflow_sink: "PIdx + 1", which might be negative, is passed to "MI->getOperand(PIdx + 1)".
# 2252|     }
# 2253|   
# 2254|->   PredReg = MI.getOperand(PIdx+1).getReg();
# 2255|     return (ARMCC::CondCodes)MI.getOperand(PIdx).getImm();
# 2256|   }

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5879: extract: Calling "operator []" which extracts wrapped state from parameter "RepeatedSequenceLocs".
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5879: assign: Assigning: "FirstCand" = "RepeatedSequenceLocs[0UL]".
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:6067: invalidate: Calling "operator =" invalidates the internal representation of parameter "RepeatedSequenceLocs".
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:6078: use_after_free: Using invalidated internal representation of parameter "RepeatedSequenceLocs".
# 6076|       // check if the range contains a call.  These require a save + restore of
# 6077|       // the link register.
# 6078|->     if (std::any_of(FirstCand.front(), FirstCand.back(),
# 6079|                       [](const MachineInstr &MI) { return MI.isCall(); }))
# 6080|         NumBytesToCreateFrame += Costs.SaveRestoreLROnStack;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseRegisterInfo.cpp:849: tainted_data_return: Called function "MI->findFirstPredOperandIdx()", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseRegisterInfo.cpp:849: assign: Assigning: "PIdx" = "MI->findFirstPredOperandIdx()".
llvm-17.0.6.src/lib/Target/ARM/ARMBaseRegisterInfo.cpp:852: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseRegisterInfo.cpp:852: overflow_sink: "PIdx + 1", which might have overflowed, is passed to "MI->getOperand(PIdx + 1)".
#  850|     ARMCC::CondCodes Pred = (PIdx == -1)
#  851|       ? ARMCC::AL : (ARMCC::CondCodes)MI.getOperand(PIdx).getImm();
#  852|->   Register PredReg = (PIdx == -1) ? Register() : MI.getOperand(PIdx+1).getReg();
#  853|   
#  854|     const MCInstrDesc &MCID = MI.getDesc();

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMCallingConv.cpp:88: cond_const: Checking "i < 2U" implies that "i" is 2 on the false branch.
llvm-17.0.6.src/lib/Target/ARM/ARMCallingConv.cpp:92: overrun-local: Overrunning array "LoRegList" of 2 2-byte elements at element index 2 (byte offset 5) using index "i" (which evaluates to 2).
#   90|         break;
#   91|   
#   92|->   unsigned T = State.AllocateReg(LoRegList[i]);
#   93|     (void)T;
#   94|     assert(T == LoRegList[i] && "Could not allocate register");

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMCallingConv.cpp:88: cond_const: Checking "i < 2U" implies that "i" is 2 on the false branch.
llvm-17.0.6.src/lib/Target/ARM/ARMCallingConv.cpp:97: overrun-local: Overrunning array "LoRegList" of 2 2-byte elements at element index 2 (byte offset 5) using index "i" (which evaluates to 2).
#   95|   
#   96|     State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
#   97|->   State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, LoRegList[i],
#   98|                                            LocVT, LocInfo));
#   99|     return true;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMCallingConv.cpp:124: cond_const: Checking "i < 2U" implies that "i" is 2 on the false branch.
llvm-17.0.6.src/lib/Target/ARM/ARMCallingConv.cpp:129: overrun-local: Overrunning array "LoRegList" of 2 2-byte elements at element index 2 (byte offset 5) using index "i" (which evaluates to 2).
#  127|   
#  128|     State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
#  129|->   State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, LoRegList[i],
#  130|                                            LocVT, LocInfo));
#  131|     return true;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMConstantIslandPass.cpp:78: constructor_uses_global_object: The constructor of global object "AdjustJumpTableBlocks" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AdjustJumpTableBlocks" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   
#   77|   static cl::opt<bool>
#   78|-> AdjustJumpTableBlocks("arm-adjust-jump-tables", cl::Hidden, cl::init(true),
#   79|             cl::desc("Adjust basic block layout to better use TB[BH]"));
#   80|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMConstantIslandPass.cpp:82: constructor_uses_global_object: The constructor of global object "CPMaxIteration" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CPMaxIteration" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   
#   81|   static cl::opt<unsigned>
#   82|-> CPMaxIteration("arm-constant-island-max-iteration", cl::Hidden, cl::init(30),
#   83|             cl::desc("The max number of iteration for converge"));
#   84|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMConstantIslandPass.cpp:85: constructor_uses_global_object: The constructor of global object "SynthesizeThumb1TBB" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SynthesizeThumb1TBB" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|             cl::desc("The max number of iteration for converge"));
#   84|   
#   85|-> static cl::opt<bool> SynthesizeThumb1TBB(
#   86|       "arm-synthesize-thumb-1-tbb", cl::Hidden, cl::init(true),
#   87|       cl::desc("Use compressed jump tables in Thumb-1 by synthesizing an "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMExpandPseudoInsts.cpp:35: constructor_uses_global_object: The constructor of global object "VerifyARMPseudo" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VerifyARMPseudo" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   33|   
#   34|   static cl::opt<bool>
#   35|-> VerifyARMPseudo("verify-arm-pseudo-expand", cl::Hidden,
#   36|                   cl::desc("Verify machine code after expanding ARM pseudos"));
#   37|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMFastISel.cpp:1691: assignment: Assigning: "LC" = "UNKNOWN_LIBCALL".
llvm-17.0.6.src/lib/Target/ARM/ARMFastISel.cpp:1704: overrun-call: Overrunning callee's array of size 644 by passing argument "LC" (which evaluates to 644) in call to "ARMEmitLibcall".
# 1702|     assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SDIV!");
# 1703|   
# 1704|->   return ARMEmitLibcall(I, LC);
# 1705|   }
# 1706|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMFastISel.cpp:1720: assignment: Assigning: "LC" = "UNKNOWN_LIBCALL".
llvm-17.0.6.src/lib/Target/ARM/ARMFastISel.cpp:1733: overrun-call: Overrunning callee's array of size 644 by passing argument "LC" (which evaluates to 644) in call to "ARMEmitLibcall".
# 1731|     assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SREM!");
# 1732|   
# 1733|->   return ARMEmitLibcall(I, LC);
# 1734|   }
# 1735|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMFrameLowering.cpp:169: constructor_uses_global_object: The constructor of global object "SpillAlignedNEONRegs" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SpillAlignedNEONRegs" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  167|   
#  168|   static cl::opt<bool>
#  169|-> SpillAlignedNEONRegs("align-neon-spills", cl::Hidden, cl::init(true),
#  170|                        cl::desc("Align ARM NEON spills in prolog and epilog"));
#  171|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMHazardRecognizer.cpp:23: constructor_uses_global_object: The constructor of global object "DataBankMask" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DataBankMask" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   21|   using namespace llvm;
#   22|   
#   23|-> static cl::opt<int> DataBankMask("arm-data-bank-mask", cl::init(-1),
#   24|                                    cl::Hidden);
#   25|   static cl::opt<bool> AssumeITCMConflict("arm-assume-itcm-bankconflict",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMHazardRecognizer.cpp:25: constructor_uses_global_object: The constructor of global object "AssumeITCMConflict" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AssumeITCMConflict" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   23|   static cl::opt<int> DataBankMask("arm-data-bank-mask", cl::init(-1),
#   24|                                    cl::Hidden);
#   25|-> static cl::opt<bool> AssumeITCMConflict("arm-assume-itcm-bankconflict",
#   26|                                           cl::init(false), cl::Hidden);
#   27|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:46: constructor_uses_global_object: The constructor of global object "DisableShifterOp" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableShifterOp" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   
#   45|   static cl::opt<bool>
#   46|-> DisableShifterOp("disable-shifter-op", cl::Hidden,
#   47|     cl::desc("Disable isel of shifter-op"),
#   48|     cl::init(false));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3204: var_decl: Declaring variable "ImmAPF".
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3209: uninit_use_in_call: Using uninitialized value "ImmAPF.U" when calling "~APFloat".
# 3207|     case ARMISD::VDUP: {
# 3208|       if (!isa<ConstantSDNode>(ImmNode.getOperand(0)))
# 3209|->       return false;
# 3210|       unsigned Imm = ImmNode.getConstantOperandVal(0);
# 3211|       if (ImmNode.getOpcode() == ARMISD::VMOVIMM)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3213: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(((ScalarBits == 32U) ? llvm::APFloatBase::IEEEsingle() : llvm::APFloatBase::IEEEhalf()), llvm::APInt(ScalarBits, Imm, false))".
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3213: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3211|       if (ImmNode.getOpcode() == ARMISD::VMOVIMM)
# 3212|         Imm = ARM_AM::decodeVMOVModImm(Imm, ScalarBits);
# 3213|->     ImmAPF =
# 3214|           APFloat(ScalarBits == 32 ? APFloat::IEEEsingle() : APFloat::IEEEhalf(),
# 3215|                   APInt(ScalarBits, Imm));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3219: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::ARM_AM::getFPImmFloat(ImmNode.getConstantOperandVal(0U)))".
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3219: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 3217|     }
# 3218|     case ARMISD::VMOVFPIMM: {
# 3219|->     ImmAPF = APFloat(ARM_AM::getFPImmFloat(ImmNode.getConstantOperandVal(0)));
# 3220|       break;
# 3221|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3297: var_decl: Declaring variable "Opcode" without initializer.
llvm-17.0.6.src/lib/Target/ARM/ARMISelDAGToDAG.cpp:3310: uninit_use_in_call: Using uninitialized value "Opcode" when calling "getMachineNode".
# 3308|       AddEmptyMVEPredicateToOps(Ops, dl, Type);
# 3309|   
# 3310|->     ReplaceNode(N, CurDAG->getMachineNode(Opcode, dl, Type, Ops));
# 3311|       return true;
# 3312|     }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:131: constructor_uses_global_object: The constructor of global object "ARMInterworking" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ARMInterworking" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  129|   
#  130|   static cl::opt<bool>
#  131|-> ARMInterworking("arm-interworking", cl::Hidden,
#  132|     cl::desc("Enable / disable ARM interworking (for debugging only)"),
#  133|     cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:135: constructor_uses_global_object: The constructor of global object "EnableConstpoolPromotion" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableConstpoolPromotion" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  133|     cl::init(true));
#  134|   
#  135|-> static cl::opt<bool> EnableConstpoolPromotion(
#  136|       "arm-promote-constant", cl::Hidden,
#  137|       cl::desc("Enable / disable promotion of unnamed_addr constants into "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:140: constructor_uses_global_object: The constructor of global object "ConstpoolPromotionMaxSize" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ConstpoolPromotionMaxSize" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  138|                "constant pools"),
#  139|       cl::init(false)); // FIXME: set to true by default once PR32780 is fixed
#  140|-> static cl::opt<unsigned> ConstpoolPromotionMaxSize(
#  141|       "arm-promote-constant-max-size", cl::Hidden,
#  142|       cl::desc("Maximum size of constant to promote into a constant pool"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:144: constructor_uses_global_object: The constructor of global object "ConstpoolPromotionMaxTotal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ConstpoolPromotionMaxTotal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  142|       cl::desc("Maximum size of constant to promote into a constant pool"),
#  143|       cl::init(64));
#  144|-> static cl::opt<unsigned> ConstpoolPromotionMaxTotal(
#  145|       "arm-promote-constant-max-total", cl::Hidden,
#  146|       cl::desc("Maximum size of ALL constants to promote into a constant pool"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:150: constructor_uses_global_object: The constructor of global object "MVEMaxSupportedInterleaveFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MVEMaxSupportedInterleaveFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  148|   
#  149|   cl::opt<unsigned>
#  150|-> MVEMaxSupportedInterleaveFactor("mve-max-interleave-factor", cl::Hidden,
#  151|     cl::desc("Maximum interleave factor for MVE VLDn to generate."),
#  152|     cl::init(2));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:5060: var_decl: Declaring variable "NewOpcode" without initializer.
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:5099: uninit_use_in_call: Using uninitialized value "NewOpcode" when calling "getNode".
# 5097|   
# 5098|     SDLoc dl(Op);
# 5099|->   SDValue Add =
# 5100|         DAG.getNode(NewOpcode, dl, MVT::i32,
# 5101|                     DAG.getSExtOrTrunc(Op->getOperand(0), dl, MVT::i32),

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:10352: overrun-call: Overrunning callee's array of size 8 by passing argument "llvm::cast(Op)->getSuccessOrdering()" (which evaluates to 15) in call to "isStrongerThanMonotonic".
#10350|   
#10351|   static SDValue LowerAtomicLoadStore(SDValue Op, SelectionDAG &DAG) {
#10352|->   if (isStrongerThanMonotonic(cast<AtomicSDNode>(Op)->getSuccessOrdering()))
#10353|       // Acquire/Release load/store is not legal for targets without a dmb or
#10354|       // equivalent available.

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:94: constructor_uses_global_object: The constructor of global object "AssumeMisalignedLoadStores" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AssumeMisalignedLoadStores" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   92|   /// \see mayCombineMisaligned()
#   93|   static cl::opt<bool>
#   94|-> AssumeMisalignedLoadStores("arm-assume-misaligned-load-store", cl::Hidden,
#   95|       cl::init(false), cl::desc("Be more conservative in ARM load/store opt"));
#   96|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:2196: constructor_uses_global_object: The constructor of global object "InstReorderLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "InstReorderLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
# 2194|   // Limit the number of instructions to be rescheduled.
# 2195|   // FIXME: tune this limit, and/or come up with some better heuristics.
# 2196|-> static cl::opt<unsigned> InstReorderLimit("arm-prera-ldst-opt-reorder-limit",
# 2197|                                             cl::init(8), cl::Hidden);
# 2198|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3024: tainted_data_return: Called function "getBaseOperandIndex(MI)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3024: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3033: overflow: The expression "BaseOp + 1U" is deemed underflowed because at least one of its arguments has underflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3033: overflow_sink: "BaseOp + 1U", which might have underflowed, is passed to "MI->getOperand(BaseOp + 1U)".
# 3031|     MRI.constrainRegClass(NewBaseReg, TRC);
# 3032|   
# 3033|->   int OldOffset = MI->getOperand(BaseOp + 1).getImm();
# 3034|     if (isLegalAddressImm(MI->getOpcode(), OldOffset - Offset, TII))
# 3035|       MI->getOperand(BaseOp + 1).setImm(OldOffset - Offset);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3165: tainted_data_return: Called function "getBaseOperandIndex(Use)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3165: assign: Assigning: "BaseOp" = "getBaseOperandIndex(Use)".
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3174: overflow: The expression "BaseOp + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3174: overflow_sink: "BaseOp + 1", which might have overflowed, is passed to "Use->getOperand(BaseOp + 1)".
# 3172|       if (isPreIndex(Use) || isPostIndex(Use))
# 3173|         PrePostInc = &Use;
# 3174|->     else if (Use.getOperand(BaseOp + 1).getImm() == 0)
# 3175|         BaseAccess = &Use;
# 3176|       else

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3223: tainted_data_return: Called function "getBaseOperandIndex(PrePostInc)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3223: assign: Assigning: "BaseOp" = "getBaseOperandIndex(PrePostInc)".
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3224: overflow: The expression "BaseOp + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3224: overflow_sink: "BaseOp + 1", which might be negative, is passed to "PrePostInc->getOperand(BaseOp + 1)".
# 3222|                         << "indexed VirtualReg " << Base.virtRegIndex() << "\n");
# 3223|       int BaseOp = getBaseOperandIndex(*PrePostInc);
# 3224|->     IncrementOffset = PrePostInc->getOperand(BaseOp+1).getImm();
# 3225|       BaseAccess = PrePostInc;
# 3226|       NewBaseReg = PrePostInc->getOperand(0).getReg();

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3244: tainted_data_return: Called function "getBaseOperandIndex(Use)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3244: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3245: overflow: The expression "BaseOp + 1U" is deemed underflowed because at least one of its arguments has underflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:3245: overflow_sink: "BaseOp + 1U", which might have underflowed, is passed to "Use->getOperand(BaseOp + 1U)".
# 3243|         SuccessorAccesses.insert(Use);
# 3244|         unsigned BaseOp = getBaseOperandIndex(*Use);
# 3245|->       if (!isLegalOrConvertableAddressImm(Use->getOpcode(),
# 3246|                                             Use->getOperand(BaseOp + 1).getImm() -
# 3247|                                                 IncrementOffset,

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:80: constructor_uses_global_object: The constructor of global object "DisableTailPredication" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableTailPredication" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   78|   
#   79|   static cl::opt<bool>
#   80|-> DisableTailPredication("arm-loloops-disable-tailpred", cl::Hidden,
#   81|       cl::desc("Disable tail-predication in the ARM LowOverheadLoop pass"),
#   82|       cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:85: constructor_uses_global_object: The constructor of global object "DisableOmitDLS" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableOmitDLS" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|   
#   84|   static cl::opt<bool>
#   85|->     DisableOmitDLS("arm-disable-omit-dls", cl::Hidden,
#   86|                      cl::desc("Disable omitting 'dls lr, lr' instructions"),
#   87|                      cl::init(false));

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:90: tainted_data_return: Called function "llvm::findFirstVPTPredOperandIdx(MI)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:90: assign: Assigning: "PIdx" = "llvm::findFirstVPTPredOperandIdx(MI)".
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:91: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:91: overflow_sink: "PIdx + 1", which might be negative, is passed to "MI->getOperand(PIdx + 1)".
#   89|   static bool isVectorPredicated(MachineInstr *MI) {
#   90|     int PIdx = llvm::findFirstVPTPredOperandIdx(*MI);
#   91|->   return PIdx != -1 && MI->getOperand(PIdx + 1).getReg() == ARM::VPR;
#   92|   }
#   93|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:1584: tainted_data_return: Called function "llvm::findFirstVPTPredOperandIdx(MI)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:1584: assign: Assigning: "PIdx" = "llvm::findFirstVPTPredOperandIdx(MI)".
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:1589: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/ARMLowOverheadLoops.cpp:1589: overflow_sink: "PIdx + 1", which might have overflowed, is passed to "MI->getOperand(PIdx + 1)".
# 1587|              "Expected Then predicate!");
# 1588|       MI->getOperand(PIdx).setImm(ARMVCC::None);
# 1589|->     MI->getOperand(PIdx + 1).setReg(0);
# 1590|     };
# 1591|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMParallelDSP.cpp:45: constructor_uses_global_object: The constructor of global object "DisableParallelDSP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableParallelDSP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   43|   
#   44|   static cl::opt<bool>
#   45|-> DisableParallelDSP("disable-arm-parallel-dsp", cl::Hidden, cl::init(false),
#   46|                      cl::desc("Disable the ARM Parallel DSP pass"));
#   47|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMParallelDSP.cpp:49: constructor_uses_global_object: The constructor of global object "NumLoadLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NumLoadLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|   
#   48|   static cl::opt<unsigned>
#   49|-> NumLoadLimit("arm-parallel-dsp-load-limit", cl::Hidden, cl::init(16),
#   50|                cl::desc("Limit the number of loads analysed"));
#   51|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMSLSHardening.cpp:344: assignment: Assigning: "FirstOpIdxToRemove" = "std::max(ImpLROpIdx, ImpSPOpIdx)". The value of "FirstOpIdxToRemove" is now -1.
llvm-17.0.6.src/lib/Target/ARM/ARMSLSHardening.cpp:346: overrun-buffer-arg: Calling "removeOperand" with "BL->Operands" and "FirstOpIdxToRemove" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  344|     int FirstOpIdxToRemove = std::max(ImpLROpIdx, ImpSPOpIdx);
#  345|     int SecondOpIdxToRemove = std::min(ImpLROpIdx, ImpSPOpIdx);
#  346|->   BL->removeOperand(FirstOpIdxToRemove);
#  347|     BL->removeOperand(SecondOpIdxToRemove);
#  348|     // Now copy over the implicit operands from the original IndirectCall

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/ARMSLSHardening.cpp:345: assignment: Assigning: "SecondOpIdxToRemove" = "std::min(ImpLROpIdx, ImpSPOpIdx)". The value of "SecondOpIdxToRemove" is now -1.
llvm-17.0.6.src/lib/Target/ARM/ARMSLSHardening.cpp:347: overrun-buffer-arg: Calling "removeOperand" with "BL->Operands" and "SecondOpIdxToRemove" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  345|     int SecondOpIdxToRemove = std::min(ImpLROpIdx, ImpSPOpIdx);
#  346|     BL->removeOperand(FirstOpIdxToRemove);
#  347|->   BL->removeOperand(SecondOpIdxToRemove);
#  348|     // Now copy over the implicit operands from the original IndirectCall
#  349|     BL->copyImplicitOps(MF, IndirectCall);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMSelectionDAGInfo.cpp:22: constructor_uses_global_object: The constructor of global object "EnableMemtransferTPLoop" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMemtransferTPLoop" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   20|   #define DEBUG_TYPE "arm-selectiondag-info"
#   21|   
#   22|-> cl::opt<TPLoop::MemTransfer> EnableMemtransferTPLoop(
#   23|       "arm-memtransfer-tploop", cl::Hidden,
#   24|       cl::desc("Control conversion of memcpy to "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMSubtarget.cpp:50: constructor_uses_global_object: The constructor of global object "UseFusedMulOps" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseFusedMulOps" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|   
#   49|   static cl::opt<bool>
#   50|-> UseFusedMulOps("arm-use-mulops",
#   51|                  cl::init(true), cl::Hidden);
#   52|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMSubtarget.cpp:59: constructor_uses_global_object: The constructor of global object "IT" itself makes use of global object "llvm::cl::AllSubCommands" defined in another compilation unit.  The order of construction is unspecified, so "IT" might be created before "llvm::cl::AllSubCommands" is available.
#   57|   
#   58|   static cl::opt<ITMode>
#   59|->     IT(cl::desc("IT block support"), cl::Hidden, cl::init(DefaultIT),
#   60|          cl::values(clEnumValN(DefaultIT, "arm-default-it",
#   61|                                "Generate any type of IT block"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMSubtarget.cpp:68: constructor_uses_global_object: The constructor of global object "ForceFastISel" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceFastISel" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   66|   /// currently supported (for testing only).
#   67|   static cl::opt<bool>
#   68|-> ForceFastISel("arm-force-fast-isel",
#   69|                  cl::init(false), cl::Hidden);
#   70|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMSubtarget.cpp:71: constructor_uses_global_object: The constructor of global object "EnableSubRegLiveness" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSubRegLiveness" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|                  cl::init(false), cl::Hidden);
#   70|   
#   71|-> static cl::opt<bool> EnableSubRegLiveness("arm-enable-subreg-liveness",
#   72|                                             cl::init(false), cl::Hidden);
#   73|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetMachine.cpp:62: constructor_uses_global_object: The constructor of global object "DisableA15SDOptimization" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableA15SDOptimization" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   60|   
#   61|   static cl::opt<bool>
#   62|-> DisableA15SDOptimization("disable-a15-sd-optimization", cl::Hidden,
#   63|                      cl::desc("Inhibit optimization of S->D register accesses on A15"),
#   64|                      cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetMachine.cpp:67: constructor_uses_global_object: The constructor of global object "EnableAtomicTidy" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableAtomicTidy" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   
#   66|   static cl::opt<bool>
#   67|-> EnableAtomicTidy("arm-atomic-cfg-tidy", cl::Hidden,
#   68|                    cl::desc("Run SimplifyCFG after expanding atomic operations"
#   69|                             " to make use of cmpxchg flow-based information"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetMachine.cpp:73: constructor_uses_global_object: The constructor of global object "EnableARMLoadStoreOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableARMLoadStoreOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   
#   72|   static cl::opt<bool>
#   73|-> EnableARMLoadStoreOpt("arm-load-store-opt", cl::Hidden,
#   74|                         cl::desc("Enable ARM load/store optimization pass"),
#   75|                         cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetMachine.cpp:79: constructor_uses_global_object: The constructor of global object "EnableGlobalMerge" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableGlobalMerge" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   // FIXME: Unify control over GlobalMerge.
#   78|   static cl::opt<cl::boolOrDefault>
#   79|-> EnableGlobalMerge("arm-global-merge", cl::Hidden,
#   80|                     cl::desc("Enable the global merge pass"));
#   81|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetTransformInfo.cpp:47: constructor_uses_global_object: The constructor of global object "EnableMaskedLoadStores" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMaskedLoadStores" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   45|   #define DEBUG_TYPE "armtti"
#   46|   
#   47|-> static cl::opt<bool> EnableMaskedLoadStores(
#   48|     "enable-arm-maskedldst", cl::Hidden, cl::init(true),
#   49|     cl::desc("Enable the generation of masked loads and stores"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetTransformInfo.cpp:51: constructor_uses_global_object: The constructor of global object "DisableLowOverheadLoops" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLowOverheadLoops" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|     cl::desc("Enable the generation of masked loads and stores"));
#   50|   
#   51|-> static cl::opt<bool> DisableLowOverheadLoops(
#   52|     "disable-arm-loloops", cl::Hidden, cl::init(false),
#   53|     cl::desc("Disable the generation of low-overhead loops"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/ARMTargetTransformInfo.cpp:56: constructor_uses_global_object: The constructor of global object "AllowWLSLoops" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AllowWLSLoops" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   
#   55|   static cl::opt<bool>
#   56|->     AllowWLSLoops("allow-arm-wlsloops", cl::Hidden, cl::init(true),
#   57|                     cl::desc("Enable the generation of WLS loops"));
#   58|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:85: constructor_uses_global_object: The constructor of global object "<unnamed>::ImplicitItMode" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::ImplicitItMode" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|   enum class ImplicitItModeTy { Always, Never, ARMOnly, ThumbOnly };
#   84|   
#   85|-> static cl::opt<ImplicitItModeTy> ImplicitItMode(
#   86|       "arm-implicit-it", cl::init(ImplicitItModeTy::ARMOnly),
#   87|       cl::desc("Allow conditional instructions outdside of an IT block"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:97: constructor_uses_global_object: The constructor of global object "<unnamed>::AddBuildAttributes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::AddBuildAttributes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   95|                             "Warn in ARM, emit implicit ITs in Thumb")));
#   96|   
#   97|-> static cl::opt<bool> AddBuildAttributes("arm-add-build-attributes",
#   98|                                           cl::init(false));
#   99|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:6012: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(RealVal)".
llvm-17.0.6.src/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:6012: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 6010|         return Error(Loc, "encoded floating point value out of range");
# 6011|       float RealVal = ARM_AM::getFPImmFloat(Val);
# 6012|->     Val = APFloat(RealVal).bitcastToAPInt().getZExtValue();
# 6013|   
# 6014|       Operands.push_back(ARMOperand::CreateImm(

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:191: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:194: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:195: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#  193|   
#  194|     if (Kind < FirstTargetFixupKind)
#  195|->     return MCAsmBackend::getFixupKindInfo(Kind);
#  196|   
#  197|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:191: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:194: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:199: illegal_address: "((this->Endian == little) ? InfosLE : InfosBE)[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 984 bytes.
#  197|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&
#  198|            "Invalid kind!");
#  199|->   return (Endian == support::little ? InfosLE
#  200|                                       : InfosBE)[Kind - FirstTargetFixupKind];
#  201|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:1091: var_decl: Declaring variable "FullSizeBytes" without initializer.
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp:1102: uninit_use: Using uninitialized value "FullSizeBytes".
# 1100|     // bitfields above.
# 1101|     for (unsigned i = 0; i != NumBytes; ++i) {
# 1102|->     unsigned Idx = Endian == support::little ? i : (FullSizeBytes - 1 - i);
# 1103|       Data[Offset + Idx] |= uint8_t((Value >> (i * 8)) & 0xff);
# 1104|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:581: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::bit_cast(uint64_t const(MO->getDFPImm())))".
llvm-17.0.6.src/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:581: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  579|       return static_cast<unsigned>(MO.getImm());
#  580|     } else if (MO.isDFPImm()) {
#  581|->     return static_cast<unsigned>(APFloat(bit_cast<double>(MO.getDFPImm()))
#  582|                                        .bitcastToAPInt()
#  583|                                        .getHiBits(32)

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MLxExpansionPass.cpp:32: constructor_uses_global_object: The constructor of global object "ForceExapnd" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceExapnd" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   30|   
#   31|   static cl::opt<bool>
#   32|-> ForceExapnd("expand-all-fp-mlx", cl::init(false), cl::Hidden);
#   33|   static cl::opt<unsigned>
#   34|   ExpandLimit("expand-limit", cl::init(~0U), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MLxExpansionPass.cpp:34: constructor_uses_global_object: The constructor of global object "ExpandLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExpandLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   ForceExapnd("expand-all-fp-mlx", cl::init(false), cl::Hidden);
#   33|   static cl::opt<unsigned>
#   34|-> ExpandLimit("expand-limit", cl::init(~0U), cl::Hidden);
#   35|   
#   36|   STATISTIC(NumExpand, "Number of fp MLA / MLS instructions expanded");

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MVEGatherScatterLowering.cpp:50: constructor_uses_global_object: The constructor of global object "EnableMaskedGatherScatters" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMaskedGatherScatters" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   48|   #define DEBUG_TYPE "arm-mve-gather-scatter-lowering"
#   49|   
#   50|-> cl::opt<bool> EnableMaskedGatherScatters(
#   51|       "enable-arm-maskedgatscat", cl::Hidden, cl::init(true),
#   52|       cl::desc("Enable the generation of masked gathers and scatters"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MVELaneInterleavingPass.cpp:79: constructor_uses_global_object: The constructor of global object "EnableInterleave" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableInterleave" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   77|   #define DEBUG_TYPE "mve-laneinterleave"
#   78|   
#   79|-> cl::opt<bool> EnableInterleave(
#   80|       "enable-mve-interleave", cl::Hidden, cl::init(true),
#   81|       cl::desc("Enable interleave MVE vector operation lowering"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:39: constructor_uses_global_object: The constructor of global object "MergeEndDec" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MergeEndDec" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   
#   38|   static cl::opt<bool>
#   39|-> MergeEndDec("arm-enable-merge-loopenddec", cl::Hidden,
#   40|       cl::desc("Enable merging Loop End and Dec instructions."),
#   41|       cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:44: constructor_uses_global_object: The constructor of global object "SetLRPredicate" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SetLRPredicate" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   
#   43|   static cl::opt<bool>
#   44|-> SetLRPredicate("arm-set-lr-predicate", cl::Hidden,
#   45|       cl::desc("Enable setting lr as a predicate in tail predication regions."),
#   46|       cl::init(true));

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:538: tainted_data_return: Called function "llvm::findFirstVPTPredOperandIdx(MI)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:538: assign: Assigning: "Idx" = "llvm::findFirstVPTPredOperandIdx(MI)".
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:539: overflow: The expression "Idx + 2" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:539: overflow_sink: "Idx + 2", which might be negative, is passed to "MI->getOperand(Idx + 2)".
#  537|       for (MachineInstr *MI : MVEInstrs) {
#  538|         int Idx = findFirstVPTPredOperandIdx(*MI);
#  539|->       MI->getOperand(Idx + 2).setReg(LR);
#  540|       }
#  541|     }

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:928: tainted_data_return: Called function "llvm::findFirstVPTPredOperandIdx(Instr)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:928: assign: Assigning: "PIdx" = "llvm::findFirstVPTPredOperandIdx(Instr)".
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:931: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:931: overflow_sink: "PIdx + 1", which might be negative, is passed to "Instr->getOperand(PIdx + 1)".
#  929|       if (PIdx == -1)
#  930|         continue;
#  931|->     Register VPR = Instr.getOperand(PIdx + 1).getReg();
#  932|       if (!VPR.isVirtual())
#  933|         continue;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/MVETailPredication.cpp:60: constructor_uses_global_object: The constructor of global object "EnableTailPredication" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableTailPredication" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|   #define DESC "Transform predicated vector loops to use MVE tail predication"
#   59|   
#   60|-> cl::opt<TailPredication::Mode> EnableTailPredication(
#   61|      "tail-predication", cl::desc("MVE tail-predication pass options"),
#   62|      cl::init(TailPredication::Enabled),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/Thumb2InstrInfo.cpp:39: constructor_uses_global_object: The constructor of global object "OldT2IfCvt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "OldT2IfCvt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   
#   38|   static cl::opt<bool>
#   39|-> OldT2IfCvt("old-thumb2-ifcvt", cl::Hidden,
#   40|              cl::desc("Use old-style Thumb2 if-conversion heuristics"),
#   41|              cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/Thumb2InstrInfo.cpp:44: constructor_uses_global_object: The constructor of global object "PreferNoCSEL" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PreferNoCSEL" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|   
#   43|   static cl::opt<bool>
#   44|-> PreferNoCSEL("prefer-no-csel", cl::Hidden,
#   45|                cl::desc("Prefer predicated Move to CSEL"),
#   46|                cl::init(false));

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/ARM/Thumb2InstrInfo.cpp:788: tainted_data_return: Called function "llvm::findFirstVPTPredOperandIdx(MI)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/ARM/Thumb2InstrInfo.cpp:788: assign: Assigning: "PIdx" = "llvm::findFirstVPTPredOperandIdx(MI)".
llvm-17.0.6.src/lib/Target/ARM/Thumb2InstrInfo.cpp:794: overflow: The expression "PIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/ARM/Thumb2InstrInfo.cpp:794: overflow_sink: "PIdx + 1", which might be negative, is passed to "MI->getOperand(PIdx + 1)".
#  792|     }
#  793|   
#  794|->   PredReg = MI.getOperand(PIdx+1).getReg();
#  795|     return (ARMVCC::VPTCodes)MI.getOperand(PIdx).getImm();
#  796|   }

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/Thumb2SizeReduction.cpp:54: constructor_uses_global_object: The constructor of global object "ReduceLimit" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReduceLimit" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   STATISTIC(NumLdSts,    "Number of 32-bit load / store reduced to 16-bit ones");
#   53|   
#   54|-> static cl::opt<int> ReduceLimit("t2-reduce-limit",
#   55|                                   cl::init(-1), cl::Hidden);
#   56|   static cl::opt<int> ReduceLimit2Addr("t2-reduce-limit2",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/Thumb2SizeReduction.cpp:56: constructor_uses_global_object: The constructor of global object "ReduceLimit2Addr" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReduceLimit2Addr" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   static cl::opt<int> ReduceLimit("t2-reduce-limit",
#   55|                                   cl::init(-1), cl::Hidden);
#   56|-> static cl::opt<int> ReduceLimit2Addr("t2-reduce-limit2",
#   57|                                        cl::init(-1), cl::Hidden);
#   58|   static cl::opt<int> ReduceLimitLdSt("t2-reduce-limit3",

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/ARM/Thumb2SizeReduction.cpp:58: constructor_uses_global_object: The constructor of global object "ReduceLimitLdSt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ReduceLimitLdSt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   56|   static cl::opt<int> ReduceLimit2Addr("t2-reduce-limit2",
#   57|                                        cl::init(-1), cl::Hidden);
#   58|-> static cl::opt<int> ReduceLimitLdSt("t2-reduce-limit3",
#   59|                                        cl::init(-1), cl::Hidden);
#   60|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/BPF/BPFAdjustOpt.cpp:33: constructor_uses_global_object: The constructor of global object "DisableBPFserializeICMP" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBPFserializeICMP" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   
#   32|   static cl::opt<bool>
#   33|->     DisableBPFserializeICMP("bpf-disable-serialize-icmp", cl::Hidden,
#   34|                               cl::desc("BPF: Disable Serializing ICMP insns."),
#   35|                               cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/BPF/BPFAdjustOpt.cpp:37: constructor_uses_global_object: The constructor of global object "DisableBPFavoidSpeculation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBPFavoidSpeculation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   35|                               cl::init(false));
#   36|   
#   37|-> static cl::opt<bool> DisableBPFavoidSpeculation(
#   38|       "bpf-disable-avoid-speculation", cl::Hidden,
#   39|       cl::desc("BPF: Disable Avoiding Speculative Code Motion."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/BPF/BPFISelLowering.cpp:34: constructor_uses_global_object: The constructor of global object "BPFExpandMemcpyInOrder" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BPFExpandMemcpyInOrder" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   #define DEBUG_TYPE "bpf-lower"
#   33|   
#   34|-> static cl::opt<bool> BPFExpandMemcpyInOrder("bpf-expand-memcpy-in-order",
#   35|     cl::Hidden, cl::init(false),
#   36|     cl::desc("Expand memcpy into load/store pairs in order"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/BPF/BPFRegisterInfo.cpp:31: constructor_uses_global_object: The constructor of global object "BPFStackSizeOption" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BPFStackSizeOption" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   
#   30|   static cl::opt<int>
#   31|->     BPFStackSizeOption("bpf-stack-size",
#   32|                          cl::desc("Specify the BPF stack size limit"),
#   33|                          cl::init(512));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/BPF/BPFTargetMachine.cpp:33: constructor_uses_global_object: The constructor of global object "DisableMIPeephole" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableMIPeephole" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   
#   32|   static cl::
#   33|-> opt<bool> DisableMIPeephole("disable-bpf-peephole", cl::Hidden,
#   34|                               cl::desc("Disable machine peepholes for BPF"));
#   35|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:3894: var_decl: Declaring variable "TrgReg" without initializer.
llvm-17.0.6.src/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4016: uninit_use: Using uninitialized value "TrgReg".
# 4014|     }
# 4015|   
# 4016|->   bool IsTrgRegZero = (TrgReg == Mips::ZERO);
# 4017|     bool IsSrcRegZero = (SrcReg == Mips::ZERO);
# 4018|     if (IsSrcRegZero && IsTrgRegZero) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4167: var_decl: Declaring variable "RtReg" without initializer.
llvm-17.0.6.src/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4242: uninit_use: Using uninitialized value "RtReg".
# 4240|     // GAS. GAS has an inconsistency/missed optimization in that not all cases
# 4241|     // are handled equivalently. As the observed behaviour is the same, we're ok.
# 4242|->   if (RtReg == Mips::ZERO || RtReg == Mips::ZERO_64) {
# 4243|       if (UseTraps) {
# 4244|         TOut.emitRRI(Mips::TEQ, ZeroReg, ZeroReg, 0x7, IDLoc, STI);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsABIInfo.cpp:22: constructor_uses_global_object: The constructor of global object "EmitJalrReloc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EmitJalrReloc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   20|   //       and libLLVMMipsCodeGen
#   21|   cl::opt<bool>
#   22|-> EmitJalrReloc("mips-jalr-reloc", cl::Hidden,
#   23|                 cl::desc("MIPS: Emit R_{MICRO}MIPS_JALR relocation with jalr"),
#   24|                 cl::init(true));

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:514: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:516: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:517: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#  515|       return MCAsmBackend::getFixupKindInfo(FK_NONE);
#  516|     if (Kind < FirstTargetFixupKind)
#  517|->     return MCAsmBackend::getFixupKindInfo(Kind);
#  518|   
#  519|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:514: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:516: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:523: illegal_address: "LittleEndianInfos[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 1680 bytes.
#  521|   
#  522|     if (Endian == support::little)
#  523|->     return LittleEndianInfos[Kind - FirstTargetFixupKind];
#  524|     return BigEndianInfos[Kind - FirstTargetFixupKind];
#  525|   }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:514: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:516: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsAsmBackend.cpp:524: illegal_address: "BigEndianInfos[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 1680 bytes.
#  522|     if (Endian == support::little)
#  523|       return LittleEndianInfos[Kind - FirstTargetFixupKind];
#  524|->   return BigEndianInfos[Kind - FirstTargetFixupKind];
#  525|   }
#  526|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:34: constructor_uses_global_object: The constructor of global object "<unnamed>::RoundSectionSizes" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "<unnamed>::RoundSectionSizes" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   
#   33|   namespace {
#   34|-> static cl::opt<bool> RoundSectionSizes(
#   35|       "mips-round-section-sizes", cl::init(false),
#   36|       cl::desc("Round section sizes up to the section alignment"), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/Mips16ISelLowering.cpp:26: constructor_uses_global_object: The constructor of global object "DontExpandCondPseudos16" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DontExpandCondPseudos16" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   #define DEBUG_TYPE "mips-lower"
#   25|   
#   26|-> static cl::opt<bool> DontExpandCondPseudos16(
#   27|     "mips16-dont-expand-cond-pseudo",
#   28|     cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsBranchExpansion.cpp:114: constructor_uses_global_object: The constructor of global object "SkipLongBranch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SkipLongBranch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  112|   
#  113|   static cl::opt<bool>
#  114|->     SkipLongBranch("skip-mips-long-branch", cl::init(false),
#  115|                      cl::desc("MIPS: Skip branch expansion pass."), cl::Hidden);
#  116|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsBranchExpansion.cpp:118: constructor_uses_global_object: The constructor of global object "ForceLongBranch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceLongBranch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  116|   
#  117|   static cl::opt<bool>
#  118|->     ForceLongBranch("force-mips-long-branch", cl::init(false),
#  119|                       cl::desc("MIPS: Expand all branches to long format."),
#  120|                       cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsConstantIslandPass.cpp:69: constructor_uses_global_object: The constructor of global object "AlignConstantIslands" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "AlignConstantIslands" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|   // FIXME: This option should be removed once it has received sufficient testing.
#   68|   static cl::opt<bool>
#   69|-> AlignConstantIslands("mips-align-constant-islands", cl::Hidden, cl::init(true),
#   70|             cl::desc("Align constant islands in code"));
#   71|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsConstantIslandPass.cpp:74: constructor_uses_global_object: The constructor of global object "ConstantIslandsSmallOffset" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ConstantIslandsSmallOffset" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   72|   // Rather than do make check tests with huge amounts of code, we force
#   73|   // the test to use this amount.
#   74|-> static cl::opt<int> ConstantIslandsSmallOffset(
#   75|     "mips-constant-islands-small-offset",
#   76|     cl::init(0),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsConstantIslandPass.cpp:82: constructor_uses_global_object: The constructor of global object "NoLoadRelaxation" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoLoadRelaxation" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   // For testing purposes we tell it to not use relaxed load forms so that it
#   81|   // will split blocks.
#   82|-> static cl::opt<bool> NoLoadRelaxation(
#   83|     "mips-constant-islands-no-load-relaxation",
#   84|     cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsDelaySlotFiller.cpp:59: constructor_uses_global_object: The constructor of global object "DisableDelaySlotFiller" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableDelaySlotFiller" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|                          " are not NOP.");
#   58|   
#   59|-> static cl::opt<bool> DisableDelaySlotFiller(
#   60|     "disable-mips-delay-filler",
#   61|     cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsDelaySlotFiller.cpp:65: constructor_uses_global_object: The constructor of global object "DisableForwardSearch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableForwardSearch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   63|     cl::Hidden);
#   64|   
#   65|-> static cl::opt<bool> DisableForwardSearch(
#   66|     "disable-mips-df-forward-search",
#   67|     cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsDelaySlotFiller.cpp:71: constructor_uses_global_object: The constructor of global object "DisableSuccBBSearch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSuccBBSearch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|     cl::Hidden);
#   70|   
#   71|-> static cl::opt<bool> DisableSuccBBSearch(
#   72|     "disable-mips-df-succbb-search",
#   73|     cl::init(true),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsDelaySlotFiller.cpp:77: constructor_uses_global_object: The constructor of global object "DisableBackwardSearch" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableBackwardSearch" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   75|     cl::Hidden);
#   76|   
#   77|-> static cl::opt<bool> DisableBackwardSearch(
#   78|     "disable-mips-df-backward-search",
#   79|     cl::init(false),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsDelaySlotFiller.cpp:93: constructor_uses_global_object: The constructor of global object "MipsCompactBranchPolicy" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MipsCompactBranchPolicy" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   91|   };
#   92|   
#   93|-> static cl::opt<CompactBranchPolicy> MipsCompactBranchPolicy(
#   94|       "mips-compact-branches", cl::Optional, cl::init(CB_Optimal),
#   95|       cl::desc("MIPS Specific: Compact branch policy."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsISelLowering.cpp:86: constructor_uses_global_object: The constructor of global object "NoZeroDivCheck" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoZeroDivCheck" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   84|   
#   85|   static cl::opt<bool>
#   86|-> NoZeroDivCheck("mno-check-zero-division", cl::Hidden,
#   87|                  cl::desc("MIPS: Don't trap on integer division by zero."),
#   88|                  cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsMachineFunction.cpp:22: constructor_uses_global_object: The constructor of global object "FixGlobalBaseReg" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FixGlobalBaseReg" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   20|   
#   21|   static cl::opt<bool>
#   22|-> FixGlobalBaseReg("mips-fix-global-base-reg", cl::Hidden, cl::init(true),
#   23|                    cl::desc("Always use $gp as the global base register."));
#   24|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsOptimizePICCall.cpp:46: constructor_uses_global_object: The constructor of global object "LoadTargetFromGOT" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LoadTargetFromGOT" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   44|   #define DEBUG_TYPE "optimize-mips-pic-call"
#   45|   
#   46|-> static cl::opt<bool> LoadTargetFromGOT("mips-load-target-from-got",
#   47|                                          cl::init(true),
#   48|                                          cl::desc("Load target address from GOT"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsOptimizePICCall.cpp:51: constructor_uses_global_object: The constructor of global object "EraseGPOpnd" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EraseGPOpnd" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   49|                                          cl::Hidden);
#   50|   
#   51|-> static cl::opt<bool> EraseGPOpnd("mips-erase-gp-opnd",
#   52|                                    cl::init(true), cl::desc("Erase GP Operand"),
#   53|                                    cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsOs16.cpp:25: constructor_uses_global_object: The constructor of global object "Mips32FunctionMask[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mips32FunctionMask[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   23|   #define DEBUG_TYPE "mips-os16"
#   24|   
#   25|-> static cl::opt<std::string> Mips32FunctionMask(
#   26|     "mips32-function-mask",
#   27|     cl::init(""),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSEISelLowering.cpp:56: constructor_uses_global_object: The constructor of global object "UseMipsTailCalls" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseMipsTailCalls" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   54|   
#   55|   static cl::opt<bool>
#   56|-> UseMipsTailCalls("mips-tail-calls", cl::Hidden,
#   57|                       cl::desc("MIPS: permit tail calls."), cl::init(false));
#   58|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSEISelLowering.cpp:59: constructor_uses_global_object: The constructor of global object "NoDPLoadStore" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoDPLoadStore" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|                       cl::desc("MIPS: permit tail calls."), cl::init(false));
#   58|   
#   59|-> static cl::opt<bool> NoDPLoadStore("mno-ldc1-sdc1", cl::init(false),
#   60|                                      cl::desc("Expand double precision loads and "
#   61|                                               "stores to their single precision "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSubtarget.cpp:39: constructor_uses_global_object: The constructor of global object "Mixed16_32" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mixed16_32" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   //
#   38|   static cl::opt<bool>
#   39|->     Mixed16_32("mips-mixed-16-32", cl::init(false),
#   40|                  cl::desc("Allow for a mixture of Mips16 "
#   41|                           "and Mips32 code in a single output file"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSubtarget.cpp:44: constructor_uses_global_object: The constructor of global object "Mips_Os16" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mips_Os16" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   42|                  cl::Hidden);
#   43|   
#   44|-> static cl::opt<bool> Mips_Os16("mips-os16", cl::init(false),
#   45|                                  cl::desc("Compile all functions that don't use "
#   46|                                           "floating point as Mips 16"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSubtarget.cpp:49: constructor_uses_global_object: The constructor of global object "Mips16HardFloat" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mips16HardFloat" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   47|                                  cl::Hidden);
#   48|   
#   49|-> static cl::opt<bool> Mips16HardFloat("mips16-hard-float", cl::NotHidden,
#   50|                                        cl::desc("Enable mips16 hard float."),
#   51|                                        cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSubtarget.cpp:54: constructor_uses_global_object: The constructor of global object "Mips16ConstantIslands" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "Mips16ConstantIslands" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   52|   
#   53|   static cl::opt<bool>
#   54|->     Mips16ConstantIslands("mips16-constant-islands", cl::NotHidden,
#   55|                             cl::desc("Enable mips16 constant islands."),
#   56|                             cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsSubtarget.cpp:59: constructor_uses_global_object: The constructor of global object "GPOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GPOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   57|   
#   58|   static cl::opt<bool>
#   59|->     GPOpt("mgpopt", cl::Hidden,
#   60|             cl::desc("Enable gp-relative addressing of mips small data items"));
#   61|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsTargetMachine.cpp:52: constructor_uses_global_object: The constructor of global object "EnableMulMulFix" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableMulMulFix" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   50|   
#   51|   static cl::opt<bool>
#   52|->     EnableMulMulFix("mfix4300", cl::init(false),
#   53|                       cl::desc("Enable the VR4300 mulmul bug fix."), cl::Hidden);
#   54|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsTargetObjectFile.cpp:24: constructor_uses_global_object: The constructor of global object "SSThreshold" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "SSThreshold" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   22|   
#   23|   static cl::opt<unsigned>
#   24|-> SSThreshold("mips-ssection-threshold", cl::Hidden,
#   25|               cl::desc("Small data and bss section threshold size (default=8)"),
#   26|               cl::init(8));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsTargetObjectFile.cpp:29: constructor_uses_global_object: The constructor of global object "LocalSData" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LocalSData" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   27|   
#   28|   static cl::opt<bool>
#   29|-> LocalSData("mlocal-sdata", cl::Hidden,
#   30|              cl::desc("MIPS: Use gp_rel for object-local data."),
#   31|              cl::init(true));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsTargetObjectFile.cpp:34: constructor_uses_global_object: The constructor of global object "ExternSData" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExternSData" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   32|   
#   33|   static cl::opt<bool>
#   34|-> ExternSData("mextern-sdata", cl::Hidden,
#   35|               cl::desc("MIPS: Use gp_rel for data that is not defined by the "
#   36|                        "current object."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/Mips/MipsTargetObjectFile.cpp:40: constructor_uses_global_object: The constructor of global object "EmbeddedData" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EmbeddedData" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   
#   39|   static cl::opt<bool>
#   40|-> EmbeddedData("membedded-data", cl::Hidden,
#   41|                cl::desc("MIPS: Try to allocate variables in the following"
#   42|                         " sections if possible: .rodata, .sdata, .data ."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:96: constructor_uses_global_object: The constructor of global object "LowerCtorDtor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "LowerCtorDtor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   94|   
#   95|   static cl::opt<bool>
#   96|->     LowerCtorDtor("nvptx-lower-global-ctor-dtor",
#   97|                     cl::desc("Lower GPU ctor / dtors to globals on the device."),
#   98|                     cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:31: constructor_uses_global_object: The constructor of global object "GlobalStr[abi:cxx11]" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GlobalStr[abi:cxx11]" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   29|   
#   30|   static cl::opt<std::string>
#   31|->     GlobalStr("nvptx-lower-global-ctor-dtor-id",
#   32|                 cl::desc("Override unique ID of ctor/dtor globals."),
#   33|                 cl::init(""), cl::Hidden);

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:871: assignment: Assigning: "Ordering" = "LD->getSuccessOrdering()". The value of "Ordering" may now be up to 15.
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:876: overrun-call: Overrunning callee's array of size 8 by passing argument "Ordering" (which evaluates to 15) in call to "isStrongerThanMonotonic".
#  874|     // with PTX ISA 6.0 / sm_70.
#  875|     // TODO: Check if we can actually use the new instructions and implement them.
#  876|->   if (isStrongerThanMonotonic(Ordering))
#  877|       return false;
#  878|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:1649: assignment: Assigning: "Ordering" = "ST->getSuccessOrdering()". The value of "Ordering" may now be up to 15.
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:1654: overrun-call: Overrunning callee's array of size 8 by passing argument "Ordering" (which evaluates to 15) in call to "isStrongerThanMonotonic".
# 1652|     // with PTX ISA 6.0 / sm_70.
# 1653|     // TODO: Check if we can actually use the new instructions and implement them.
# 1654|->   if (isStrongerThanMonotonic(Ordering))
# 1655|       return false;
# 1656|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:71: constructor_uses_global_object: The constructor of global object "sched4reg" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "sched4reg" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   69|   static std::atomic<unsigned> GlobalUniqueCallSite;
#   70|   
#   71|-> static cl::opt<bool> sched4reg(
#   72|       "nvptx-sched4reg",
#   73|       cl::desc("NVPTX Specific: schedule for register pressue"), cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:75: constructor_uses_global_object: The constructor of global object "FMAContractLevelOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FMAContractLevelOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   73|       cl::desc("NVPTX Specific: schedule for register pressue"), cl::init(false));
#   74|   
#   75|-> static cl::opt<unsigned> FMAContractLevelOpt(
#   76|       "nvptx-fma-level", cl::Hidden,
#   77|       cl::desc("NVPTX Specific: FMA contraction (0: don't do it"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:81: constructor_uses_global_object: The constructor of global object "UsePrecDivF32" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UsePrecDivF32" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   79|       cl::init(2));
#   80|   
#   81|-> static cl::opt<int> UsePrecDivF32(
#   82|       "nvptx-prec-divf32", cl::Hidden,
#   83|       cl::desc("NVPTX Specifies: 0 use div.approx, 1 use div.full, 2 use"

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:87: constructor_uses_global_object: The constructor of global object "UsePrecSqrtF32" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UsePrecSqrtF32" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   85|       cl::init(2));
#   86|   
#   87|-> static cl::opt<bool> UsePrecSqrtF32(
#   88|       "nvptx-prec-sqrtf32", cl::Hidden,
#   89|       cl::desc("NVPTX Specific: 0 use sqrt.approx, 1 use sqrt.rn."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:92: constructor_uses_global_object: The constructor of global object "ForceMinByValParamAlign" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ForceMinByValParamAlign" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   90|       cl::init(true));
#   91|   
#   92|-> static cl::opt<bool> ForceMinByValParamAlign(
#   93|       "nvptx-force-min-byval-param-align", cl::Hidden,
#   94|       cl::desc("NVPTX Specific: force 4-byte minimal alignment for byval"

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:339: var_decl: Declaring variable "VectorInfo".
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:343: uninit_use: Using uninitialized value "VectorInfo". Field "VectorInfo.InlineElts" is uninitialized.
#  341|   
#  342|     if (IsVAArg)
#  343|->     return VectorInfo;
#  344|   
#  345|     // Check what we can vectorize using 128/64/32-bit accesses.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:339: var_decl: Declaring variable "VectorInfo".
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXISelLowering.cpp:379: uninit_use: Using uninitialized value "VectorInfo". Field "VectorInfo.InlineElts" is uninitialized.
#  377|       }
#  378|     }
#  379|->   return VectorInfo;
#  380|   }
#  381|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXSubtarget.cpp:26: constructor_uses_global_object: The constructor of global object "NoF16Math" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NoF16Math" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   24|   
#   25|   static cl::opt<bool>
#   26|->     NoF16Math("nvptx-no-f16-math", cl::Hidden,
#   27|                 cl::desc("NVPTX Specific: Disable generation of f16 math ops."),
#   28|                 cl::init(false));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXTargetMachine.cpp:48: constructor_uses_global_object: The constructor of global object "DisableLoadStoreVectorizer" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableLoadStoreVectorizer" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   46|   // encounter (or suspect) a bug.
#   47|   static cl::opt<bool>
#   48|->     DisableLoadStoreVectorizer("disable-nvptx-load-store-vectorizer",
#   49|                                  cl::desc("Disable load/store vectorizer"),
#   50|                                  cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXTargetMachine.cpp:53: constructor_uses_global_object: The constructor of global object "DisableRequireStructuredCFG" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableRequireStructuredCFG" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   51|   
#   52|   // TODO: Remove this flag when we are confident with no regressions.
#   53|-> static cl::opt<bool> DisableRequireStructuredCFG(
#   54|       "disable-nvptx-require-structured-cfg",
#   55|       cl::desc("Transitional flag to turn off NVPTX's requirement on preserving "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXTargetMachine.cpp:60: constructor_uses_global_object: The constructor of global object "UseShortPointersOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseShortPointersOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   58|       cl::init(false), cl::Hidden);
#   59|   
#   60|-> static cl::opt<bool> UseShortPointersOpt(
#   61|       "nvptx-short-ptr",
#   62|       cl::desc(

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVPTXTargetMachine.cpp:69: constructor_uses_global_object: The constructor of global object "ExitOnUnreachable" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ExitOnUnreachable" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   67|   // makes it into the LLVM-17 release.
#   68|   static cl::opt<bool>
#   69|->     ExitOnUnreachable("nvptx-exit-on-unreachable",
#   70|                         cl::desc("Lower 'unreachable' as 'exit' instruction."),
#   71|                         cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVVMIntrRange.cpp:30: constructor_uses_global_object: The constructor of global object "NVVMIntrRangeSM" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NVVMIntrRangeSM" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   28|   
#   29|   // Add !range metadata based on limits of given SM variant.
#   30|-> static cl::opt<unsigned> NVVMIntrRangeSM("nvvm-intr-range-sm", cl::init(20),
#   31|                                            cl::Hidden, cl::desc("SM variant"));
#   32|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/NVPTX/NVVMReflect.cpp:70: constructor_uses_global_object: The constructor of global object "NVVMReflectEnabled" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "NVVMReflectEnabled" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|   
#   69|   static cl::opt<bool>
#   70|-> NVVMReflectEnabled("nvvm-reflect-enable", cl::init(true), cl::Hidden,
#   71|                      cl::desc("NVVM reflection, enabled by default"));
#   72|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:607: overrun-local: Overrunning array "CRRegs" of 8 2-byte elements at element index 4294967239 (byte offset 8589934479) using index "this->getCRBitMask()" (which evaluates to 4294967239).
#  605|     void addCRBitMaskOperands(MCInst &Inst, unsigned N) const {
#  606|       assert(N == 1 && "Invalid number of operands!");
#  607|->     Inst.addOperand(MCOperand::createReg(CRRegs[getCRBitMask()]));
#  608|     }
#  609|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:127: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:130: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:131: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#  129|   
#  130|       if (Kind < FirstTargetFixupKind)
#  131|->       return MCAsmBackend::getFixupKindInfo(Kind);
#  132|   
#  133|       assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:127: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:130: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCAsmBackend.cpp:135: illegal_address: "((this->Endian == little) ? InfosLE : InfosBE)[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 264 bytes.
#  133|       assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&
#  134|              "Invalid kind!");
#  135|->     return (Endian == support::little
#  136|                   ? InfosLE
#  137|                   : InfosBE)[Kind - FirstTargetFixupKind];

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:33: constructor_uses_global_object: The constructor of global object "FullRegNames" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FullRegNames" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   31|   // to the verbose-asm setting.
#   32|   static cl::opt<bool>
#   33|-> FullRegNames("ppc-asm-full-reg-names", cl::Hidden, cl::init(false),
#   34|                cl::desc("Use full register names when printing assembly"));
#   35|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:38: constructor_uses_global_object: The constructor of global object "ShowVSRNumsAsVR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ShowVSRNumsAsVR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   36|   // Useful for testing purposes. Prints vs{31-63} as v{0-31} respectively.
#   37|   static cl::opt<bool>
#   38|-> ShowVSRNumsAsVR("ppc-vsr-nums-as-vr", cl::Hidden, cl::init(false),
#   39|                cl::desc("Prints full register names with vs{31-63} as v{0-31}"));
#   40|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/MCTargetDesc/PPCInstPrinter.cpp:43: constructor_uses_global_object: The constructor of global object "FullRegNamesWithPercent" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FullRegNamesWithPercent" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   41|   // Prints full register names with percent symbol.
#   42|   static cl::opt<bool>
#   43|-> FullRegNamesWithPercent("ppc-reg-with-percent-prefix", cl::Hidden,
#   44|                           cl::init(false),
#   45|                           cl::desc("Prints full register names with percent"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCAsmPrinter.cpp:96: constructor_uses_global_object: The constructor of global object "EnableSSPCanaryBitInTB" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableSSPCanaryBitInTB" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   94|   STATISTIC(NumTOCEHBlock, "Number of EH Block TOC Entries.");
#   95|   
#   96|-> static cl::opt<bool> EnableSSPCanaryBitInTB(
#   97|       "aix-ssp-tb-bit", cl::init(false),
#   98|       cl::desc("Enable Passing SSP Canary info in Trackback on AIX"), cl::Hidden);

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/PowerPC/PPCCallingConv.cpp:159: cond_const: Checking "i < 4UL" implies that "i" is 4 on the false branch.
llvm-17.0.6.src/lib/Target/PowerPC/PPCCallingConv.cpp:163: overrun-local: Overrunning array "LoRegList" of 4 2-byte elements at element index 4 (byte offset 9) using index "i" (which evaluates to 4).
#  161|         break;
#  162|   
#  163|->   unsigned T = State.AllocateReg(LoRegList[i]);
#  164|     (void)T;
#  165|     assert(T == LoRegList[i] && "Could not allocate register");

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/PowerPC/PPCCallingConv.cpp:159: cond_const: Checking "i < 4UL" implies that "i" is 4 on the false branch.
llvm-17.0.6.src/lib/Target/PowerPC/PPCCallingConv.cpp:168: overrun-local: Overrunning array "LoRegList" of 4 2-byte elements at element index 4 (byte offset 9) using index "i" (which evaluates to 4).
#  166|   
#  167|     State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
#  168|->   State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, LoRegList[i],
#  169|                                            LocVT, LocInfo));
#  170|     return true;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/PowerPC/PPCCallingConv.cpp:188: cond_const: Checking "i < 1UL" implies that "i" is 1 on the false branch.
llvm-17.0.6.src/lib/Target/PowerPC/PPCCallingConv.cpp:193: overrun-local: Overrunning array "LoRegList" of 1 2-byte elements at element index 1 (byte offset 3) using index "i" (which evaluates to 1).
#  191|   
#  192|     State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
#  193|->   State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, LoRegList[i],
#  194|                                            LocVT, LocInfo));
#  195|     return true;

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCExpandISEL.cpp:40: constructor_uses_global_object: The constructor of global object "GenerateISEL" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "GenerateISEL" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   38|   // ISEL instruction, else expand it.
#   39|   static cl::opt<bool>
#   40|->     GenerateISEL("ppc-gen-isel",
#   41|                    cl::desc("Enable generating the ISEL instruction."),
#   42|                    cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCFrameLowering.cpp:39: constructor_uses_global_object: The constructor of global object "EnablePEVectorSpills" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnablePEVectorSpills" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   37|   
#   38|   static cl::opt<bool>
#   39|-> EnablePEVectorSpills("ppc-enable-pe-vector-spills",
#   40|                        cl::desc("Enable spills in prologue to vector registers."),
#   41|                        cl::init(false), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:91: constructor_uses_global_object: The constructor of global object "ANDIGlueBug" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "ANDIGlueBug" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   89|   
#   90|   // FIXME: Remove this once the bug has been fixed!
#   91|-> cl::opt<bool> ANDIGlueBug("expose-ppc-andi-glue-bug",
#   92|   cl::desc("expose the ANDI glue bug on PPC"), cl::Hidden);
#   93|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:95: constructor_uses_global_object: The constructor of global object "UseBitPermRewriter" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseBitPermRewriter" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   93|   
#   94|   static cl::opt<bool>
#   95|->     UseBitPermRewriter("ppc-use-bit-perm-rewriter", cl::init(true),
#   96|                          cl::desc("use aggressive ppc isel for bit permutations"),
#   97|                          cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:98: constructor_uses_global_object: The constructor of global object "BPermRewriterNoMasking" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "BPermRewriterNoMasking" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   96|                          cl::desc("use aggressive ppc isel for bit permutations"),
#   97|                          cl::Hidden);
#   98|-> static cl::opt<bool> BPermRewriterNoMasking(
#   99|       "ppc-bit-perm-rewriter-stress-rotates",
#  100|       cl::desc("stress rotate selection in aggressive ppc isel for "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:104: constructor_uses_global_object: The constructor of global object "EnableBranchHint" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableBranchHint" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  102|       cl::Hidden);
#  103|   
#  104|-> static cl::opt<bool> EnableBranchHint(
#  105|     "ppc-use-branch-hint", cl::init(true),
#  106|       cl::desc("Enable static hinting of branches on ppc"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:109: constructor_uses_global_object: The constructor of global object "EnableTLSOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableTLSOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  107|       cl::Hidden);
#  108|   
#  109|-> static cl::opt<bool> EnableTLSOpt(
#  110|     "ppc-tls-opt", cl::init(true),
#  111|       cl::desc("Enable tls optimization peephole"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:118: constructor_uses_global_object: The constructor of global object "CmpInGPR" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "CmpInGPR" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  116|     ICGPR_SextI32, ICGPR_ZextI64, ICGPR_SextI64 };
#  117|   
#  118|-> static cl::opt<ICmpInGPRType> CmpInGPR(
#  119|     "ppc-gpr-icmps", cl::Hidden, cl::init(ICGPR_All),
#  120|     cl::desc("Specify the types of comparisons to emit GPR-only code for."),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:107: constructor_uses_global_object: The constructor of global object "DisablePPCPreinc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePPCPreinc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  105|   #define DEBUG_TYPE "ppc-lowering"
#  106|   
#  107|-> static cl::opt<bool> DisablePPCPreinc("disable-ppc-preinc",
#  108|   cl::desc("disable preincrement load/store generation on PPC"), cl::Hidden);
#  109|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:110: constructor_uses_global_object: The constructor of global object "DisableILPPref" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableILPPref" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  108|   cl::desc("disable preincrement load/store generation on PPC"), cl::Hidden);
#  109|   
#  110|-> static cl::opt<bool> DisableILPPref("disable-ppc-ilp-pref",
#  111|   cl::desc("disable setting the node scheduling preference to ILP on PPC"), cl::Hidden);
#  112|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:113: constructor_uses_global_object: The constructor of global object "DisablePPCUnaligned" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePPCUnaligned" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  111|   cl::desc("disable setting the node scheduling preference to ILP on PPC"), cl::Hidden);
#  112|   
#  113|-> static cl::opt<bool> DisablePPCUnaligned("disable-ppc-unaligned",
#  114|   cl::desc("disable unaligned load/store generation on PPC"), cl::Hidden);
#  115|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:116: constructor_uses_global_object: The constructor of global object "DisableSCO" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableSCO" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  114|   cl::desc("disable unaligned load/store generation on PPC"), cl::Hidden);
#  115|   
#  116|-> static cl::opt<bool> DisableSCO("disable-ppc-sco",
#  117|   cl::desc("disable sibling call optimization on ppc"), cl::Hidden);
#  118|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:119: constructor_uses_global_object: The constructor of global object "DisableInnermostLoopAlign32" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableInnermostLoopAlign32" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  117|   cl::desc("disable sibling call optimization on ppc"), cl::Hidden);
#  118|   
#  119|-> static cl::opt<bool> DisableInnermostLoopAlign32("disable-ppc-innermost-loop-align32",
#  120|   cl::desc("don't always align innermost loop to 32 bytes on ppc"), cl::Hidden);
#  121|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:122: constructor_uses_global_object: The constructor of global object "UseAbsoluteJumpTables" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseAbsoluteJumpTables" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  120|   cl::desc("don't always align innermost loop to 32 bytes on ppc"), cl::Hidden);
#  121|   
#  122|-> static cl::opt<bool> UseAbsoluteJumpTables("ppc-use-absolute-jumptables",
#  123|   cl::desc("use absolute jump tables on ppc"), cl::Hidden);
#  124|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:126: constructor_uses_global_object: The constructor of global object "DisablePerfectShuffle" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisablePerfectShuffle" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  124|   
#  125|   static cl::opt<bool>
#  126|->     DisablePerfectShuffle("ppc-disable-perfect-shuffle",
#  127|                             cl::desc("disable vector permute decomposition"),
#  128|                             cl::init(true), cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCISelLowering.cpp:130: constructor_uses_global_object: The constructor of global object "DisableAutoPairedVecSt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableAutoPairedVecSt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  128|                             cl::init(true), cl::Hidden);
#  129|   
#  130|-> cl::opt<bool> DisableAutoPairedVecSt(
#  131|       "disable-auto-paired-vec-st",
#  132|       cl::desc("disable automatically generated 32byte paired vector stores"),

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:67: constructor_uses_global_object: The constructor of global object "DisableCTRLoopAnal" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCTRLoopAnal" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   65|   
#   66|   static cl::
#   67|-> opt<bool> DisableCTRLoopAnal("disable-ppc-ctrloop-analysis", cl::Hidden,
#   68|               cl::desc("Disable analysis for CTR loops"));
#   69|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:70: constructor_uses_global_object: The constructor of global object "DisableCmpOpt" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "DisableCmpOpt" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   68|               cl::desc("Disable analysis for CTR loops"));
#   69|   
#   70|-> static cl::opt<bool> DisableCmpOpt("disable-ppc-cmp-opt",
#   71|   cl::desc("Disable compare instruction optimization"), cl::Hidden);
#   72|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:73: constructor_uses_global_object: The constructor of global object "VSXSelfCopyCrash" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "VSXSelfCopyCrash" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   71|   cl::desc("Disable compare instruction optimization"), cl::Hidden);
#   72|   
#   73|-> static cl::opt<bool> VSXSelfCopyCrash("crash-on-ppc-vsx-self-copy",
#   74|   cl::desc("Causes the backend to crash instead of generating a nop VSX copy"),
#   75|   cl::Hidden);

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:78: constructor_uses_global_object: The constructor of global object "UseOldLatencyCalc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "UseOldLatencyCalc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   76|   
#   77|   static cl::opt<bool>
#   78|-> UseOldLatencyCalc("ppc-old-latency-calc", cl::Hidden,
#   79|     cl::desc("Use the old (incorrect) instruction latency calculation"));
#   80|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:82: constructor_uses_global_object: The constructor of global object "FMARPFactor" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "FMARPFactor" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   80|   
#   81|   static cl::opt<float>
#   82|->     FMARPFactor("ppc-fma-rp-factor", cl::Hidden, cl::init(1.5),
#   83|                   cl::desc("register pressure factor for the transformations."));
#   84|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:85: constructor_uses_global_object: The constructor of global object "EnableFMARegPressureReduction" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableFMARegPressureReduction" might be created before "llvm::cl::TopLevelSubCommand" is available.
#   83|                   cl::desc("register pressure factor for the transformations."));
#   84|   
#   85|-> static cl::opt<bool> EnableFMARegPressureReduction(
#   86|       "ppc-fma-rp-reduction", cl::Hidden, cl::init(true),
#   87|       cl::desc("enable register pressure reduce in machine combiner pass."));

Error: NEGATIVE_RETURNS (CWE-394):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:388: negative_return_fn: Function "this->this->getFMAOpIdxInfo(this->Root->getOpcode())" returns a negative number.
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:388: negative_returns: Using variable "this->this->getFMAOpIdxInfo(this->Root->getOpcode())" as an index to array "FMAOpIdxInfo".
#  386|     auto IsReassociableAddOrSub = [&](const MachineInstr &Instr,
#  387|                                       unsigned OpType) {
#  388|->     if (Instr.getOpcode() !=
#  389|           FMAOpIdxInfo[getFMAOpIdxInfo(Root.getOpcode())][OpType])
#  390|         return false;

Error: NEGATIVE_RETURNS (CWE-394):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:810: negative_return_fn: Function "this->getFMAOpIdxInfo(FmaOp)" returns a negative number.
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:810: assign: Assigning: "Idx" = "this->getFMAOpIdxInfo(FmaOp)".
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:817: negative_returns: Using variable "Idx" as an index to array "FMAOpIdxInfo".
#  815|         (Pattern == MachineCombinerPattern::REASSOC_XMM_AMM_BMM);
#  816|   
#  817|->   uint16_t AddOpIdx = FMAOpIdxInfo[Idx][InfoArrayIdxAddOpIdx];
#  818|     uint16_t FirstMulOpIdx = FMAOpIdxInfo[Idx][InfoArrayIdxMULOpIdx];
#  819|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:1260: var_decl: Declaring variable "Nop".
llvm-17.0.6.src/lib/Target/PowerPC/PPCInstrInfo.cpp:1262: uninit_use: Using uninitialized value "Nop". Field "Nop.Operands.InlineElts" is uninitialized.
# 1260|     MCInst Nop;
# 1261|     Nop.setOpcode(PPC::NOP);
# 1262|->   return Nop;
# 1263|   }
# 1264|   

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:120: constructor_uses_global_object: The constructor of global object "MaxVarsPrep" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "MaxVarsPrep" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  118|   
#  119|   static cl::opt<unsigned>
#  120|->     MaxVarsPrep("ppc-formprep-max-vars", cl::Hidden, cl::init(24),
#  121|                   cl::desc("Potential common base number threshold per function "
#  122|                            "for PPC loop prep"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:124: constructor_uses_global_object: The constructor of global object "PreferUpdateForm" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "PreferUpdateForm" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  122|                            "for PPC loop prep"));
#  123|   
#  124|-> static cl::opt<bool> PreferUpdateForm("ppc-formprep-prefer-update",
#  125|                                    cl::init(true), cl::Hidden,
#  126|     cl::desc("prefer update form when ds form is also a update form"));

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:128: constructor_uses_global_object: The constructor of global object "EnableUpdateFormForNonConstInc" itself makes use of global object "llvm::cl::TopLevelSubCommand" defined in another compilation unit.  The order of construction is unspecified, so "EnableUpdateFormForNonConstInc" might be created before "llvm::cl::TopLevelSubCommand" is available.
#  126|     cl::desc("prefer update form when ds form is also a update form"));
#  127|   
#  128|-> static cl::opt<bool> EnableUpdateFormForNonConstInc(
#  129|       "ppc-formprep-update-nonconst-inc", cl::init(false), cl::Hidden,
#  130|       cl::desc("prepare update form when the load/store increment is a loop "

Error: GLOBAL_INIT_ORDER (CWE-908):
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:133: error[too-many]: 3010 occurrences of constructor_uses_global_object exceeded the specified limit 1024
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:133: note: 1986 occurrences of constructor_uses_global_object were discarded because of this

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:865: var_decl: Declaring variable "Buckets".
llvm-17.0.6.src/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:893: uninit_use: Using uninitialized value "Buckets". Field "Buckets.InlineElts" is uninitialized.
#  891|           addOneCandidate(&J, LSCEV, Buckets, isValidDiff, MaxCandidateNum);
#  892|       }
#  893|->   return Buckets;
#  894|   }
#  895|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:161: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:164: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:165: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#  163|   
#  164|     if (Kind < FirstTargetFixupKind)
#  165|->     return MCAsmBackend::getFixupKindInfo(Kind);
#  166|   
#  167|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:161: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:164: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/SystemZ/MCTargetDesc/SystemZMCAsmBackend.cpp:169: illegal_address: "llvm::SystemZ::MCFixupKindInfos[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 432 bytes.
#  167|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&
#  168|            "Invalid kind!");
#  169|->   return SystemZ::MCFixupKindInfos[Kind - FirstTargetFixupKind];
#  170|   }
#  171|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/SystemZ/SystemZElimCompare.cpp:650: return_constant: Function call "MBBI->findRegisterUseOperandIdx(llvm::Register(CC), false, this->TRI)" may return -1.
llvm-17.0.6.src/lib/Target/SystemZ/SystemZElimCompare.cpp:650: assignment: Assigning: "CCUse" = "MBBI->findRegisterUseOperandIdx(llvm::Register(CC), false, this->TRI)". The value of "CCUse" is now -1.
llvm-17.0.6.src/lib/Target/SystemZ/SystemZElimCompare.cpp:652: overrun-buffer-arg: Calling "removeOperand" with "Branch->Operands" and "CCUse" is suspicious because of the very large index, 4294967295. The index may be due to a negative parameter being interpreted as unsigned.
#  650|     int CCUse = MBBI->findRegisterUseOperandIdx(SystemZ::CC, false, TRI);
#  651|     assert(CCUse >= 0 && "BRC/BCR must use CC");
#  652|->   Branch->removeOperand(CCUse);
#  653|     // Remove regmask (sibcall).
#  654|     if (Type == SystemZII::CompareAndSibcall)

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyAsmBackend.cpp:79: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyAsmBackend.cpp:80: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#   78|   
#   79|     if (Kind < FirstTargetFixupKind)
#   80|->     return MCAsmBackend::getFixupKindInfo(Kind);
#   81|   
#   82|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:311: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), llvm::APInt(32U, Op->getSFPImm(), false))".
llvm-17.0.6.src/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:311: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  309|       O << Op.getImm();
#  310|     } else if (Op.isSFPImm()) {
#  311|->     O << ::toString(APFloat(APFloat::IEEEsingle(), APInt(32, Op.getSFPImm())));
#  312|     } else if (Op.isDFPImm()) {
#  313|       O << ::toString(APFloat(APFloat::IEEEdouble(), APInt(64, Op.getDFPImm())));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:313: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), llvm::APInt(64U, Op->getDFPImm(), false))".
llvm-17.0.6.src/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:313: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  311|       O << ::toString(APFloat(APFloat::IEEEsingle(), APInt(32, Op.getSFPImm())));
#  312|     } else if (Op.isDFPImm()) {
#  313|->     O << ::toString(APFloat(APFloat::IEEEdouble(), APInt(64, Op.getDFPImm())));
#  314|     } else {
#  315|       assert(Op.isExpr() && "unknown operand kind in printOperand");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:126: var_decl: Declaring variable "SinkableDbgValues".
llvm-17.0.6.src/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:211: uninit_use: Using uninitialized value "SinkableDbgValues". Field "SinkableDbgValues.InlineElts" is uninitialized.
#  209|         SinkableDbgValues.push_back(DV);
#  210|     }
#  211|->   return SinkableDbgValues;
#  212|   }
#  213|   
llvm-17.0.6.src/lib/Target/WebAssembly/WebAssemblyDebugValueManager.cpp:211: note: trimmed 1 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:1919: var_decl: Declaring variable "Ext" without initializer.
llvm-17.0.6.src/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:1931: uninit_use_in_call: Using uninitialized value "Ext" when calling "getNode".
# 1929|     SDValue Ret = Src;
# 1930|     while (Scale != 1) {
# 1931|->     Ret = DAG.getNode(Ext, DL,
# 1932|                         Ret.getValueType()
# 1933|                             .widenIntegerVectorElementType(*DAG.getContext())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/AsmParser/X86AsmParser.cpp:2111: var_decl: Declaring variable "Info".
llvm-17.0.6.src/lib/Target/X86/AsmParser/X86AsmParser.cpp:2113: uninit_use_in_call: Using uninitialized value "Info". Field "Info" is uninitialized when calling "onIdentifierExpr".
# 2111|             InlineAsmIdentifierInfo Info;
# 2112|             AsmTypeInfo Type;
# 2113|->           if (SM.onIdentifierExpr(Val, Identifier, Info, Type,
# 2114|                                     isParsingMSInlineAsm(), ErrMsg))
# 2115|               return Error(Loc, ErrMsg);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Target/X86/ImmutableGraph.h:375: address_of: Taking address with "*__begin0" yields a singleton pointer.
llvm-17.0.6.src/lib/Target/X86/ImmutableGraph.h:375: assign: Assigning: "N" = "*__begin0".
llvm-17.0.6.src/lib/Target/X86/ImmutableGraph.h:380: callee_ptr_arith: Passing "N" to function "edges" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  378|         NewVertexArray[VertexI].Value = N.getValue();
#  379|         NewVertexArray[VertexI].Edges = &NewEdgeArray[EdgeI];
#  380|->       for (const Edge &E : N.edges()) {
#  381|           if (TrimEdges.contains(E))
#  382|             continue;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:300: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:300: assign: Assigning: "MemoryOperand" = "llvm::X86II::getMemoryOperandNo(TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:307: overflow: The expression "MemoryOperand + AddrSegmentReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:307: overflow_sink: "MemoryOperand + AddrSegmentReg", which might have overflowed, is passed to "Inst->getOperand(MemoryOperand + AddrSegmentReg)".
#  305|     if (MemoryOperand >= 0) {
#  306|       // Check for explicit segment override on memory operand.
#  307|->     SegmentReg = Inst.getOperand(MemoryOperand + X86::AddrSegmentReg).getReg();
#  308|     }
#  309|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:300: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:300: assign: Assigning: "MemoryOperand" = "llvm::X86II::getMemoryOperandNo(TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:302: overflow: The expression "MemoryOperand" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:339: overflow: The expression "MemoryOperand + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:339: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:340: overflow_sink: "BaseRegNum", which might have underflowed, is passed to "Inst->getOperand(BaseRegNum)".
#  338|     if (MemoryOperand >= 0) {
#  339|       unsigned BaseRegNum = MemoryOperand + X86::AddrBaseReg;
#  340|->     unsigned BaseReg = Inst.getOperand(BaseRegNum).getReg();
#  341|       if (BaseReg == X86::ESP || BaseReg == X86::EBP)
#  342|         return X86::SS_Encoding;

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:635: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:638: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 0 and 127 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:639: overrun-call: Overrunning callee's array of size 22 by passing argument "Kind" (which evaluates to 127) in call to "getFixupKindInfo".
#  637|   
#  638|     if (Kind < FirstTargetFixupKind)
#  639|->     return MCAsmBackend::getFixupKindInfo(Kind);
#  640|   
#  641|     assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:635: cond_between: Checking "Kind >= FirstLiteralRelocationKind" implies that "Kind" is between 0 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:638: cond_between: Checking "Kind < FirstTargetFixupKind" implies that "Kind" is between 128 and 255 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:644: illegal_address: "Infos[Kind - FirstTargetFixupKind]" evaluates to an address that is at byte offset 3048 of an array of 216 bytes.
#  642|            "Invalid kind!");
#  643|     assert(Infos[Kind - FirstTargetFixupKind].Name && "Empty fixup name!");
#  644|->   return Infos[Kind - FirstTargetFixupKind];
#  645|   }
#  646|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:1031: alias: Assigning: "Nops" = "Nops16Bit". "Nops" now points to element 0 of "Nops16Bit" (which consists of 4 11-byte elements).
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:1040: cond_at_most: Checking "ThisNopLength <= 10" implies that "ThisNopLength" may be up to 10 on the true branch.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:1040: assignment: Assigning: "Prefixes" = "(ThisNopLength <= 10) ? 0 : (ThisNopLength - 10)". The value of "Prefixes" is now 0.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:1043: assignment: Assigning: "Rest" = "ThisNopLength - Prefixes". The value of "Rest" may now be up to 10.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:1044: cond_between: Checking "Rest != 0" implies that "Rest" is between 1 and 10 (inclusive) on the true branch.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:1045: illegal_address: "Nops + (Rest - 1)" evaluates to an address that is at byte offset 99 of an array of 44 bytes.
# 1043|       const uint8_t Rest = ThisNopLength - Prefixes;
# 1044|       if (Rest != 0)
# 1045|->       OS.write(Nops[Rest - 1], Rest);
# 1046|       Count -= ThisNopLength;
# 1047|     } while (Count != 0);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86InstPrinterCommon.cpp:390: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86InstPrinterCommon.cpp:390: assign: Assigning: "MemoryOperand" = "llvm::X86II::getMemoryOperandNo(TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86InstPrinterCommon.cpp:395: overflow_sink: "MemoryOperand", which might be negative, is passed to "llvm::X86_MC::needsAddressSizeOverride(MI, STI, MemoryOperand, TSFlags)".
#  393|   
#  394|     // Address-Size override prefix
#  395|->   if (Flags & X86::IP_HAS_AD_SIZE &&
#  396|         !X86_MC::needsAddressSizeOverride(*MI, STI, MemoryOperand, TSFlags)) {
#  397|       if (STI.hasFeature(X86::Is16Bit) || STI.hasFeature(X86::Is64Bit))

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:793: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:793: assign: Assigning: "MemoryOperand" = "llvm::X86II::getMemoryOperandNo(TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:796: overflow: The expression "MemoryOperand" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:797: overflow: The expression "MemoryOperand + AddrSegmentReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:797: overflow_sink: "MemoryOperand + AddrSegmentReg", which might have underflowed, is passed to "this->emitSegmentOverridePrefix(MemoryOperand + AddrSegmentReg, MI, CB)".
#  795|     if (MemoryOperand != -1) {
#  796|       MemoryOperand += CurOp;
#  797|->     emitSegmentOverridePrefix(MemoryOperand + X86::AddrSegmentReg, MI, CB);
#  798|     }
#  799|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:793: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:793: assign: Assigning: "MemoryOperand" = "llvm::X86II::getMemoryOperandNo(TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:796: overflow: The expression "MemoryOperand" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCCodeEmitter.cpp:808: overflow_sink: "MemoryOperand", which might be negative, is passed to "llvm::X86_MC::needsAddressSizeOverride(MI, STI, MemoryOperand, TSFlags)".
#  806|   
#  807|     // Emit the address size opcode prefix as needed.
#  808|->   if (X86_MC::needsAddressSizeOverride(MI, STI, MemoryOperand, TSFlags) ||
#  809|         Flags & X86::IP_HAS_AD_SIZE)
#  810|       emitByte(0x67, CB);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:652: overflow: The expression "MemOpStart + AddrSegmentReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:652: overflow_sink: "MemOpStart + AddrSegmentReg", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrSegmentReg)".
#  650|     MemOpStart += X86II::getOperandBias(MCID);
#  651|   
#  652|->   const MCOperand &SegReg = Inst.getOperand(MemOpStart + X86::AddrSegmentReg);
#  653|     const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  654|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:650: overflow: The expression "MemOpStart" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:653: overflow: The expression "MemOpStart + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:653: overflow_sink: "MemOpStart + AddrBaseReg", which might have underflowed, is passed to "Inst->getOperand(MemOpStart + AddrBaseReg)".
#  651|   
#  652|     const MCOperand &SegReg = Inst.getOperand(MemOpStart + X86::AddrSegmentReg);
#  653|->   const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  654|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  655|     const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:654: overflow: The expression "MemOpStart + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:654: overflow_sink: "MemOpStart + AddrIndexReg", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrIndexReg)".
#  652|     const MCOperand &SegReg = Inst.getOperand(MemOpStart + X86::AddrSegmentReg);
#  653|     const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  654|->   const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  655|     const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);
#  656|     const MCOperand &Disp = Inst.getOperand(MemOpStart + X86::AddrDisp);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:655: overflow: The expression "MemOpStart + AddrScaleAmt" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:655: overflow_sink: "MemOpStart + AddrScaleAmt", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrScaleAmt)".
#  653|     const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  654|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  655|->   const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);
#  656|     const MCOperand &Disp = Inst.getOperand(MemOpStart + X86::AddrDisp);
#  657|     if (SegReg.getReg() != 0 || IndexReg.getReg() != 0 || ScaleAmt.getImm() != 1 ||

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:647: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:656: overflow: The expression "MemOpStart + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:656: overflow_sink: "MemOpStart + AddrDisp", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrDisp)".
#  654|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  655|     const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);
#  656|->   const MCOperand &Disp = Inst.getOperand(MemOpStart + X86::AddrDisp);
#  657|     if (SegReg.getReg() != 0 || IndexReg.getReg() != 0 || ScaleAmt.getImm() != 1 ||
#  658|         !Disp.isImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:678: overflow: The expression "MemOpStart + AddrSegmentReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:678: overflow_sink: "MemOpStart + AddrSegmentReg", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrSegmentReg)".
#  676|       return std::nullopt;
#  677|     MemOpStart += X86II::getOperandBias(MCID);
#  678|->   const MCOperand &SegReg = Inst.getOperand(MemOpStart + X86::AddrSegmentReg);
#  679|     const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  680|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:677: overflow: The expression "MemOpStart" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:679: overflow: The expression "MemOpStart + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:679: overflow_sink: "MemOpStart + AddrBaseReg", which might have underflowed, is passed to "Inst->getOperand(MemOpStart + AddrBaseReg)".
#  677|     MemOpStart += X86II::getOperandBias(MCID);
#  678|     const MCOperand &SegReg = Inst.getOperand(MemOpStart + X86::AddrSegmentReg);
#  679|->   const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  680|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  681|     const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:680: overflow: The expression "MemOpStart + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:680: overflow_sink: "MemOpStart + AddrIndexReg", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrIndexReg)".
#  678|     const MCOperand &SegReg = Inst.getOperand(MemOpStart + X86::AddrSegmentReg);
#  679|     const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  680|->   const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  681|     const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);
#  682|     const MCOperand &Disp = Inst.getOperand(MemOpStart + X86::AddrDisp);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:681: overflow: The expression "MemOpStart + AddrScaleAmt" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:681: overflow_sink: "MemOpStart + AddrScaleAmt", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrScaleAmt)".
#  679|     const MCOperand &BaseReg = Inst.getOperand(MemOpStart + X86::AddrBaseReg);
#  680|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  681|->   const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);
#  682|     const MCOperand &Disp = Inst.getOperand(MemOpStart + X86::AddrDisp);
#  683|     // Must be a simple rip-relative address.

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:674: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(MCID.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:682: overflow: The expression "MemOpStart + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.cpp:682: overflow_sink: "MemOpStart + AddrDisp", which might be negative, is passed to "Inst->getOperand(MemOpStart + AddrDisp)".
#  680|     const MCOperand &IndexReg = Inst.getOperand(MemOpStart + X86::AddrIndexReg);
#  681|     const MCOperand &ScaleAmt = Inst.getOperand(MemOpStart + X86::AddrScaleAmt);
#  682|->   const MCOperand &Disp = Inst.getOperand(MemOpStart + X86::AddrDisp);
#  683|     // Must be a simple rip-relative address.
#  684|     if (BaseReg.getReg() != X86::RIP || SegReg.getReg() != 0 ||

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:340: var_decl: Declaring variable "PotentialBlockers".
llvm-17.0.6.src/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:353: uninit_use: Using uninitialized value "PotentialBlockers". Field "PotentialBlockers.InlineElts" is uninitialized.
#  351|       MachineInstr &MI = *PBInst;
#  352|       if (MI.getDesc().isCall())
#  353|->       return PotentialBlockers;
#  354|       PotentialBlockers.push_back(&MI);
#  355|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:340: var_decl: Declaring variable "PotentialBlockers".
llvm-17.0.6.src/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:377: uninit_use: Using uninitialized value "PotentialBlockers". Field "PotentialBlockers.InlineElts" is uninitialized.
#  375|       }
#  376|     }
#  377|->   return PotentialBlockers;
#  378|   }
#  379|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86DomainReassignment.cpp:529: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86DomainReassignment.cpp:529: assign: Assigning: "MemOpStart" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86DomainReassignment.cpp:534: cast_underflow: An assign of a possibly negative number to an unsigned type, which might trigger an underflow.
llvm-17.0.6.src/lib/Target/X86/X86DomainReassignment.cpp:537: overflow_sink: "MemOpIdx", which might be negative, is passed to "MI->getOperand(MemOpIdx)".
#  535|                   MemOpEnd = MemOpStart + X86::AddrNumOperands;
#  536|          MemOpIdx < MemOpEnd; ++MemOpIdx) {
#  537|->     const MachineOperand &Op = MI.getOperand(MemOpIdx);
#  538|       if (Op.isReg() && Op.getReg() == Reg)
#  539|         return true;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:653: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:653: assign: Assigning: "AddrOffset" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:655: overflow: The expression "AddrOffset" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:656: overflow: The expression "AddrOffset + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:656: overflow_sink: "AddrOffset + AddrBaseReg", which might have underflowed, is passed to "MI->getOperand(AddrOffset + AddrBaseReg)".
#  654|     if (AddrOffset >= 0) {
#  655|       AddrOffset += X86II::getOperandBias(Desc);
#  656|->     MachineOperand &p = MI.getOperand(AddrOffset + X86::AddrBaseReg);
#  657|       if (p.isReg() && p.getReg() != X86::ESP) {
#  658|         seekLEAFixup(p, I, MBB);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:653: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:653: assign: Assigning: "AddrOffset" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:660: overflow: The expression "AddrOffset + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86FixupLEAs.cpp:660: overflow_sink: "AddrOffset + AddrIndexReg", which might have overflowed, is passed to "MI->getOperand(AddrOffset + AddrIndexReg)".
#  658|         seekLEAFixup(p, I, MBB);
#  659|       }
#  660|->     MachineOperand &q = MI.getOperand(AddrOffset + X86::AddrIndexReg);
#  661|       if (q.isReg() && q.getReg() != X86::ESP) {
#  662|         seekLEAFixup(q, I, MBB);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9274: var_decl: Declaring variable "FirstNonZeroIdx" without initializer.
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9330: uninit_use: Using uninitialized value "FirstNonZeroIdx".
# 9328|   
# 9329|     SDValue V2 = Elt.getOperand(0);
# 9330|->   if (Elt == FirstNonZero && EltIdx == FirstNonZeroIdx)
# 9331|       V1 = SDValue();
# 9332|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9806: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEhalf(), Val)".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9806: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 9804|       if (VT.isFloatingPoint()) {
# 9805|         if (ScalarSize == 16)
# 9806|->         return ConstantFP::get(C, APFloat(APFloat::IEEEhalf(), Val));
# 9807|         if (ScalarSize == 32)
# 9808|           return ConstantFP::get(C, APFloat(APFloat::IEEEsingle(), Val));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9808: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), Val)".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9808: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 9806|           return ConstantFP::get(C, APFloat(APFloat::IEEEhalf(), Val));
# 9807|         if (ScalarSize == 32)
# 9808|->         return ConstantFP::get(C, APFloat(APFloat::IEEEsingle(), Val));
# 9809|         assert(ScalarSize == 64 && "Unsupported floating point scalar size");
# 9810|         return ConstantFP::get(C, APFloat(APFloat::IEEEdouble(), Val));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9810: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), Val)".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:9810: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 9808|           return ConstantFP::get(C, APFloat(APFloat::IEEEsingle(), Val));
# 9809|         assert(ScalarSize == 64 && "Unsupported floating point scalar size");
# 9810|->       return ConstantFP::get(C, APFloat(APFloat::IEEEdouble(), Val));
# 9811|       }
# 9812|       return Constant::getIntegerValue(Type::getIntNTy(C, ScalarSize), Val);

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:18398: address_of: Taking address with "&Perm2" yields a singleton pointer.
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:18398: callee_ptr_arith: Passing "&Perm2" to function "ReplaceAllUsesWith" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#18396|                                 DAG.getTargetConstant(0x31, DL, MVT::i8));
#18397|     if (IsFirstHalf) {
#18398|->     DAG.ReplaceAllUsesWith(SecondHalf, &Perm2);
#18399|       return Perm1;
#18400|     }

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:18401: address_of: Taking address with "&Perm1" yields a singleton pointer.
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:18401: callee_ptr_arith: Passing "&Perm1" to function "ReplaceAllUsesWith" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#18399|       return Perm1;
#18400|     }
#18401|->   DAG.ReplaceAllUsesWith(FirstHalf, &Perm1);
#18402|     return Perm2;
#18403|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22022: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), llvm::APInt(64U, 4841369599423283200UL, false))".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22022: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#22020|   
#22021|     SmallVector<Constant*,2> CV1;
#22022|->   CV1.push_back(
#22023|       ConstantFP::get(*Context, APFloat(APFloat::IEEEdouble(),
#22024|                                         APInt(64, 0x4330000000000000ULL))));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22025: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), llvm::APInt(64U, 4985484787499139072UL, false))".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22025: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#22023|       ConstantFP::get(*Context, APFloat(APFloat::IEEEdouble(),
#22024|                                         APInt(64, 0x4330000000000000ULL))));
#22025|->   CV1.push_back(
#22026|       ConstantFP::get(*Context, APFloat(APFloat::IEEEdouble(),
#22027|                                         APInt(64, 0x4530000000000000ULL))));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22212: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), llvm::APInt(64U, 4841369599423283200UL, false))".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22212: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#22210|         Op->getSimpleValueType(0) == MVT::v4f64) {
#22211|       SDValue ZExtIn = DAG.getNode(ISD::ZERO_EXTEND, DL, MVT::v4i64, V);
#22212|->     Constant *Bias = ConstantFP::get(
#22213|           *DAG.getContext(),
#22214|           APFloat(APFloat::IEEEdouble(), APInt(64, 0x4330000000000000ULL)));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22298: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), llvm::APInt(32U, 1392509056UL, false))".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22298: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#22296|   
#22297|     // Create the vector constant for (0x1.0p39f + 0x1.0p23f).
#22298|->   SDValue VecCstFSub = DAG.getConstantFP(
#22299|         APFloat(APFloat::IEEEsingle(), APInt(32, 0x53000080)), DL, VecFloatVT);
#22300|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22568: var_decl: Declaring variable "Thresh".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:22582: uninit_use_in_call: Using uninitialized value "Thresh.U" when calling "getConstantFP".
#22580|              "FP conversion should have been exact");
#22581|   
#22582|->     SDValue ThreshVal = DAG.getConstantFP(Thresh, DL, TheVT);
#22583|   
#22584|       EVT ResVT = getSetCCResultType(DAG.getDataLayout(),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:24318: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, MaskElt)".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:24318: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#24316|                              APInt::getSignMask(EltBits);
#24317|     const fltSemantics &Sem = SelectionDAG::EVTToAPFloatSemantics(VT);
#24318|->   SDValue Mask = DAG.getConstantFP(APFloat(Sem, MaskElt), dl, LogicVT);
#24319|   
#24320|     SDValue Op0 = Op.getOperand(0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:24376: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, llvm::APInt(llvm::APInt::getSignMask(EltSizeInBits)))".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:24376: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#24374|     // The mask constants are automatically splatted for vector types.
#24375|     unsigned EltSizeInBits = VT.getScalarSizeInBits();
#24376|->   SDValue SignMask = DAG.getConstantFP(
#24377|         APFloat(Sem, APInt::getSignMask(EltSizeInBits)), dl, LogicVT);
#24378|     SDValue MagMask = DAG.getConstantFP(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:24378: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Sem, llvm::APInt(llvm::APInt::getSignedMaxValue(EltSizeInBits)))".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:24378: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#24376|     SDValue SignMask = DAG.getConstantFP(
#24377|         APFloat(Sem, APInt::getSignMask(EltSizeInBits)), dl, LogicVT);
#24378|->   SDValue MagMask = DAG.getConstantFP(
#24379|         APFloat(Sem, APInt::getSignedMaxValue(EltSizeInBits)), dl, LogicVT);
#24380|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:42013: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:42035: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
#42033|     switch (N.getOpcode()) {
#42034|     case X86ISD::PSHUFD:
#42035|->     return Mask;
#42036|     case X86ISD::PSHUFLW:
#42037|       Mask.resize(4);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:42013: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:42038: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
#42036|     case X86ISD::PSHUFLW:
#42037|       Mask.resize(4);
#42038|->     return Mask;
#42039|     case X86ISD::PSHUFHW:
#42040|       Mask.erase(Mask.begin(), Mask.begin() + 4);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:42013: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:42043: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
#42041|       for (int &M : Mask)
#42042|         M -= 4;
#42043|->     return Mask;
#42044|     default:
#42045|       llvm_unreachable("No valid shuffle instruction found!");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:45507: var_decl: Declaring variable "F64".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:45508: uninit_use_in_call: Using uninitialized value "F64.U" when calling "getConstantFP".
#45506|         // TODO - investigate supporting sext 32-bit immediates on x86_64.
#45507|         APFloat F64(APFloat::IEEEdouble(), EltBits[0]);
#45508|->       return DAG.getBitcast(VT, DAG.getConstantFP(F64, DL, MVT::f64));
#45509|       }
#45510|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:53485: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), AI)".
llvm-17.0.6.src/lib/Target/X86/X86ISelLowering.cpp:53485: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#53483|           return CI->getValue() == AI;
#53484|         if (const auto *CF = dyn_cast<ConstantFP>(CP->getConstVal()))
#53485|->         return CF->getValue() == APFloat(APFloat::IEEEsingle(), AI);
#53486|       }
#53487|       return false;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: assign: Assigning: "Offset" = "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: overflow: The expression "Offset + Bias" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:205: overflow_sink: "MemOpOffset", which might have overflowed, is passed to "<unnamed>::IsMemOpCompatibleWithPrefetch(*Current, MemOpOffset)".
#  203|         int MemOpOffset = Offset + Bias;
#  204|         // FIXME(mtrofin): ORE message when the recommendation cannot be taken.
#  205|->       if (!IsMemOpCompatibleWithPrefetch(*Current, MemOpOffset))
#  206|           continue;
#  207|         Prefetches.clear();

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: assign: Assigning: "Offset" = "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: overflow: The expression "Offset + Bias" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow: The expression "MemOpOffset + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow_sink: "MemOpOffset + AddrBaseReg", which might have underflowed, is passed to "Current->getOperand(MemOpOffset + AddrBaseReg)".
#  227|           // FIXME(mtrofin): consider adding a:
#  228|           //     MachineInstrBuilder::set(unsigned offset, op).
#  229|->         MIB.addReg(Current->getOperand(MemOpOffset + X86::AddrBaseReg).getReg())
#  230|               .addImm(
#  231|                   Current->getOperand(MemOpOffset + X86::AddrScaleAmt).getImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: assign: Assigning: "Offset" = "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow: The expression "MemOpOffset + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow_sink: "MemOpOffset + AddrDisp", which might have overflowed, is passed to "Current->getOperand(MemOpOffset + AddrDisp)".
#  227|           // FIXME(mtrofin): consider adding a:
#  228|           //     MachineInstrBuilder::set(unsigned offset, op).
#  229|->         MIB.addReg(Current->getOperand(MemOpOffset + X86::AddrBaseReg).getReg())
#  230|               .addImm(
#  231|                   Current->getOperand(MemOpOffset + X86::AddrScaleAmt).getImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: assign: Assigning: "Offset" = "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow: The expression "MemOpOffset + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow_sink: "MemOpOffset + AddrIndexReg", which might have overflowed, is passed to "Current->getOperand(MemOpOffset + AddrIndexReg)".
#  227|           // FIXME(mtrofin): consider adding a:
#  228|           //     MachineInstrBuilder::set(unsigned offset, op).
#  229|->         MIB.addReg(Current->getOperand(MemOpOffset + X86::AddrBaseReg).getReg())
#  230|               .addImm(
#  231|                   Current->getOperand(MemOpOffset + X86::AddrScaleAmt).getImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: assign: Assigning: "Offset" = "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow: The expression "MemOpOffset + AddrScaleAmt" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow_sink: "MemOpOffset + AddrScaleAmt", which might have overflowed, is passed to "Current->getOperand(MemOpOffset + AddrScaleAmt)".
#  227|           // FIXME(mtrofin): consider adding a:
#  228|           //     MachineInstrBuilder::set(unsigned offset, op).
#  229|->         MIB.addReg(Current->getOperand(MemOpOffset + X86::AddrBaseReg).getReg())
#  230|               .addImm(
#  231|                   Current->getOperand(MemOpOffset + X86::AddrScaleAmt).getImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:199: assign: Assigning: "Offset" = "llvm::X86II::getMemoryOperandNo(Current->getDesc().TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:203: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow: The expression "MemOpOffset + AddrSegmentReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InsertPrefetch.cpp:229: overflow_sink: "MemOpOffset + AddrSegmentReg", which might have overflowed, is passed to "Current->getOperand(MemOpOffset + AddrSegmentReg)".
#  227|           // FIXME(mtrofin): consider adding a:
#  228|           //     MachineInstrBuilder::set(unsigned offset, op).
#  229|->         MIB.addReg(Current->getOperand(MemOpOffset + X86::AddrBaseReg).getReg())
#  230|               .addImm(
#  231|                   Current->getOperand(MemOpOffset + X86::AddrScaleAmt).getImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3220: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3220: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3224: overflow: The expression "MemRefBegin + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3224: overflow_sink: "MemRefBegin + AddrDisp", which might be negative, is passed to "MI->getOperand(MemRefBegin + AddrDisp)".
# 3222|     MemRefBegin += X86II::getOperandBias(Desc);
# 3223|   
# 3224|->   const MachineOperand &MO = MI.getOperand(MemRefBegin + X86::AddrDisp);
# 3225|     if (!MO.isJTI())
# 3226|       return -1;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3813: overflow: The expression "MemRefBegin" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3815: overflow: The expression "MemRefBegin + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3815: overflow_sink: "MemRefBegin + AddrBaseReg", which might have underflowed, is passed to "MemI->getOperand(MemRefBegin + AddrBaseReg)".
# 3813|     MemRefBegin += X86II::getOperandBias(Desc);
# 3814|   
# 3815|->   auto &BaseOp = MemI.getOperand(MemRefBegin + X86::AddrBaseReg);
# 3816|     if (!BaseOp.isReg()) // Can be an MO_FrameIndex
# 3817|       return std::nullopt;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3819: overflow: The expression "MemRefBegin + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3819: overflow_sink: "MemRefBegin + AddrDisp", which might have overflowed, is passed to "MemI->getOperand(MemRefBegin + AddrDisp)".
# 3817|       return std::nullopt;
# 3818|   
# 3819|->   const MachineOperand &DispMO = MemI.getOperand(MemRefBegin + X86::AddrDisp);
# 3820|     // Displacement can be symbolic
# 3821|     if (!DispMO.isImm())

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3826: overflow: The expression "MemRefBegin + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3826: overflow_sink: "MemRefBegin + AddrIndexReg", which might have overflowed, is passed to "MemI->getOperand(MemRefBegin + AddrIndexReg)".
# 3824|     ExtAddrMode AM;
# 3825|     AM.BaseReg = BaseOp.getReg();
# 3826|->   AM.ScaledReg = MemI.getOperand(MemRefBegin + X86::AddrIndexReg).getReg();
# 3827|     AM.Scale = MemI.getOperand(MemRefBegin + X86::AddrScaleAmt).getImm();
# 3828|     AM.Displacement = DispMO.getImm();

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3809: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3827: overflow: The expression "MemRefBegin + AddrScaleAmt" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3827: overflow_sink: "MemRefBegin + AddrScaleAmt", which might have overflowed, is passed to "MemI->getOperand(MemRefBegin + AddrScaleAmt)".
# 3825|     AM.BaseReg = BaseOp.getReg();
# 3826|     AM.ScaledReg = MemI.getOperand(MemRefBegin + X86::AddrIndexReg).getReg();
# 3827|->   AM.Scale = MemI.getOperand(MemRefBegin + X86::AddrScaleAmt).getImm();
# 3828|     AM.Displacement = DispMO.getImm();
# 3829|     return AM;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3910: overflow: The expression "MemRefBegin" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3912: overflow: The expression "MemRefBegin + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3912: overflow_sink: "MemRefBegin + AddrBaseReg", which might have underflowed, is passed to "MemOp->getOperand(MemRefBegin + AddrBaseReg)".
# 3910|     MemRefBegin += X86II::getOperandBias(Desc);
# 3911|   
# 3912|->   const MachineOperand *BaseOp =
# 3913|         &MemOp.getOperand(MemRefBegin + X86::AddrBaseReg);
# 3914|     if (!BaseOp->isReg()) // Can be an MO_FrameIndex

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3917: overflow: The expression "MemRefBegin + AddrScaleAmt" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3917: overflow_sink: "MemRefBegin + AddrScaleAmt", which might have overflowed, is passed to "MemOp->getOperand(MemRefBegin + AddrScaleAmt)".
# 3915|       return false;
# 3916|   
# 3917|->   if (MemOp.getOperand(MemRefBegin + X86::AddrScaleAmt).getImm() != 1)
# 3918|       return false;
# 3919|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3920: overflow: The expression "MemRefBegin + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3920: overflow_sink: "MemRefBegin + AddrIndexReg", which might have overflowed, is passed to "MemOp->getOperand(MemRefBegin + AddrIndexReg)".
# 3918|       return false;
# 3919|   
# 3920|->   if (MemOp.getOperand(MemRefBegin + X86::AddrIndexReg).getReg() !=
# 3921|         X86::NoRegister)
# 3922|       return false;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3906: assign: Assigning: "MemRefBegin" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3924: overflow: The expression "MemRefBegin + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:3924: overflow_sink: "MemRefBegin + AddrDisp", which might have overflowed, is passed to "MemOp->getOperand(MemRefBegin + AddrDisp)".
# 3922|       return false;
# 3923|   
# 3924|->   const MachineOperand &DispMO = MemOp.getOperand(MemRefBegin + X86::AddrDisp);
# 3925|   
# 3926|     // Displacement can be symbolic

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:6895: var_decl: Declaring variable "LoadMMOs".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:6911: uninit_use: Using uninitialized value "LoadMMOs". Field "LoadMMOs.InlineElts" is uninitialized.
# 6909|     }
# 6910|   
# 6911|->   return LoadMMOs;
# 6912|   }
# 6913|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:6916: var_decl: Declaring variable "StoreMMOs".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:6932: uninit_use: Using uninitialized value "StoreMMOs". Field "StoreMMOs.InlineElts" is uninitialized.
# 6930|     }
# 6931|   
# 6932|->   return StoreMMOs;
# 6933|   }
# 6934|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:8442: var_decl: Declaring variable "Nop".
llvm-17.0.6.src/lib/Target/X86/X86InstrInfo.cpp:8444: uninit_use: Using uninitialized value "Nop". Field "Nop.Operands.InlineElts" is uninitialized.
# 8442|     MCInst Nop;
# 8443|     Nop.setOpcode(X86::NOOP);
# 8444|->   return Nop;
# 8445|   }
# 8446|   

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:562: address_of: Taking address with "*__begin1" yields a singleton pointer.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:562: assign: Assigning: "RootN" = "*__begin1".
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:563: callee_ptr_arith: Passing "RootN" to function "edges" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  561|     NodeSet ReachableNodes{G};
#  562|     for (const Node &RootN : G.nodes()) {
#  563|->     if (llvm::none_of(RootN.edges(), MachineGadgetGraph::isGadgetEdge))
#  564|         continue; // skip this node if it isn't a gadget source
#  565|   

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:688: address_of: Taking address with "*__begin1" yields a singleton pointer.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:688: assign: Assigning: "N" = "*__begin1".
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:689: callee_ptr_arith: Passing "N" to function "edges" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  687|     // than the gadget sink, or an (a)-type cut otherwise.
#  688|     for (const Node &N : Graph->nodes()) {
#  689|->     for (const Edge &E : N.edges()) {
#  690|         if (!MachineGadgetGraph::isGadgetEdge(E))
#  691|           continue;

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:728: address_of: Taking address with "*__begin1" yields a singleton pointer.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:728: assign: Assigning: "N" = "*__begin1".
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:729: callee_ptr_arith: Passing "N" to function "edges" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  727|     int FencesInserted = 0;
#  728|     for (const Node &N : G.nodes()) {
#  729|->     for (const Edge &E : N.edges()) {
#  730|         if (CutEdges.contains(E)) {
#  731|           MachineInstr *MI = N.getValue(), *Prev;

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:776: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:776: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:783: overflow: The expression "MemRefBeginIdx" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:785: overflow: The expression "MemRefBeginIdx + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:785: overflow_sink: "MemRefBeginIdx + AddrBaseReg", which might have underflowed, is passed to "MI->getOperand(MemRefBeginIdx + AddrBaseReg)".
#  783|     MemRefBeginIdx += X86II::getOperandBias(Desc);
#  784|   
#  785|->   const MachineOperand &BaseMO =
#  786|         MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
#  787|     const MachineOperand &IndexMO =

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:776: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:776: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:787: overflow: The expression "MemRefBeginIdx + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:787: overflow_sink: "MemRefBeginIdx + AddrIndexReg", which might have overflowed, is passed to "MI->getOperand(MemRefBeginIdx + AddrIndexReg)".
#  785|     const MachineOperand &BaseMO =
#  786|         MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
#  787|->   const MachineOperand &IndexMO =
#  788|         MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);
#  789|     return (BaseMO.isReg() && BaseMO.getReg() != X86::NoRegister &&

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:447: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:447: assign: Assigning: "MemOpNo" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:454: overflow: The expression "MemOpNo" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:458: overflow: The expression "MemOpNo + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:458: overflow_sink: "MemOpNo + AddrBaseReg", which might have underflowed, is passed to "MI->getOperand(MemOpNo + AddrBaseReg)".
#  456|       // If the address base of the use instruction is not the LEA def register -
#  457|       // the LEA is not replaceable.
#  458|->     if (!isIdenticalOp(MI.getOperand(MemOpNo + X86::AddrBaseReg), MO))
#  459|         return false;
#  460|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:447: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:447: assign: Assigning: "MemOpNo" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:469: overflow: The expression "MemOpNo + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:469: overflow_sink: "MemOpNo + AddrDisp", which might have overflowed, is passed to "MI->getOperand(MemOpNo + AddrDisp)".
#  467|   
#  468|       // Check that the new address displacement will fit 4 bytes.
#  469|->     if (MI.getOperand(MemOpNo + X86::AddrDisp).isImm() &&
#  470|           !isInt<32>(MI.getOperand(MemOpNo + X86::AddrDisp).getImm() +
#  471|                      AddrDispShift))

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:511: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:511: assign: Assigning: "MemOpNo" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:517: overflow: The expression "MemOpNo" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:520: overflow_sink: "MemOpNo", which might have overflowed, is passed to "getMemOpKey(MI, MemOpNo)".
#  518|   
#  519|       // Do not call chooseBestLEA if there was no matching LEA
#  520|->     auto Insns = LEAs.find(getMemOpKey(MI, MemOpNo));
#  521|       if (Insns == LEAs.end())
#  522|         continue;
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:520: note: trimmed 1 message(s) with length over 512

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:672: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:672: cast_overflow: An assign that casts to a different type, which might trigger an overflow.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:680: overflow: The expression "MemOpNo + AddrDisp" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86OptimizeLEAs.cpp:680: overflow_sink: "MemOpNo + AddrDisp", which might have overflowed, is passed to "MI->getOperand(MemOpNo + AddrDisp)".
#  678|   
#  679|             // Update address disp.
#  680|->           MachineOperand &Op = MI.getOperand(MemOpNo + X86::AddrDisp);
#  681|             if (Op.isImm())
#  682|               Op.setImm(Op.getImm() + AddrDispShift);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86RegisterBankInfo.cpp:309: var_decl: Declaring variable "AltMappings".
llvm-17.0.6.src/lib/Target/X86/X86RegisterBankInfo.cpp:311: uninit_use: Using uninitialized value "AltMappings". Field "AltMappings.InlineElts" is uninitialized.
#  309|       InstructionMappings AltMappings;
#  310|       AltMappings.push_back(&Mapping);
#  311|->     return AltMappings;
#  312|     }
#  313|     default:

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:601: var_decl: Declaring variable "Infos".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:681: uninit_use: Using uninitialized value "Infos". Field "Infos.InlineElts" is uninitialized.
#  679|     }
#  680|   
#  681|->   return Infos;
#  682|   }
#  683|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1052: var_decl: Declaring variable "CMovs".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1056: uninit_use: Using uninitialized value "CMovs". Field "CMovs.InlineElts" is uninitialized.
# 1054|     // If we didn't find any indirect branches with targets, nothing to do here.
# 1055|     if (IndirectTargetMBBs.empty())
# 1056|->     return CMovs;
# 1057|   
# 1058|     // We found indirect branches and targets that need to be instrumented to

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1052: var_decl: Declaring variable "CMovs".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1200: uninit_use: Using uninitialized value "CMovs". Field "CMovs.InlineElts" is uninitialized.
# 1198|   
# 1199|     // Return all the newly inserted cmov instructions of the predicate state.
# 1200|->   return CMovs;
# 1201|   }
# 1202|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1326: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1326: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1334: overflow: The expression "MemRefBeginIdx" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1336: overflow: The expression "MemRefBeginIdx + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1336: overflow_sink: "MemRefBeginIdx + AddrBaseReg", which might have underflowed, is passed to "MI->getOperand(MemRefBeginIdx + AddrBaseReg)".
# 1334|           MemRefBeginIdx += X86II::getOperandBias(Desc);
# 1335|   
# 1336|->         MachineOperand &BaseMO =
# 1337|               MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
# 1338|           MachineOperand &IndexMO =

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1326: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1326: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1338: overflow: The expression "MemRefBeginIdx + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1338: overflow_sink: "MemRefBeginIdx + AddrIndexReg", which might have overflowed, is passed to "MI->getOperand(MemRefBeginIdx + AddrIndexReg)".
# 1336|           MachineOperand &BaseMO =
# 1337|               MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
# 1338|->         MachineOperand &IndexMO =
# 1339|               MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);
# 1340|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1405: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1405: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1408: overflow: The expression "MemRefBeginIdx" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1410: overflow: The expression "MemRefBeginIdx + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1410: overflow_sink: "MemRefBeginIdx + AddrBaseReg", which might have underflowed, is passed to "MI->getOperand(MemRefBeginIdx + AddrBaseReg)".
# 1408|             MemRefBeginIdx += X86II::getOperandBias(Desc);
# 1409|   
# 1410|->           MachineOperand &BaseMO =
# 1411|                 MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
# 1412|             MachineOperand &IndexMO =

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1405: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1405: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1412: overflow: The expression "MemRefBeginIdx + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1412: overflow_sink: "MemRefBeginIdx + AddrIndexReg", which might be negative, is passed to "MI->getOperand(MemRefBeginIdx + AddrIndexReg)".
# 1410|             MachineOperand &BaseMO =
# 1411|                 MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
# 1412|->           MachineOperand &IndexMO =
# 1413|                 MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);
# 1414|             hardenLoadAddr(MI, BaseMO, IndexMO, AddrRegToHardenedReg);

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1807: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1807: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1810: overflow: The expression "MemRefBeginIdx" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1812: overflow: The expression "MemRefBeginIdx + AddrBaseReg" is deemed overflowed because at least one of its arguments has overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1812: overflow_sink: "MemRefBeginIdx + AddrBaseReg", which might have underflowed, is passed to "UseMI->getOperand(MemRefBeginIdx + AddrBaseReg)".
# 1810|           MemRefBeginIdx += X86II::getOperandBias(Desc);
# 1811|   
# 1812|->         MachineOperand &BaseMO =
# 1813|               UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
# 1814|           MachineOperand &IndexMO =

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1807: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1807: assign: Assigning: "MemRefBeginIdx" = "llvm::X86II::getMemoryOperandNo(Desc.TSFlags)".
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1814: overflow: The expression "MemRefBeginIdx + AddrIndexReg" is considered to have possibly overflowed.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1814: overflow_sink: "MemRefBeginIdx + AddrIndexReg", which might be negative, is passed to "UseMI->getOperand(MemRefBeginIdx + AddrIndexReg)".
# 1812|           MachineOperand &BaseMO =
# 1813|               UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);
# 1814|->         MachineOperand &IndexMO =
# 1815|               UseMI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);
# 1816|           if ((BaseMO.isReg() && BaseMO.getReg() == DefReg) ||

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1873: return_constant: Function call "llvm::Log2_32(RegBytes)" may return 4294967295.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1873: assignment: Assigning: "RegIdx" = "llvm::Log2_32(RegBytes)". The value of "RegIdx" is now 4294967295.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1886: overrun-local: Overrunning array "NOREXRegClasses" of 4 8-byte elements at element index 4294967295 (byte offset 34359738367) using index "RegIdx" (which evaluates to 4294967295).
# 1884|         &X86::GR8_NOREXRegClass, &X86::GR16_NOREXRegClass,
# 1885|         &X86::GR32_NOREXRegClass, &X86::GR64_NOREXRegClass};
# 1886|->   if (RC == NOREXRegClasses[RegIdx])
# 1887|       return false;
# 1888|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1873: return_constant: Function call "llvm::Log2_32(RegBytes)" may return 4294967295.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1873: assignment: Assigning: "RegIdx" = "llvm::Log2_32(RegBytes)". The value of "RegIdx" is now 4294967295.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1892: overrun-local: Overrunning array "GPRRegClasses" of 4 8-byte elements at element index 4294967295 (byte offset 34359738367) using index "RegIdx" (which evaluates to 4294967295).
# 1890|         &X86::GR8RegClass, &X86::GR16RegClass, &X86::GR32RegClass,
# 1891|         &X86::GR64RegClass};
# 1892|->   return RC->hasSuperClassEq(GPRRegClasses[RegIdx]);
# 1893|   }
# 1894|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1924: return_constant: Function call "llvm::Log2_32(Bytes)" may return 4294967295.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1924: overrun-local: Overrunning array "SubRegImms" of 3 4-byte elements at element index 4294967295 (byte offset 17179869183) using index "llvm::Log2_32(Bytes)" (which evaluates to 4294967295).
# 1922|     if (Bytes != 8) {
# 1923|       unsigned SubRegImms[] = {X86::sub_8bit, X86::sub_16bit, X86::sub_32bit};
# 1924|->     unsigned SubRegImm = SubRegImms[Log2_32(Bytes)];
# 1925|       Register NarrowStateReg = MRI->createVirtualRegister(RC);
# 1926|       BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), NarrowStateReg)

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1937: return_constant: Function call "llvm::Log2_32(Bytes)" may return 4294967295.
llvm-17.0.6.src/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1937: overrun-local: Overrunning array "OrOpCodes" of 4 4-byte elements at element index 4294967295 (byte offset 17179869183) using index "llvm::Log2_32(Bytes)" (which evaluates to 4294967295).
# 1935|     Register NewReg = MRI->createVirtualRegister(RC);
# 1936|     unsigned OrOpCodes[] = {X86::OR8rr, X86::OR16rr, X86::OR32rr, X86::OR64rr};
# 1937|->   unsigned OrOpCode = OrOpCodes[Log2_32(Bytes)];
# 1938|     auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOpCode), NewReg)
# 1939|                    .addReg(StateReg)

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Target/X86/X86TargetTransformInfo.cpp:6104: var_decl: Declaring variable "Options".
llvm-17.0.6.src/lib/Target/X86/X86TargetTransformInfo.cpp:6123: uninit_use: Using uninitialized value "Options". Field "Options.LoadSizes.InlineElts" is uninitialized.
# 6121|     Options.LoadSizes.push_back(2);
# 6122|     Options.LoadSizes.push_back(1);
# 6123|->   return Options;
# 6124|   }
# 6125|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/TextAPI/TextStub.cpp:583: var_decl: Declaring variable "Targets".
llvm-17.0.6.src/lib/TextAPI/TextStub.cpp:595: uninit_use: Using uninitialized value "Targets". Field "Targets.InlineElts" is uninitialized.
#  593|           }
#  594|         }
#  595|->       return Targets;
#  596|       }
#  597|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Coroutines/CoroFrame.cpp:472: var_decl: Declaring variable "Defs".
llvm-17.0.6.src/lib/Transforms/Coroutines/CoroFrame.cpp:477: uninit_use: Using uninitialized value "Defs". Field "Defs.InlineElts" is uninitialized.
#  475|       for (const auto &A : Allocas)
#  476|         Defs.push_back(A.Alloca);
#  477|->     return Defs;
#  478|     }
#  479|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Coroutines/CoroFrame.cpp:802: var_decl: Declaring variable "Allocas".
llvm-17.0.6.src/lib/Transforms/Coroutines/CoroFrame.cpp:806: uninit_use: Using uninitialized value "Allocas". Field "Allocas.InlineElts" is uninitialized.
#  804|       for (const auto &A : FrameData.Allocas)
#  805|         Allocas.push_back(A.Alloca);
#  806|->     return Allocas;
#  807|     };
#  808|     StackLifetime StackLifetimeAnalyzer(F, ExtractAllocas(),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Coroutines/CoroSplit.cpp:689: var_decl: Declaring variable "Intrinsics".
llvm-17.0.6.src/lib/Transforms/Coroutines/CoroSplit.cpp:693: uninit_use: Using uninitialized value "Intrinsics". Field "Intrinsics.InlineElts" is uninitialized.
#  691|       if (auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I))
#  692|         Intrinsics.push_back(DVI);
#  693|->   return Intrinsics;
#  694|   }
#  695|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/Attributor.cpp:3696: var_decl: Declaring variable "AC".
llvm-17.0.6.src/lib/Transforms/IPO/Attributor.cpp:3699: uninit_use_in_call: Using uninitialized value "AC.IPOAmendableCB". Field "AC.IPOAmendableCB.callable" is uninitialized when calling "AttributorConfig".
# 3697|     AC.IsModulePass = IsModulePass;
# 3698|     AC.DeleteFns = DeleteFns;
# 3699|->   Attributor A(Functions, InfoCache, AC);
# 3700|   
# 3701|     // Create shallow wrappers for all functions that are not IPO amendable

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/Attributor.cpp:3696: var_decl: Declaring variable "AC".
llvm-17.0.6.src/lib/Transforms/IPO/Attributor.cpp:3699: uninit_use_in_call: Using uninitialized value "AC.OREGetter". Field "AC.OREGetter.callable" is uninitialized when calling "AttributorConfig".
# 3697|     AC.IsModulePass = IsModulePass;
# 3698|     AC.DeleteFns = DeleteFns;
# 3699|->   Attributor A(Functions, InfoCache, AC);
# 3700|   
# 3701|     // Create shallow wrappers for all functions that are not IPO amendable

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Transforms/IPO/ForceFunctionAttrs.cpp:43: assignment: Assigning: "Kind" = "llvm::Attribute::getAttrKindFromName(KV.second)". The value of "Kind" is now between 0 and 87 (inclusive).
llvm-17.0.6.src/lib/Transforms/IPO/ForceFunctionAttrs.cpp:44: cond_between: Checking "Kind == None" implies that "Kind" is between 1 and 87 (inclusive) on the false branch.
llvm-17.0.6.src/lib/Transforms/IPO/ForceFunctionAttrs.cpp:44: overrun-call: Overrunning callee's array of size 84 by passing argument "Kind" (which evaluates to 87) in call to "canUseAsFnAttr".
#   42|         return Kind;
#   43|       Kind = Attribute::getAttrKindFromName(KV.second);
#   44|->     if (Kind == Attribute::None || !Attribute::canUseAsFnAttr(Kind)) {
#   45|         LLVM_DEBUG(dbgs() << "ForcedAttribute: " << KV.second
#   46|                           << " unknown or not a function attribute!\n");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/FunctionAttrs.cpp:1692: var_decl: Declaring variable "Res".
llvm-17.0.6.src/lib/Transforms/IPO/FunctionAttrs.cpp:1718: uninit_use: Using uninitialized value "Res". Field "Res.SCCNodes.vector_.InlineElts" is uninitialized.
# 1716|       Res.SCCNodes.insert(F);
# 1717|     }
# 1718|->   return Res;
# 1719|   }
# 1720|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:955: var_decl: Declaring variable "TIL".
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:1020: uninit_use: Using uninitialized value "TIL". Field "TIL.AlignLog2" is uninitialized.
# 1018|           TTRes.SizeM1BitWidth <= 5 ? Int32Ty : Int64Ty);
# 1019|   
# 1020|->   return TIL;
# 1021|   }
# 1022|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:955: var_decl: Declaring variable "TIL".
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:1020: uninit_use: Using uninitialized value "TIL". Field "TIL.InlineBits" is uninitialized.
# 1018|           TTRes.SizeM1BitWidth <= 5 ? Int32Ty : Int64Ty);
# 1019|   
# 1020|->   return TIL;
# 1021|   }
# 1022|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:955: var_decl: Declaring variable "TIL".
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:1020: uninit_use: Using uninitialized value "TIL". Field "TIL.OffsetedGlobal" is uninitialized.
# 1018|           TTRes.SizeM1BitWidth <= 5 ? Int32Ty : Int64Ty);
# 1019|   
# 1020|->   return TIL;
# 1021|   }
# 1022|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:955: var_decl: Declaring variable "TIL".
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:1020: uninit_use: Using uninitialized value "TIL". Field "TIL.TheByteArray" is uninitialized.
# 1018|           TTRes.SizeM1BitWidth <= 5 ? Int32Ty : Int64Ty);
# 1019|   
# 1020|->   return TIL;
# 1021|   }
# 1022|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:1125: var_decl: Declaring variable "TIL".
llvm-17.0.6.src/lib/Transforms/IPO/LowerTypeTests.cpp:1162: uninit_use_in_call: Using uninitialized value "TIL.InlineBits" when calling "lowerTypeTestCall".
# 1160|       for (CallInst *CI : TIUI.CallSites) {
# 1161|         ++NumTypeTestCallsLowered;
# 1162|->       Value *Lowered = lowerTypeTestCall(TypeId, CI, TIL);
# 1163|         if (Lowered) {
# 1164|           CI->replaceAllUsesWith(Lowered);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:2812: var_decl: Declaring variable "VMaps".
llvm-17.0.6.src/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:2861: uninit_use: Using uninitialized value "VMaps". Field "VMaps.InlineElts" is uninitialized.
# 2859|       }
# 2860|     }
# 2861|->   return VMaps;
# 2862|   }
# 2863|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/OpenMPOpt.cpp:5549: var_decl: Declaring variable "AC".
llvm-17.0.6.src/lib/Transforms/IPO/OpenMPOpt.cpp:5558: uninit_use_in_call: Using uninitialized value "AC.IPOAmendableCB". Field "AC.IPOAmendableCB.callable" is uninitialized when calling "AttributorConfig".
# 5556|     AC.InitializationCallback = OpenMPOpt::registerAAsForFunction;
# 5557|   
# 5558|->   Attributor A(Functions, InfoCache, AC);
# 5559|   
# 5560|     OpenMPOpt OMPOpt(SCC, CGUpdater, OREGetter, InfoCache, A);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/IPO/SampleProfile.cpp:1638: var_decl: Declaring variable "R".
llvm-17.0.6.src/lib/Transforms/IPO/SampleProfile.cpp:1643: uninit_use: Using uninitialized value "R". Field "R.InlineElts" is uninitialized.
# 1641|           InstrProfValueData{FunctionSamples::getGUID(I.first), I.second});
# 1642|     }
# 1643|->   return R;
# 1644|   }
# 1645|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/lib/Transforms/IPO/SampleProfile.cpp:2569: extract: Calling "get" which extracts wrapped state from local "OwnedORE".
llvm-17.0.6.src/lib/Transforms/IPO/SampleProfile.cpp:2569: escape: The internal representation of local "OwnedORE" escapes into "this->ORE", but is destroyed when it exits scope.
# 2567|     } else {
# 2568|       OwnedORE = std::make_unique<OptimizationRemarkEmitter>(&F);
# 2569|->     ORE = OwnedORE.get();
# 2570|     }
# 2571|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineAddSub.cpp:386: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(C0->getValueAPF()->getSemantics())".
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineAddSub.cpp:386: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  384|   
#  385|       // Both operands are zero. Weird!
#  386|->     Addend0.set(APFloat(C0->getValueAPF().getSemantics()), nullptr);
#  387|       return 1;
#  388|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7132: var_decl: Declaring variable "SMax".
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7133: uninit_use_in_call: Using uninitialized value "SMax.U" when calling "convertFromAPInt".
# 7131|       // and large values.
# 7132|       APFloat SMax(RHS.getSemantics());
# 7133|->     SMax.convertFromAPInt(APInt::getSignedMaxValue(IntWidth), true,
# 7134|                             APFloat::rmNearestTiesToEven);
# 7135|       if (SMax < RHS) { // smax < 13123.0

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7144: var_decl: Declaring variable "UMax".
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7145: uninit_use_in_call: Using uninitialized value "UMax.U" when calling "convertFromAPInt".
# 7143|       // +INF and large values.
# 7144|       APFloat UMax(RHS.getSemantics());
# 7145|->     UMax.convertFromAPInt(APInt::getMaxValue(IntWidth), false,
# 7146|                             APFloat::rmNearestTiesToEven);
# 7147|       if (UMax < RHS) { // umax < 13123.0

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7157: var_decl: Declaring variable "SMin".
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7158: uninit_use_in_call: Using uninitialized value "SMin.U" when calling "convertFromAPInt".
# 7156|       // See if the RHS value is < SignedMin.
# 7157|       APFloat SMin(RHS.getSemantics());
# 7158|->     SMin.convertFromAPInt(APInt::getSignedMinValue(IntWidth), true,
# 7159|                             APFloat::rmNearestTiesToEven);
# 7160|       if (SMin > RHS) { // smin > 12312.0

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7168: var_decl: Declaring variable "UMin".
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCompares.cpp:7169: uninit_use_in_call: Using uninitialized value "UMin.U" when calling "convertFromAPInt".
# 7167|       // See if the RHS value is < UnsignedMin.
# 7168|       APFloat UMin(RHS.getSemantics());
# 7169|->     UMin.convertFromAPInt(APInt::getMinValue(IntWidth), false,
# 7170|                             APFloat::rmNearestTiesToEven);
# 7171|       if (UMin > RHS) { // umin > 12312.0

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstructionCombining.cpp:1092: var_decl: Declaring variable "Cond" without initializer.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstructionCombining.cpp:1146: uninit_use_in_call: Using uninitialized value "Cond" when calling "CreateSelect".
# 1144|       return nullptr;
# 1145|   
# 1146|->   Value *SI = Builder.CreateSelect(Cond, True, False);
# 1147|     SI->takeName(&I);
# 1148|     return SI;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:67: var_decl: Declaring variable "Dependencies".
llvm-17.0.6.src/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:74: uninit_use: Using uninitialized value "Dependencies". Field "Dependencies.vector_.InlineElts" is uninitialized.
#   72|     if (It != SuccessorDependencies.end())
#   73|       Dependencies.set_union(It->second);
#   74|->   return Dependencies;
#   75|   }
#   76|   
llvm-17.0.6.src/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:74: note: trimmed 2 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:1240: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:1257: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
# 1255|       assert(Result.empty() &&
# 1256|              "If no outer (top-level), must return no nested ones");
# 1257|->   return Result;
# 1258|   }
# 1259|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:1316: var_decl: Declaring variable "ArgIt".
llvm-17.0.6.src/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:1317: uninit_use_in_call: Using uninitialized value "ArgIt". Field "ArgIt.Ptr" is uninitialized when calling "vector".
# 1315|     } else {
# 1316|       auto ArgIt = pointer_iterator<Argument *>(NewF->arg_begin());
# 1317|->     std::vector<Value *> Args(ArgIt, ArgIt + FT->getNumParams());
# 1318|   
# 1319|       CallInst *CI = CallInst::Create(F, Args, "", BB);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/GCOVProfiling.cpp:214: var_decl: Declaring variable "Path".
llvm-17.0.6.src/lib/Transforms/Instrumentation/GCOVProfiling.cpp:220: uninit_use: Using uninitialized value "Path". Field "Path.InlineElts" is uninitialized.
#  218|     else
#  219|       sys::path::append(Path, SP->getDirectory(), SP->getFilename());
#  220|->   return Path;
#  221|   }
#  222|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3628: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3632: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
# 3630|         Mask.append(2, X);
# 3631|       }
# 3632|->     return Mask;
# 3633|     }
# 3634|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4626: tainted_data_return: Called function "this->getNumOutputArgs(IA, CB)", and a possible return value may be less than zero.
llvm-17.0.6.src/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4626: assign: Assigning: "OutputArgs" = "this->getNumOutputArgs(IA, CB)".
llvm-17.0.6.src/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4632: assign: Assigning: "i" = "OutputArgs".
llvm-17.0.6.src/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4633: overflow_sink: "i", which might have overflowed, is passed to "CB->getOperand(i)".
# 4631|       // that we won't overwrite uninit values before checking them.
# 4632|       for (int i = OutputArgs; i < NumOperands; i++) {
# 4633|->       Value *Operand = CB->getOperand(i);
# 4634|         instrumentAsmArgument(Operand, CB->getParamElementType(i), I, IRB, DL,
# 4635|                               /*isOutput*/ false);

Error: VIRTUAL_DTOR (CWE-772):
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:494: no_virtual_dtor: Class "<unnamed>::PGOBBInfo" does not have a virtual destructor.
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1002: dtor_in_derived: Class "<unnamed>::PGOUseBBInfo" has a compiler-generated destructor. It is non-empty because of its field "InEdges". A pointer to class "<unnamed>::PGOUseBBInfo" is upcast to class "<unnamed>::PGOBBInfo" which doesn't have a virtual destructor.
llvm-17.0.6.src/include/llvm/Transforms/Instrumentation/CFGMST.h:57: upcast: Example 1: Casting from a pointer to "<unnamed>::PGOUseBBInfo" to a pointer to "<unnamed>::PGOBBInfo" in "this->findAndCompressGroup(static_cast<<unnamed>::PGOUseBBInfo *>(G->Group))".
/usr/include/c++/14/bits/unique_ptr.h:93: delete: Example 1: Deletion of type "<unnamed>::PGOBBInfo".
/usr/include/c++/14/bits/unique_ptr.h:1076: alloc: Example 1: Allocated an object of type "<unnamed>::PGOUseBBInfo".
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1007: non-empty_dtor_field: Field "InEdges" in class "<unnamed>::PGOUseBBInfo".
#  492|   
#  493|   /// This class stores the auxiliary information for each BB in the MST.
#  494|-> struct PGOBBInfo {
#  495|     PGOBBInfo *Group;
#  496|     uint32_t Index;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1866: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(CountValue * 1.)".
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1866: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1864|       CountValue = Func.getBBInfo(&BBI).CountValue;
# 1865|       BFICountValue = *BFICount;
# 1866|->     SumCount.add(APFloat(CountValue * 1.0), APFloat::rmNearestTiesToEven);
# 1867|       SumBFICount.add(APFloat(BFICountValue * 1.0), APFloat::rmNearestTiesToEven);
# 1868|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1867: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(BFICountValue * 1.)".
llvm-17.0.6.src/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1867: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1865|       BFICountValue = *BFICount;
# 1866|       SumCount.add(APFloat(CountValue * 1.0), APFloat::rmNearestTiesToEven);
# 1867|->     SumBFICount.add(APFloat(BFICountValue * 1.0), APFloat::rmNearestTiesToEven);
# 1868|     }
# 1869|     if (SumCount.isZero())

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:757: overrun-local: Overrunning array "this->TsanAtomicRMW" of 17 80-byte elements at element index 31 (byte offset 2559) using index "RMWI->getOperation()" (which evaluates to 31).
#  755|       if (Idx < 0)
#  756|         return false;
#  757|->     FunctionCallee F = TsanAtomicRMW[RMWI->getOperation()][Idx];
#  758|       if (!F)
#  759|         return false;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/DivRemPairs.cpp:145: var_decl: Declaring variable "Worklist".
llvm-17.0.6.src/lib/Transforms/Scalar/DivRemPairs.cpp:164: uninit_use: Using uninitialized value "Worklist". Field "Worklist.InlineElts" is uninitialized.
#  162|     }
#  163|   
#  164|->   return Worklist;
#  165|   }
#  166|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:327: var_decl: Declaring variable "e".
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:368: uninit_use: Using uninitialized value "e". Field "e.varargs.InlineElts" is uninitialized.
#  366|     }
#  367|   
#  368|->   return e;
#  369|   }
#  370|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:375: var_decl: Declaring variable "e".
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:387: uninit_use: Using uninitialized value "e". Field "e.varargs.InlineElts" is uninitialized.
#  385|     e.opcode = (Opcode << 8) | Predicate;
#  386|     e.commutative = true;
#  387|->   return e;
#  388|   }
#  389|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:393: var_decl: Declaring variable "e".
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:405: uninit_use: Using uninitialized value "e". Field "e.varargs.InlineElts" is uninitialized.
#  403|       e.varargs.push_back(lookupOrAdd(WO->getLHS()));
#  404|       e.varargs.push_back(lookupOrAdd(WO->getRHS()));
#  405|->     return e;
#  406|     }
#  407|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:420: var_decl: Declaring variable "E".
llvm-17.0.6.src/lib/Transforms/Scalar/GVN.cpp:448: uninit_use: Using uninitialized value "E". Field "E.varargs.InlineElts" is uninitialized.
#  446|         E.varargs.push_back(lookupOrAdd(Op));
#  447|     }
#  448|->   return E;
#  449|   }
#  450|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/GVNSink.cpp:245: var_decl: Declaring variable "M".
llvm-17.0.6.src/lib/Transforms/Scalar/GVNSink.cpp:247: uninit_use: Using uninitialized value "M". Field "M.Values.InlineElts" is uninitialized.
#  245|       ModelledPHI M;
#  246|       M.Values.push_back(reinterpret_cast<Value*>(ID));
#  247|->     return M;
#  248|     }
#  249|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1156: var_decl: Declaring variable "V".
llvm-17.0.6.src/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1158: uninit_use: Using uninitialized value "V". Field "V.InlineElts" is uninitialized.
# 1156|       SmallVector<const SCEV *, 4>  V;
# 1157|       V.push_back(reinterpret_cast<const SCEV *>(-1));
# 1158|->     return V;
# 1159|     }
# 1160|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1162: var_decl: Declaring variable "V".
llvm-17.0.6.src/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1164: uninit_use: Using uninitialized value "V". Field "V.InlineElts" is uninitialized.
# 1162|       SmallVector<const SCEV *, 4> V;
# 1163|       V.push_back(reinterpret_cast<const SCEV *>(-2));
# 1164|->     return V;
# 1165|     }
# 1166|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:2400: var_decl: Declaring variable "Leaves".
llvm-17.0.6.src/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:2407: uninit_use: Using uninitialized value "Leaves". Field "Leaves.InlineElts" is uninitialized.
# 2405|               }))
# 2406|             Leaves.push_back(Expr);
# 2407|->       return Leaves;
# 2408|       }
# 2409|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/ASanStackFrameLayout.cpp:118: var_decl: Declaring variable "SB".
llvm-17.0.6.src/lib/Transforms/Utils/ASanStackFrameLayout.cpp:130: uninit_use: Using uninitialized value "SB". Field "SB.InlineElts" is uninitialized.
#  128|     }
#  129|     SB.resize(Layout.FrameSize / Granularity, kAsanStackRightRedzoneMagic);
#  130|->   return SB;
#  131|   }
#  132|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/InlineFunction.cpp:1348: var_decl: Declaring variable "Valid".
llvm-17.0.6.src/lib/Transforms/Utils/InlineFunction.cpp:1360: uninit_use: Using uninitialized value "Valid". Field "Valid.Attrs.InlineElts" is uninitialized.
# 1358|     if (AB.contains(Attribute::NonNull))
# 1359|       Valid.addAttribute(Attribute::NonNull);
# 1360|->   return Valid;
# 1361|   }
# 1362|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:102: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(Val)".
llvm-17.0.6.src/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:102: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  100|     Value *createCond(IRBuilder<> &BBBuilder, Value *Arg, CmpInst::Predicate Cmp,
#  101|                       float Val) {
#  102|->     Constant *V = ConstantFP::get(BBBuilder.getContext(), APFloat(Val));
#  103|       if (!Arg->getType()->isFloatTy())
#  104|         V = ConstantExpr::getFPExtend(V, Arg->getType());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/LoopUtils.cpp:124: var_decl: Declaring variable "UsedOutside".
llvm-17.0.6.src/lib/Transforms/Utils/LoopUtils.cpp:138: uninit_use: Using uninitialized value "UsedOutside". Field "UsedOutside.InlineElts" is uninitialized.
#  136|       }
#  137|   
#  138|->   return UsedOutside;
#  139|   }
#  140|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/SampleProfileInference.cpp:137: var_decl: Declaring variable "SrcEdge" without initializer.
llvm-17.0.6.src/lib/Transforms/Utils/SampleProfileInference.cpp:151: uninit_use_in_call: Using uninitialized value "SrcEdge". Field "SrcEdge.OnShortestPath" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  149|       DstEdge.RevEdgeIndex = Edges[Src].size();
#  150|   
#  151|->     Edges[Src].push_back(SrcEdge);
#  152|       Edges[Dst].push_back(DstEdge);
#  153|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/SampleProfileInference.cpp:144: var_decl: Declaring variable "DstEdge" without initializer.
llvm-17.0.6.src/lib/Transforms/Utils/SampleProfileInference.cpp:152: uninit_use_in_call: Using uninitialized value "DstEdge". Field "DstEdge.OnShortestPath" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  150|   
#  151|       Edges[Src].push_back(SrcEdge);
#  152|->     Edges[Dst].push_back(DstEdge);
#  153|     }
#  154|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/ValueMapper.cpp:1066: var_decl: Declaring variable "WE" without initializer.
llvm-17.0.6.src/lib/Transforms/Utils/ValueMapper.cpp:1071: uninit_use_in_call: Using uninitialized value "WE". Field "WE.AppendingGVIsOldCtorDtor" is uninitialized when calling "push_back".
# 1069|     WE.Data.GVInit.GV = &GV;
# 1070|     WE.Data.GVInit.Init = &Init;
# 1071|->   Worklist.push_back(WE);
# 1072|   }
# 1073|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/ValueMapper.cpp:1100: var_decl: Declaring variable "WE" without initializer.
llvm-17.0.6.src/lib/Transforms/Utils/ValueMapper.cpp:1105: uninit_use_in_call: Using uninitialized value "WE". Field "WE.AppendingGVIsOldCtorDtor" is uninitialized when calling "push_back".
# 1103|     WE.Data.AliasOrIFunc.GV = &GV;
# 1104|     WE.Data.AliasOrIFunc.Target = &Target;
# 1105|->   Worklist.push_back(WE);
# 1106|   }
# 1107|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Utils/ValueMapper.cpp:1112: var_decl: Declaring variable "WE" without initializer.
llvm-17.0.6.src/lib/Transforms/Utils/ValueMapper.cpp:1116: uninit_use_in_call: Using uninitialized value "WE". Field "WE.AppendingGVIsOldCtorDtor" is uninitialized when calling "push_back".
# 1114|     WE.MCID = MCID;
# 1115|     WE.Data.RemapF = &F;
# 1116|->   Worklist.push_back(WE);
# 1117|   }
# 1118|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:2545: var_decl: Declaring variable "Mask".
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:2548: uninit_use: Using uninitialized value "Mask". Field "Mask.InlineElts" is uninitialized.
# 2546|         inversePermutation(ReorderIndices, Mask);
# 2547|         ::addMask(Mask, ReuseShuffleIndices);
# 2548|->       return Mask;
# 2549|       }
# 2550|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:3567: var_decl: Declaring variable "V".
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:3569: uninit_use: Using uninitialized value "V". Field "V.InlineElts" is uninitialized.
# 3567|         OrdersType V;
# 3568|         V.push_back(~1U);
# 3569|->       return V;
# 3570|       }
# 3571|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:3573: var_decl: Declaring variable "V".
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:3575: uninit_use: Using uninitialized value "V". Field "V.InlineElts" is uninitialized.
# 3573|         OrdersType V;
# 3574|         V.push_back(~2U);
# 3575|->       return V;
# 3576|       }
# 3577|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:5031: var_decl: Declaring variable "ExternalReorderIndices".
llvm-17.0.6.src/lib/Transforms/Vectorize/SLPVectorizer.cpp:5051: uninit_use: Using uninitialized value "ExternalReorderIndices". Field "ExternalReorderIndices.InlineElts" is uninitialized.
# 5049|       ExternalReorderIndices.push_back(ReorderIndices);
# 5050|     }
# 5051|->   return ExternalReorderIndices;
# 5052|   }
# 5053|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/VPlanSLP.cpp:156: var_decl: Declaring variable "Operands".
llvm-17.0.6.src/lib/Transforms/Vectorize/VPlanSLP.cpp:162: uninit_use: Using uninitialized value "Operands". Field "Operands.InlineElts" is uninitialized.
#  160|       Operands.push_back(U->getOperand(OperandIndex));
#  161|     }
#  162|->   return Operands;
#  163|   }
#  164|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/VPlanSLP.cpp:172: var_decl: Declaring variable "Result".
llvm-17.0.6.src/lib/Transforms/Vectorize/VPlanSLP.cpp:187: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  185|     }
#  186|   
#  187|->   return Result;
#  188|   }
#  189|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/lib/Transforms/Vectorize/VPlanSLP.cpp:297: var_decl: Declaring variable "FinalOrder".
llvm-17.0.6.src/lib/Transforms/Vectorize/VPlanSLP.cpp:341: uninit_use: Using uninitialized value "FinalOrder". Field "FinalOrder.InlineElts" is uninitialized.
#  339|     }
#  340|   
#  341|->   return FinalOrder;
#  342|   }
#  343|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenDAGISel.inc:239642: overrun-call: Overrunning callee's array of size 8 by passing argument "llvm::cast(N)->getMergedOrdering()" (which evaluates to 15) in call to "isReleaseOrStronger".
#239640|       SDNode *N = Node;
#239641|       (void)N;
#239642|-> if (isReleaseOrStronger(cast<AtomicSDNode>(N)->getMergedOrdering())) return false;
#239643|   return true;
#239644|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenDAGISel.inc:239674: overrun-call: Overrunning callee's array of size 8 by passing argument "llvm::cast(N)->getMergedOrdering()" (which evaluates to 15) in call to "isReleaseOrStronger".
#239672|       SDNode *N = Node;
#239673|       (void)N;
#239674|-> if (!isReleaseOrStronger(cast<AtomicSDNode>(N)->getMergedOrdering())) return false;
#239675|   return true;
#239676|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenDAGISel.inc:239696: overrun-call: Overrunning callee's array of size 8 by passing argument "llvm::cast(N)->getMergedOrdering()" (which evaluates to 15) in call to "isAcquireOrStronger".
#239694|       SDNode *N = Node;
#239695|       (void)N;
#239696|-> if (isAcquireOrStronger(cast<AtomicSDNode>(N)->getMergedOrdering())) return false;
#239697|   return true;
#239698|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/redhat-linux-build/lib/Target/ARM/ARMGenDAGISel.inc:91550: assignment: Assigning: "Ordering" = "llvm::cast(N)->getSuccessOrdering()". The value of "Ordering" may now be up to 15.
llvm-17.0.6.src/redhat-linux-build/lib/Target/ARM/ARMGenDAGISel.inc:91551: overrun-call: Overrunning callee's array of size 8 by passing argument "Ordering" (which evaluates to 15) in call to "isAcquireOrStronger".
#91549|   
#91550|     AtomicOrdering Ordering = cast<AtomicSDNode>(N)->getSuccessOrdering();
#91551|->   return isAcquireOrStronger(Ordering);
#91552|   
#91553|     }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/redhat-linux-build/lib/Target/ARM/ARMGenDAGISel.inc:91570: assignment: Assigning: "Ordering" = "llvm::cast(N)->getSuccessOrdering()". The value of "Ordering" may now be up to 15.
llvm-17.0.6.src/redhat-linux-build/lib/Target/ARM/ARMGenDAGISel.inc:91571: overrun-call: Overrunning callee's array of size 8 by passing argument "Ordering" (which evaluates to 15) in call to "isReleaseOrStronger".
#91569|   
#91570|     AtomicOrdering Ordering = cast<AtomicSDNode>(N)->getSuccessOrdering();
#91571|->   return isReleaseOrStronger(Ordering);
#91572|   
#91573|     }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/dsymutil/DwarfLinkerForBinary.cpp:145: move: "Err" is moved (indicated by "std::move(Err)").
llvm-17.0.6.src/tools/dsymutil/DwarfLinkerForBinary.cpp:148: use_after_move: "Err" is used after it has been already moved.
#  146|                         toString(std::move(Err)),
#  147|                     Obj.getObjectFilename());
#  148|->     return errorToErrorCode(std::move(Err));
#  149|     }
#  150|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/dsymutil/DwarfLinkerForBinary.cpp:154: move: "Err" is moved (indicated by "std::move(Err)").
llvm-17.0.6.src/tools/dsymutil/DwarfLinkerForBinary.cpp:157: use_after_move: "Err" is used after it has been already moved.
#  155|                         toString(std::move(Err)),
#  156|                     Obj.getObjectFilename());
#  157|->     return errorToErrorCode(std::move(Err));
#  158|     }
#  159|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/dsymutil/dsymutil.cpp:308: var_decl: Declaring variable "Options".
llvm-17.0.6.src/tools/dsymutil/dsymutil.cpp:420: uninit_use_in_call: Using uninitialized value "Options.NumThreads" when calling "Expected".
#  418|     if (Error E = verifyOptions(Options))
#  419|       return std::move(E);
#  420|->   return Options;
#  421|   }
#  422|   

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/tools/llvm-c-test/calc.c:128: address_of: Taking address with "&param" yields a singleton pointer.
llvm-17.0.6.src/tools/llvm-c-test/calc.c:128: callee_ptr_arith: Passing "&param" to function "LLVMGetParams" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#  126|     LLVMPositionBuilderAtEnd(builder, LLVMAppendBasicBlock(F, "entry"));
#  127|   
#  128|->   LLVMGetParams(F, &param);
#  129|     LLVMSetValueName(param, "in");
#  130|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/tools/llvm-c-test/diagnostic.c:72: alloc_arg: "LLVMGetBitcodeModule2" allocates memory that is stored into "M".
llvm-17.0.6.src/tools/llvm-c-test/diagnostic.c:82: leaked_storage: Variable "M" going out of scope leaks the storage it points to.
#   80|     }
#   81|   
#   82|->   return 0;
#   83|   }

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/tools/llvm-c-test/object.c:78: alloc_fn: Storage is returned from allocation function "LLVMObjectFileCopySectionIterator".
llvm-17.0.6.src/tools/llvm-c-test/object.c:78: var_assign: Assigning: "sect" = storage returned from "LLVMObjectFileCopySectionIterator(O)".
llvm-17.0.6.src/tools/llvm-c-test/object.c:96: leaked_storage: Variable "sect" going out of scope leaks the storage it points to.
#   94|     LLVMDisposeMemoryBuffer(MB);
#   95|   
#   96|->   return 0;
#   97|   }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/llvm-cov/CodeCoverage.cpp:347: move: "CoverageInfo" is moved (indicated by "std::move(CoverageInfo)").
llvm-17.0.6.src/tools/llvm-cov/CodeCoverage.cpp:347: use_after_move: "CoverageInfo" is used after it has been already moved.
#  345|   
#  346|       if (!ViewBranches.empty()) {
#  347|->       auto SubView = SourceCoverageView::create(SourceName, File, ViewOpts,
#  348|                                                   std::move(CoverageInfo));
#  349|         View.addBranch(CurrentLine, ViewBranches, std::move(SubView));

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/tools/llvm-cov/llvm-cov.cpp:80: extract: Calling "c_str" which extracts wrapped state from local "Invocation".
llvm-17.0.6.src/tools/llvm-cov/llvm-cov.cpp:80: escape: The internal representation of local "Invocation" escapes into "argv[1]", but is destroyed when it exits scope.
#   78|       if (Func) {
#   79|         std::string Invocation = std::string(argv[0]) + " " + argv[1];
#   80|->       argv[1] = Invocation.c_str();
#   81|         return Func(argc - 1, argv + 1);
#   82|       }

Error: Y2K38_SAFETY (CWE-197):
llvm-17.0.6.src/tools/llvm-cvtres/llvm-cvtres.cpp:100: store_truncates_time_t: A "time_t" value is stored in an integer with too few bits to accommodate it.  The expression "Now" is cast to "uint32_t".
#   98|     if (Now < 0 || !isUInt<32>(Now))
#   99|       return UINT32_MAX;
#  100|->   return static_cast<uint32_t>(Now);
#  101|   }
#  102|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/llvm-dwp/llvm-dwp.cpp:101: move: "DWOName" is moved (indicated by "std::move(DWOName)").
llvm-17.0.6.src/tools/llvm-dwp/llvm-dwp.cpp:103: use_after_move: "DWOName" is used after it has been already moved.
#  101|         SmallString<16> DWOPath(std::move(DWOName));
#  102|         sys::fs::make_absolute(DWOCompDir, DWOPath);
#  103|->       if (!sys::fs::exists(DWOPath) && sys::fs::exists(DWOName))
#  104|           DWOPaths.push_back(std::move(DWOName));
#  105|         else

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-exegesis/lib/CodeTemplate.cpp:116: var_decl: Declaring variable "Result".
llvm-17.0.6.src/tools/llvm-exegesis/lib/CodeTemplate.cpp:120: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  118|       if ((Execution & Bit) == Bit)
#  119|         Result.push_back(Bit);
#  120|->   return Result;
#  121|   }
#  122|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/llvm-exegesis/lib/PerfHelper.cpp:110: move: "E" is moved (indicated by "std::move(E)").
llvm-17.0.6.src/tools/llvm-exegesis/lib/PerfHelper.cpp:114: use_after_move: "E" is used after it has been already moved.
#  112|     IsDummyEvent = Event.name() == PerfEvent::DummyEventString;
#  113|     if (!IsDummyEvent)
#  114|->     initRealEvent(E, ProcessID);
#  115|   }
#  116|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-exegesis/lib/SchedClassResolution.cpp:53: var_decl: Declaring variable "Result".
llvm-17.0.6.src/tools/llvm-exegesis/lib/SchedClassResolution.cpp:120: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#  118|       }
#  119|     }
#  120|->   return Result;
#  121|   }
#  122|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/tools/llvm-exegesis/lib/SubprocessMemory.cpp:93: alloc_fn: Storage is returned from allocation function "mmap".
llvm-17.0.6.src/tools/llvm-exegesis/lib/SubprocessMemory.cpp:93: var_assign: Assigning: "AuxiliaryMemoryMapping" = storage returned from "mmap(NULL, 4096UL, 3, 1, AuxiliaryMemoryFileDescriptor, 0L)".
llvm-17.0.6.src/tools/llvm-exegesis/lib/SubprocessMemory.cpp:105: leaked_storage: Variable "AuxiliaryMemoryMapping" going out of scope leaks the storage it points to.
#  103|           shm_open(MemoryValueName.c_str(), O_RDWR, S_IRUSR | S_IWUSR);
#  104|       if (AuxiliaryMemoryMapping[AuxiliaryMemoryOffset + MemVal.Index] == -1)
#  105|->       return make_error<Failure>("Mapping shared memory failed");
#  106|     }
#  107|     if (munmap(AuxiliaryMemoryMapping, 4096) == -1)

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: assign: Assigning: "MemOpIdx" = "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)".
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:886: overflow_sink: "MemOpIdx + 0", which might be negative, is passed to "llvm::exegesis::setMemOp(IT, MemOpIdx + 0, llvm::MCOperand const(llvm::MCOperand::createReg(Reg)))".
#  884|     // getMemoryOperandNo() ignores tied operands, so we have to add them back.
#  885|     MemOpIdx += X86II::getOperandBias(IT.getInstr().Description);
#  886|->   setMemOp(IT, MemOpIdx + 0, MCOperand::createReg(Reg));    // BaseReg
#  887|     setMemOp(IT, MemOpIdx + 1, MCOperand::createImm(1));      // ScaleAmt
#  888|     setMemOp(IT, MemOpIdx + 2, MCOperand::createReg(0));      // IndexReg

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: assign: Assigning: "MemOpIdx" = "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)".
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:887: overflow: The expression "MemOpIdx + 1" is considered to have possibly overflowed.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:887: overflow_sink: "MemOpIdx + 1", which might be negative, is passed to "llvm::exegesis::setMemOp(IT, MemOpIdx + 1, llvm::MCOperand const(llvm::MCOperand::createImm(1L)))".
#  885|     MemOpIdx += X86II::getOperandBias(IT.getInstr().Description);
#  886|     setMemOp(IT, MemOpIdx + 0, MCOperand::createReg(Reg));    // BaseReg
#  887|->   setMemOp(IT, MemOpIdx + 1, MCOperand::createImm(1));      // ScaleAmt
#  888|     setMemOp(IT, MemOpIdx + 2, MCOperand::createReg(0));      // IndexReg
#  889|     setMemOp(IT, MemOpIdx + 3, MCOperand::createImm(Offset)); // Disp

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: assign: Assigning: "MemOpIdx" = "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)".
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:888: overflow: The expression "MemOpIdx + 2" is considered to have possibly overflowed.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:888: overflow_sink: "MemOpIdx + 2", which might be negative, is passed to "llvm::exegesis::setMemOp(IT, MemOpIdx + 2, llvm::MCOperand const(llvm::MCOperand::createReg(0U)))".
#  886|     setMemOp(IT, MemOpIdx + 0, MCOperand::createReg(Reg));    // BaseReg
#  887|     setMemOp(IT, MemOpIdx + 1, MCOperand::createImm(1));      // ScaleAmt
#  888|->   setMemOp(IT, MemOpIdx + 2, MCOperand::createReg(0));      // IndexReg
#  889|     setMemOp(IT, MemOpIdx + 3, MCOperand::createImm(Offset)); // Disp
#  890|     setMemOp(IT, MemOpIdx + 4, MCOperand::createReg(0));      // Segment

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: assign: Assigning: "MemOpIdx" = "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)".
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:889: overflow: The expression "MemOpIdx + 3" is considered to have possibly overflowed.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:889: overflow_sink: "MemOpIdx + 3", which might be negative, is passed to "llvm::exegesis::setMemOp(IT, MemOpIdx + 3, llvm::MCOperand const(llvm::MCOperand::createImm(Offset)))".
#  887|     setMemOp(IT, MemOpIdx + 1, MCOperand::createImm(1));      // ScaleAmt
#  888|     setMemOp(IT, MemOpIdx + 2, MCOperand::createReg(0));      // IndexReg
#  889|->   setMemOp(IT, MemOpIdx + 3, MCOperand::createImm(Offset)); // Disp
#  890|     setMemOp(IT, MemOpIdx + 4, MCOperand::createReg(0));      // Segment
#  891|   }

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: tainted_data_return: Called function "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)", and a possible return value may be less than zero.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:882: assign: Assigning: "MemOpIdx" = "llvm::X86II::getMemoryOperandNo(IT->getInstr().Description.TSFlags)".
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:890: overflow: The expression "MemOpIdx + 4" is considered to have possibly overflowed.
llvm-17.0.6.src/tools/llvm-exegesis/lib/X86/Target.cpp:890: overflow_sink: "MemOpIdx + 4", which might be negative, is passed to "llvm::exegesis::setMemOp(IT, MemOpIdx + 4, llvm::MCOperand const(llvm::MCOperand::createReg(0U)))".
#  888|     setMemOp(IT, MemOpIdx + 2, MCOperand::createReg(0));      // IndexReg
#  889|     setMemOp(IT, MemOpIdx + 3, MCOperand::createImm(Offset)); // Disp
#  890|->   setMemOp(IT, MemOpIdx + 4, MCOperand::createReg(0));      // Segment
#  891|   }
#  892|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:75: alloc_arg: "getaddrinfo" allocates memory that is stored into "AI".
llvm-17.0.6.src/tools/llvm-jitlink/llvm-jitlink-executor/llvm-jitlink-executor.cpp:109: leaked_storage: Variable "AI" going out of scope leaks the storage it points to.
#  107|     return accept(SockFD, AI->ai_addr, &AddrLen);
#  108|   #else
#  109|->   return accept(SockFD, AI->ai_addr, &AI->ai_addrlen);
#  110|   #endif
#  111|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-jitlink/llvm-jitlink.cpp:1488: var_decl: Declaring variable "PathVec".
llvm-17.0.6.src/tools/llvm-jitlink/llvm-jitlink.cpp:1495: uninit_use: Using uninitialized value "PathVec". Field "PathVec.InlineElts" is uninitialized.
# 1493|       StringRef(getenv("LD_LIBRARY_PATH")).split(PathVec, ":");
# 1494|   
# 1495|->   return PathVec;
# 1496|   }
# 1497|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:682: var_decl: Declaring variable "C".
llvm-17.0.6.src/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:690: uninit_use_in_call: Using uninitialized value "C". Field "C.ArchCPUType" is uninitialized when calling "Expected".
#  688|                                  "-static option: must be specified");
#  689|       }
#  690|->     return C;
#  691|     }
#  692|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:682: var_decl: Declaring variable "C".
llvm-17.0.6.src/tools/llvm-libtool-darwin/llvm-libtool-darwin.cpp:733: uninit_use_in_call: Using uninitialized value "C". Field "C.ArchCPUType" is uninitialized when calling "Expected".
#  731|                                 InputFiles, OutputFile);
#  732|   
#  733|->   return C;
#  734|   }
#  735|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-lipo/llvm-lipo.cpp:321: var_decl: Declaring variable "InputBinaries".
llvm-17.0.6.src/tools/llvm-lipo/llvm-lipo.cpp:350: uninit_use: Using uninitialized value "InputBinaries". Field "InputBinaries.InlineElts" is uninitialized.
#  348|       InputBinaries.push_back(std::move(*BinaryOrErr));
#  349|     }
#  350|->   return InputBinaries;
#  351|   }
#  352|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-lipo/llvm-lipo.cpp:560: var_decl: Declaring variable "Slices".
llvm-17.0.6.src/tools/llvm-lipo/llvm-lipo.cpp:602: uninit_use: Using uninitialized value "Slices". Field "Slices.InlineElts" is uninitialized.
#  600|     }
#  601|     updateAlignments(Slices, Alignments);
#  602|->   return Slices;
#  603|   }
#  604|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-mca/CodeRegion.cpp:164: var_decl: Declaring variable "AI".
llvm-17.0.6.src/tools/llvm-mca/CodeRegion.cpp:171: uninit_use: Using uninitialized value "AI". Field "AI.InlineElts" is uninitialized.
#  169|       }
#  170|     }
#  171|->   return AI;
#  172|   }
#  173|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/tools/llvm-objdump/COFFDump.cpp:862: alloc_fn: Storage is returned from allocation function "microsoftDemangle".
llvm-17.0.6.src/tools/llvm-objdump/COFFDump.cpp:862: var_assign: Assigning: "DemangledSymbol" = storage returned from "llvm::microsoftDemangle(Name.operator std::string_view(), NULL, &Status, MSDF_None)".
llvm-17.0.6.src/tools/llvm-objdump/COFFDump.cpp:870: leaked_storage: Variable "DemangledSymbol" going out of scope leaks the storage it points to.
#  868|           outs() << " (invalid mangled name)";
#  869|         }
#  870|->     }
#  871|       outs() << "\n";
#  872|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:1241: var_decl: Declaring variable "Ret".
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:1251: uninit_use: Using uninitialized value "Ret". Field "Ret.InlineElts" is uninitialized.
# 1249|       }
# 1250|     }
# 1251|->   return Ret;
# 1252|   }
# 1253|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:2897: var_decl: Declaring variable "r_value" without initializer.
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:2939: uninit_use_in_call: Using uninitialized value "r_value" when calling "GuessSymbolName".
# 2937|       if (reloc_found && (r_type == MachO::GENERIC_RELOC_SECTDIFF ||
# 2938|                           r_type == MachO::GENERIC_RELOC_LOCAL_SECTDIFF)) {
# 2939|->       const char *add = GuessSymbolName(r_value, info->AddrMap);
# 2940|         const char *sub = GuessSymbolName(pair_r_value, info->AddrMap);
# 2941|         uint32_t offset = value - (r_value - pair_r_value);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:2897: var_decl: Declaring variable "pair_r_value" without initializer.
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:2940: uninit_use_in_call: Using uninitialized value "pair_r_value" when calling "GuessSymbolName".
# 2938|                           r_type == MachO::GENERIC_RELOC_LOCAL_SECTDIFF)) {
# 2939|         const char *add = GuessSymbolName(r_value, info->AddrMap);
# 2940|->       const char *sub = GuessSymbolName(pair_r_value, info->AddrMap);
# 2941|         uint32_t offset = value - (r_value - pair_r_value);
# 2942|         op_info->AddSymbol.Present = 1;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:6541: var_decl: Declaring variable "objc_class" without initializer.
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:6645: uninit_use: Using uninitialized value "objc_class.info".
# 6643|         }
# 6644|   
# 6645|->       if (CLS_GETINFO(&objc_class, CLS_CLASS)) {
# 6646|           outs() << "\tMeta Class";
# 6647|           r = get_pointer_32(objc_class.isa, xoffset, left, xS, &info, true);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:6541: var_decl: Declaring variable "objc_class" without initializer.
llvm-17.0.6.src/tools/llvm-objdump/MachODump.cpp:6647: uninit_use_in_call: Using uninitialized value "objc_class.isa" when calling "get_pointer_32".
# 6645|         if (CLS_GETINFO(&objc_class, CLS_CLASS)) {
# 6646|           outs() << "\tMeta Class";
# 6647|->         r = get_pointer_32(objc_class.isa, xoffset, left, xS, &info, true);
# 6648|           if (r != nullptr) {
# 6649|             if (left > sizeof(struct objc_class_t)) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-pdbutil/BytesOutputStyle.cpp:65: var_decl: Declaring variable "Result".
llvm-17.0.6.src/tools/llvm-pdbutil/BytesOutputStyle.cpp:76: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#   74|       Result.push_back(*ESS);
#   75|     }
#   76|->   return Result;
#   77|   }
#   78|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/llvm-pdbutil/DumpOutputStyle.cpp:1497: move: "EC" is moved (indicated by "std::move(EC)").
llvm-17.0.6.src/tools/llvm-pdbutil/DumpOutputStyle.cpp:1499: use_after_move: "EC" is used after it has been already moved.
# 1497|               P.formatLine("Error while processing symbol records.  {0}",
# 1498|                            toString(std::move(EC)));
# 1499|->             return EC;
# 1500|             }
# 1501|           } else if (auto EC = Visitor.visitSymbolStream(ModS.getSymbolArray(),

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/tools/llvm-pdbutil/DumpOutputStyle.cpp:1503: move: "EC" is moved (indicated by "std::move(EC)").
llvm-17.0.6.src/tools/llvm-pdbutil/DumpOutputStyle.cpp:1505: use_after_move: "EC" is used after it has been already moved.
# 1503|             P.formatLine("Error while processing symbol records.  {0}",
# 1504|                          toString(std::move(EC)));
# 1505|->           return EC;
# 1506|           }
# 1507|           return Error::success();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-pdbutil/PrettyClassDefinitionDumper.cpp:98: var_decl: Declaring variable "Pct".
llvm-17.0.6.src/tools/llvm-pdbutil/PrettyClassDefinitionDumper.cpp:101: uninit_use_in_call: Using uninitialized value "Pct.U" when calling "toString".
#   99|                   (double)Layout.getSize());
#  100|       SmallString<8> PctStr;
#  101|->     Pct.toString(PctStr, 4);
#  102|       WithColor(Printer, PDB_ColorItem::Padding).get()
#  103|           << "Total padding " << Layout.deepPaddingSize() << " bytes (" << PctStr

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-pdbutil/PrettyClassDefinitionDumper.cpp:106: var_decl: Declaring variable "Pct2".
llvm-17.0.6.src/tools/llvm-pdbutil/PrettyClassDefinitionDumper.cpp:109: uninit_use_in_call: Using uninitialized value "Pct2.U" when calling "toString".
#  107|                    (double)Layout.getSize());
#  108|       PctStr.clear();
#  109|->     Pct2.toString(PctStr, 4);
#  110|       WithColor(Printer, PDB_ColorItem::Padding).get()
#  111|           << "Immediate padding " << Layout.immediatePadding() << " bytes ("

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-pdbutil/llvm-pdbutil.cpp:813: var_decl: Declaring variable "DefaultInfoStream".
llvm-17.0.6.src/tools/llvm-pdbutil/llvm-pdbutil.cpp:818: uninit_use_in_call: Using uninitialized value "DefaultInfoStream.Guid" when calling "value_or".
#  816|     pdb::yaml::PdbTpiStream DefaultIpiStream;
#  817|   
#  818|->   const auto &Info = YamlObj.PdbStream.value_or(DefaultInfoStream);
#  819|   
#  820|     auto &InfoBuilder = Builder.getInfoBuilder();

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/tools/llvm-profdata/llvm-profdata.cpp:3112: extract: Calling "c_str" which extracts wrapped state from local "Invocation".
llvm-17.0.6.src/tools/llvm-profdata/llvm-profdata.cpp:3112: escape: The internal representation of local "Invocation" escapes into "argv[1]", but is destroyed when it exits scope.
# 3110|       if (func) {
# 3111|         std::string Invocation(ProgName.str() + " " + argv[1]);
# 3112|->       argv[1] = Invocation.c_str();
# 3113|         return func(argc - 1, argv + 1);
# 3114|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-profgen/ProfiledBinary.cpp:865: var_decl: Declaring variable "CallStack".
llvm-17.0.6.src/tools/llvm-profgen/ProfiledBinary.cpp:888: uninit_use: Using uninitialized value "CallStack". Field "CallStack.InlineElts" is uninitialized.
#  886|     }
#  887|   
#  888|->   return CallStack;
#  889|   }
#  890|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-rc/llvm-rc.cpp:378: var_decl: Declaring variable "Opts".
llvm-17.0.6.src/tools/llvm-rc/llvm-rc.cpp:531: uninit_use: Using uninitialized value "Opts". Field "Opts.Params.NoInclude" is uninitialized.
#  529|     Opts.BeVerbose = InputArgs.hasArg(WINDRES_verbose);
#  530|   
#  531|->   return Opts;
#  532|   }
#  533|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:5165: var_decl: Declaring variable "Properties".
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:5188: uninit_use: Using uninitialized value "Properties". Field "Properties.InlineElts" is uninitialized.
# 5186|       Properties.push_back("<corrupted GNU_PROPERTY_TYPE_0>");
# 5187|   
# 5188|->   return Properties;
# 5189|   }
# 5190|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6287: var_decl: Declaring variable "SymbolIndexes".
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6308: uninit_use: Using uninitialized value "SymbolIndexes". Field "SymbolIndexes.InlineElts" is uninitialized.
# 6306|               reportUniqueWarning("unable to get address of symbol '" + Name +
# 6307|                                   "': " + toString(SymAddrOrErr.takeError()));
# 6308|->             return SymbolIndexes;
# 6309|             }
# 6310|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6287: var_decl: Declaring variable "SymbolIndexes".
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6322: uninit_use: Using uninitialized value "SymbolIndexes". Field "SymbolIndexes.InlineElts" is uninitialized.
# 6320|     auto Symbols = this->AddressToIndexMap->find(SymValue);
# 6321|     if (Symbols == this->AddressToIndexMap->end())
# 6322|->     return SymbolIndexes;
# 6323|   
# 6324|     for (uint32_t Index : Symbols->second) {
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6322: note: trimmed 1 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6287: var_decl: Declaring variable "SymbolIndexes".
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6340: uninit_use: Using uninitialized value "SymbolIndexes". Field "SymbolIndexes.InlineElts" is uninitialized.
# 6338|           reportUniqueWarning("unable to get section of symbol '" + Name +
# 6339|                               "': " + toString(SecOrErr.takeError()));
# 6340|->         return SymbolIndexes;
# 6341|         }
# 6342|       }
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6340: note: trimmed 1 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6287: var_decl: Declaring variable "SymbolIndexes".
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6347: uninit_use: Using uninitialized value "SymbolIndexes". Field "SymbolIndexes.InlineElts" is uninitialized.
# 6345|     }
# 6346|   
# 6347|->   return SymbolIndexes;
# 6348|   }
# 6349|   
llvm-17.0.6.src/tools/llvm-readobj/ELFDumper.cpp:6347: note: trimmed 1 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-stress/llvm-stress.cpp:438: var_decl: Declaring variable "RandomFloat".
llvm-17.0.6.src/tools/llvm-stress/llvm-stress.cpp:441: uninit_use_in_call: Using uninitialized value "RandomFloat.U" when calling "~APFloat".
#  439|   
#  440|         if (getRandom() & 1)
#  441|->         return PT->push_back(ConstantFP::getZero(Ty));
#  442|         return PT->push_back(ConstantFP::get(Ty->getContext(), RandomFloat));
#  443|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-stress/llvm-stress.cpp:438: var_decl: Declaring variable "RandomFloat".
llvm-17.0.6.src/tools/llvm-stress/llvm-stress.cpp:442: uninit_use_in_call: Using uninitialized value "RandomFloat.U" when calling "get".
#  440|         if (getRandom() & 1)
#  441|           return PT->push_back(ConstantFP::getZero(Ty));
#  442|->       return PT->push_back(ConstantFP::get(Ty->getContext(), RandomFloat));
#  443|       }
#  444|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-tapi-diff/DiffEngine.cpp:287: var_decl: Declaring variable "Diff".
llvm-17.0.6.src/tools/llvm-tapi-diff/DiffEngine.cpp:293: uninit_use: Using uninitialized value "Diff". Field "Diff.Kind" is uninitialized.
#  291|       Diff.Values.push_back(std::make_unique<T>(RHS));
#  292|     }
#  293|->   return Diff;
#  294|   }
#  295|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-xray/xray-converter.cpp:190: var_decl: Declaring variable "Siblings".
llvm-17.0.6.src/tools/llvm-xray/xray-converter.cpp:201: uninit_use: Using uninitialized value "Siblings". Field "Siblings.InlineElts" is uninitialized.
#  199|           }
#  200|       }
#  201|->     return Siblings;
#  202|     }
#  203|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-xray/xray-converter.cpp:190: var_decl: Declaring variable "Siblings".
llvm-17.0.6.src/tools/llvm-xray/xray-converter.cpp:209: uninit_use: Using uninitialized value "Siblings". Field "Siblings.InlineElts" is uninitialized.
#  207|           Siblings.push_back(node_iter);
#  208|   
#  209|->   return Siblings;
#  210|   }
#  211|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/llvm-xray/xray-stacks.cpp:523: var_decl: Declaring variable "MergedByThreadRoots".
llvm-17.0.6.src/tools/llvm-xray/xray-stacks.cpp:540: uninit_use: Using uninitialized value "MergedByThreadRoots". Field "MergedByThreadRoots.InlineElts" is uninitialized.
#  538|         }
#  539|       }
#  540|->     return MergedByThreadRoots;
#  541|     }
#  542|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:225: var_decl: Declaring variable "YAMLFD" without initializer.
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:231: uninit_use_in_call: Using uninitialized value "YAMLFD". Field "YAMLFD.unused" is uninitialized when calling "operator =".
#  229|     YAMLFD.PointerToNextFunction = ObjFD->PointerToNextFunction;
#  230|   
#  231|->   Sym->FunctionDefinition = YAMLFD;
#  232|   }
#  233|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:237: var_decl: Declaring variable "YAMLAAS" without initializer.
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:241: uninit_use_in_call: Using uninitialized value "YAMLAAS". Field "YAMLAAS.unused1" is uninitialized when calling "operator =".
#  239|     YAMLAAS.PointerToNextFunction = ObjBES->PointerToNextFunction;
#  240|   
#  241|->   Sym->bfAndefSymbol = YAMLAAS;
#  242|   }
#  243|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:246: var_decl: Declaring variable "YAMLWE" without initializer.
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:250: uninit_use_in_call: Using uninitialized value "YAMLWE". Field "YAMLWE.unused" is uninitialized when calling "operator =".
#  248|     YAMLWE.Characteristics = ObjWE->Characteristics;
#  249|   
#  250|->   Sym->WeakExternal = YAMLWE;
#  251|   }
#  252|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:257: var_decl: Declaring variable "YAMLASD" without initializer.
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:266: uninit_use_in_call: Using uninitialized value "YAMLASD". Field "YAMLASD.unused" is uninitialized when calling "operator =".
#  264|     YAMLASD.Selection = ObjSD->Selection;
#  265|   
#  266|->   Sym->SectionDefinition = YAMLASD;
#  267|   }
#  268|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:272: var_decl: Declaring variable "YAMLCLRToken" without initializer.
llvm-17.0.6.src/tools/obj2yaml/coff2yaml.cpp:276: uninit_use_in_call: Using uninitialized value "YAMLCLRToken". Field "YAMLCLRToken.unused1" is uninitialized when calling "operator =".
#  274|     YAMLCLRToken.SymbolTableIndex = ObjCLRToken->SymbolTableIndex;
#  275|   
#  276|->   Sym->CLRToken = YAMLCLRToken;
#  277|   }
#  278|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/dwarf2yaml.cpp:40: var_decl: Declaring variable "AttAbrv" without initializer.
llvm-17.0.6.src/tools/obj2yaml/dwarf2yaml.cpp:45: uninit_use_in_call: Using uninitialized value "AttAbrv". Field "AttAbrv.Value" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   43|             if (AttAbrv.Form == dwarf::DW_FORM_implicit_const)
#   44|               AttAbrv.Value = Attribute.getImplicitConstValue();
#   45|->           Abbrv.Attributes.push_back(AttAbrv);
#   46|           }
#   47|           Y.DebugAbbrev.back().Table.push_back(Abbrv);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/wasm2yaml.cpp:128: var_decl: Declaring variable "Info".
llvm-17.0.6.src/tools/obj2yaml/wasm2yaml.cpp:147: uninit_use_in_call: Using uninitialized value "Info". Field "Info" is uninitialized when calling "emplace_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  145|           break;
#  146|         }
#  147|->       LinkingSec->SymbolTable.emplace_back(Info);
#  148|       }
#  149|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/obj2yaml/wasm2yaml.cpp:234: var_decl: Declaring variable "Im".
llvm-17.0.6.src/tools/obj2yaml/wasm2yaml.cpp:258: uninit_use_in_call: Using uninitialized value "Im". Field "Im" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  256|             break;
#  257|           }
#  258|->         ImportSec->Imports.push_back(Im);
#  259|         }
#  260|         S = std::move(ImportSec);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/tools/sancov/sancov.cpp:576: var_decl: Declaring variable "Point".
llvm-17.0.6.src/tools/sancov/sancov.cpp:597: uninit_use_in_call: Using uninitialized value "Point". Field "Point.Locs.InlineElts" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  595|       }
#  596|   
#  597|->     Result.push_back(Point);
#  598|     }
#  599|   
llvm-17.0.6.src/tools/sancov/sancov.cpp:597: note: trimmed 3 message(s) with length over 512

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:779: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.75f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:779: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  777|   
#  778|     // Simple exact fraction
#  779|->   Val = APFloat(0.75f);
#  780|     CheckFloatToFixedConversion(Val, getSAccumSema(), 3ULL << 5);
#  781|     CheckFloatToFixedConversion(Val, getAccumSema(),  3ULL << 13);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:802: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0.75f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:802: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  800|   
#  801|     // Simple negative exact fraction
#  802|->   Val = APFloat(-0.75f);
#  803|     CheckFloatToFixedConversion(Val, getSAccumSema(), -3ULL << 5);
#  804|     CheckFloatToFixedConversion(Val, getAccumSema(),  -3ULL << 13);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:825: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:825: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  823|   
#  824|     // Highly precise fraction
#  825|->   Val = APFloat(0.999999940395355224609375f);
#  826|     CheckFloatToFixedConversion(Val, getSAccumSema(), 0x7FULL);
#  827|     CheckFloatToFixedConversion(Val, getAccumSema(),  0x7FFFULL);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:848: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(17.9961f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:848: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  846|   
#  847|     // Integral and fraction
#  848|->   Val = APFloat(17.99609375f);
#  849|     CheckFloatToFixedConversion(Val, getSAccumSema(), 0x11FFULL >> 1);
#  850|     CheckFloatToFixedConversion(Val, getAccumSema(),  0x11FFULL << 7);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:871: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-17.9961f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:871: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  869|   
#  870|     // Negative integral and fraction
#  871|->   Val = APFloat(-17.99609375f);
#  872|     CheckFloatToFixedConversion(Val, getSAccumSema(), -0x11FELL >> 1);
#  873|     CheckFloatToFixedConversion(Val, getAccumSema(),  -0x11FFULL << 7);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:894: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1e+38f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:894: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  892|   
#  893|     // Very large value
#  894|->   Val = APFloat(1.0e38f);
#  895|     CheckFloatToFixedConversion(Val, getSAccumSema(), MaxSat);
#  896|     CheckFloatToFixedConversion(Val, getAccumSema(),  MaxSat);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:917: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1e-38f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:917: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  915|   
#  916|     // Very small value
#  917|->   Val = APFloat(1.0e-38f);
#  918|     CheckFloatToFixedConversion(Val, getSAccumSema(), 0);
#  919|     CheckFloatToFixedConversion(Val, getAccumSema(),  0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:940: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.999512f)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:940: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  938|   
#  939|     // Half conversion
#  940|->   Val = APFloat(0.99951171875f);
#  941|     bool Ignored;
#  942|     Val.convert(APFloat::IEEEhalf(), APFloat::rmNearestTiesToEven, &Ignored);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:965: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.124996)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:965: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  963|     CheckFloatToFixedConversion(Val, getS32Pos2(), 0);
#  964|   
#  965|->   Val = APFloat(0.124996185302734375);
#  966|     CheckFloatToFixedConversion(Val, getU8Neg10(), 0x7f);
#  967|     CheckFloatToFixedConversion(Val, getU8Pos4(), 0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:971: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0.124996)".
llvm-17.0.6.src/unittests/ADT/APFixedPointTest.cpp:971: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  969|     CheckFloatToFixedConversion(Val, getS32Pos2(), 0);
#  970|   
#  971|->   Val = APFloat(-0.124996185302734375);
#  972|     CheckFloatToFixedConversion(Val, getU8Neg10(), MinSat);
#  973|     CheckFloatToFixedConversion(Val, getU8Pos4(), 0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:26: var_decl: Declaring variable "F".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:27: uninit_use_in_call: Using uninitialized value "F.U" when calling "convertFromString".
#   25|   static std::string convertToErrorFromString(StringRef Str) {
#   26|     llvm::APFloat F(0.0);
#   27|->   auto StatusOrErr =
#   28|         F.convertFromString(Str, llvm::APFloat::rmNearestTiesToEven);
#   29|     EXPECT_TRUE(!StatusOrErr);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:34: var_decl: Declaring variable "F".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:35: uninit_use_in_call: Using uninitialized value "F.U" when calling "convertFromString".
#   33|   static double convertToDoubleFromString(StringRef Str) {
#   34|     llvm::APFloat F(0.0);
#   35|->   auto StatusOrErr =
#   36|         F.convertFromString(Str, llvm::APFloat::rmNearestTiesToEven);
#   37|     EXPECT_FALSE(!StatusOrErr);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:45: var_decl: Declaring variable "F".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:46: uninit_use_in_call: Using uninitialized value "F.U" when calling "toString".
#   44|     llvm::SmallVector<char, 100> Buffer;
#   45|     llvm::APFloat F(d);
#   46|->   F.toString(Buffer, Prec, Pad, Tr);
#   47|     return std::string(Buffer.data(), Buffer.size());
#   48|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:483: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:486: uninit_use_in_call: Using uninitialized value "f1.U" when calling "fusedMultiplyAdd".
#  484|       APFloat f2(-14.5f);
#  485|       APFloat f3(225.0f);
#  486|->     f1.fusedMultiplyAdd(f2, f3, APFloat::rmNearestTiesToEven);
#  487|       EXPECT_EQ(14.75f, f1.convertToFloat());
#  488|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:492: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:494: uninit_use_in_call: Using uninitialized value "f1.U" when calling "divide".
#  492|       APFloat f1((float)1.17549435e-38F);
#  493|       APFloat f2((float)1.17549435e-38F);
#  494|->     f1.divide(Val2, rdmd);
#  495|       f2.divide(Val2, rdmd);
#  496|       APFloat f3(12.0f);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:493: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:495: uninit_use_in_call: Using uninitialized value "f2.U" when calling "divide".
#  493|       APFloat f2((float)1.17549435e-38F);
#  494|       f1.divide(Val2, rdmd);
#  495|->     f2.divide(Val2, rdmd);
#  496|       APFloat f3(12.0f);
#  497|       f1.fusedMultiplyAdd(f2, f3, APFloat::rmNearestTiesToEven);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:504: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:507: uninit_use_in_call: Using uninitialized value "f1.U" when calling "fusedMultiplyAdd".
#  505|       APFloat f2(-1.0);
#  506|       APFloat f3(1.0);
#  507|->     f1.fusedMultiplyAdd(f2, f3, APFloat::rmNearestTiesToEven);
#  508|       EXPECT_TRUE(!f1.isNegative() && f1.isZero());
#  509|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:515: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:518: uninit_use_in_call: Using uninitialized value "f1.U" when calling "fusedMultiplyAdd".
#  516|       APFloat f2(-1.0);
#  517|       APFloat f3(1.0);
#  518|->     f1.fusedMultiplyAdd(f2, f3, APFloat::rmTowardNegative);
#  519|       EXPECT_TRUE(f1.isNegative() && f1.isZero());
#  520|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:525: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:528: uninit_use_in_call: Using uninitialized value "f1.U" when calling "fusedMultiplyAdd".
#  526|       APFloat f2(-0.0);
#  527|       APFloat f3(-0.0);
#  528|->     f1.fusedMultiplyAdd(f2, f3, APFloat::rmNearestTiesToEven);
#  529|       EXPECT_TRUE(f1.isNegative() && f1.isZero());
#  530|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:544: var_decl: Declaring variable "M2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:552: uninit_use_in_call: Using uninitialized value "M2.U" when calling "~APFloat".
#  550|       EXPECT_FALSE(losesInfo);
#  551|       EXPECT_EQ(4.0f, M1.convertToFloat());
#  552|->   }
#  553|   
#  554|     // Regression test that failed an assertion.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:556: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:559: uninit_use_in_call: Using uninitialized value "f1.U" when calling "fusedMultiplyAdd".
#  557|       APFloat f2(2.0f);
#  558|       APFloat f3(8.85242279E-41f);
#  559|->     f1.fusedMultiplyAdd(f2, f3, APFloat::rmNearestTiesToEven);
#  560|       EXPECT_EQ(-8.85242279E-41f, f1.convertToFloat());
#  561|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:573: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:577: uninit_use_in_call: Using uninitialized value "f1.U" when calling "minnum".
#  575|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  576|   
#  577|->   EXPECT_EQ(1.0, minnum(f1, f2).convertToDouble());
#  578|     EXPECT_EQ(1.0, minnum(f2, f1).convertToDouble());
#  579|     EXPECT_EQ(1.0, minnum(f1, nan).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:574: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:577: uninit_use_in_call: Using uninitialized value "f2.U" when calling "minnum".
#  575|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  576|   
#  577|->   EXPECT_EQ(1.0, minnum(f1, f2).convertToDouble());
#  578|     EXPECT_EQ(1.0, minnum(f2, f1).convertToDouble());
#  579|     EXPECT_EQ(1.0, minnum(f1, nan).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:584: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:588: uninit_use_in_call: Using uninitialized value "f1.U" when calling "maxnum".
#  586|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  587|   
#  588|->   EXPECT_EQ(2.0, maxnum(f1, f2).convertToDouble());
#  589|     EXPECT_EQ(2.0, maxnum(f2, f1).convertToDouble());
#  590|     EXPECT_EQ(1.0, maxnum(f1, nan).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:585: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:588: uninit_use_in_call: Using uninitialized value "f2.U" when calling "maxnum".
#  586|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  587|   
#  588|->   EXPECT_EQ(2.0, maxnum(f1, f2).convertToDouble());
#  589|     EXPECT_EQ(2.0, maxnum(f2, f1).convertToDouble());
#  590|     EXPECT_EQ(1.0, maxnum(f1, nan).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:595: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:601: uninit_use_in_call: Using uninitialized value "f1.U" when calling "minimum".
#  599|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  600|   
#  601|->   EXPECT_EQ(1.0, minimum(f1, f2).convertToDouble());
#  602|     EXPECT_EQ(1.0, minimum(f2, f1).convertToDouble());
#  603|     EXPECT_EQ(-0.0, minimum(zp, zn).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:596: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:601: uninit_use_in_call: Using uninitialized value "f2.U" when calling "minimum".
#  599|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  600|   
#  601|->   EXPECT_EQ(1.0, minimum(f1, f2).convertToDouble());
#  602|     EXPECT_EQ(1.0, minimum(f2, f1).convertToDouble());
#  603|     EXPECT_EQ(-0.0, minimum(zp, zn).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:596: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:602: uninit_use_in_call: Using uninitialized value "f2.U" when calling "minimum".
#  600|   
#  601|     EXPECT_EQ(1.0, minimum(f1, f2).convertToDouble());
#  602|->   EXPECT_EQ(1.0, minimum(f2, f1).convertToDouble());
#  603|     EXPECT_EQ(-0.0, minimum(zp, zn).convertToDouble());
#  604|     EXPECT_EQ(-0.0, minimum(zn, zp).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:598: var_decl: Declaring variable "zn".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:603: uninit_use_in_call: Using uninitialized value "zn.U" when calling "minimum".
#  601|     EXPECT_EQ(1.0, minimum(f1, f2).convertToDouble());
#  602|     EXPECT_EQ(1.0, minimum(f2, f1).convertToDouble());
#  603|->   EXPECT_EQ(-0.0, minimum(zp, zn).convertToDouble());
#  604|     EXPECT_EQ(-0.0, minimum(zn, zp).convertToDouble());
#  605|     EXPECT_TRUE(std::isnan(minimum(f1, nan).convertToDouble()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:597: var_decl: Declaring variable "zp".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:603: uninit_use_in_call: Using uninitialized value "zp.U" when calling "minimum".
#  601|     EXPECT_EQ(1.0, minimum(f1, f2).convertToDouble());
#  602|     EXPECT_EQ(1.0, minimum(f2, f1).convertToDouble());
#  603|->   EXPECT_EQ(-0.0, minimum(zp, zn).convertToDouble());
#  604|     EXPECT_EQ(-0.0, minimum(zn, zp).convertToDouble());
#  605|     EXPECT_TRUE(std::isnan(minimum(f1, nan).convertToDouble()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:598: var_decl: Declaring variable "zn".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:604: uninit_use_in_call: Using uninitialized value "zn.U" when calling "minimum".
#  602|     EXPECT_EQ(1.0, minimum(f2, f1).convertToDouble());
#  603|     EXPECT_EQ(-0.0, minimum(zp, zn).convertToDouble());
#  604|->   EXPECT_EQ(-0.0, minimum(zn, zp).convertToDouble());
#  605|     EXPECT_TRUE(std::isnan(minimum(f1, nan).convertToDouble()));
#  606|     EXPECT_TRUE(std::isnan(minimum(nan, f1).convertToDouble()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:610: var_decl: Declaring variable "f1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:616: uninit_use_in_call: Using uninitialized value "f1.U" when calling "maximum".
#  614|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  615|   
#  616|->   EXPECT_EQ(2.0, maximum(f1, f2).convertToDouble());
#  617|     EXPECT_EQ(2.0, maximum(f2, f1).convertToDouble());
#  618|     EXPECT_EQ(0.0, maximum(zp, zn).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:611: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:616: uninit_use_in_call: Using uninitialized value "f2.U" when calling "maximum".
#  614|     APFloat nan = APFloat::getNaN(APFloat::IEEEdouble());
#  615|   
#  616|->   EXPECT_EQ(2.0, maximum(f1, f2).convertToDouble());
#  617|     EXPECT_EQ(2.0, maximum(f2, f1).convertToDouble());
#  618|     EXPECT_EQ(0.0, maximum(zp, zn).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:611: var_decl: Declaring variable "f2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:617: uninit_use_in_call: Using uninitialized value "f2.U" when calling "maximum".
#  615|   
#  616|     EXPECT_EQ(2.0, maximum(f1, f2).convertToDouble());
#  617|->   EXPECT_EQ(2.0, maximum(f2, f1).convertToDouble());
#  618|     EXPECT_EQ(0.0, maximum(zp, zn).convertToDouble());
#  619|     EXPECT_EQ(0.0, maximum(zn, zp).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:613: var_decl: Declaring variable "zn".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:618: uninit_use_in_call: Using uninitialized value "zn.U" when calling "maximum".
#  616|     EXPECT_EQ(2.0, maximum(f1, f2).convertToDouble());
#  617|     EXPECT_EQ(2.0, maximum(f2, f1).convertToDouble());
#  618|->   EXPECT_EQ(0.0, maximum(zp, zn).convertToDouble());
#  619|     EXPECT_EQ(0.0, maximum(zn, zp).convertToDouble());
#  620|     EXPECT_TRUE(std::isnan(maximum(f1, nan).convertToDouble()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:612: var_decl: Declaring variable "zp".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:618: uninit_use_in_call: Using uninitialized value "zp.U" when calling "maximum".
#  616|     EXPECT_EQ(2.0, maximum(f1, f2).convertToDouble());
#  617|     EXPECT_EQ(2.0, maximum(f2, f1).convertToDouble());
#  618|->   EXPECT_EQ(0.0, maximum(zp, zn).convertToDouble());
#  619|     EXPECT_EQ(0.0, maximum(zn, zp).convertToDouble());
#  620|     EXPECT_TRUE(std::isnan(maximum(f1, nan).convertToDouble()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:613: var_decl: Declaring variable "zn".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:619: uninit_use_in_call: Using uninitialized value "zn.U" when calling "maximum".
#  617|     EXPECT_EQ(2.0, maximum(f2, f1).convertToDouble());
#  618|     EXPECT_EQ(0.0, maximum(zp, zn).convertToDouble());
#  619|->   EXPECT_EQ(0.0, maximum(zn, zp).convertToDouble());
#  620|     EXPECT_TRUE(std::isnan(maximum(f1, nan).convertToDouble()));
#  621|     EXPECT_TRUE(std::isnan(maximum(nan, f1).convertToDouble()));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:631: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEsingle(), 0UL)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:631: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  629|       const char *MinNormalStr = "1.17549435082228750797e-38";
#  630|       EXPECT_FALSE(APFloat(APFloat::IEEEsingle(), MinNormalStr).isDenormal());
#  631|->     EXPECT_FALSE(APFloat(APFloat::IEEEsingle(), 0).isDenormal());
#  632|   
#  633|       APFloat Val2(APFloat::IEEEsingle(), 2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:652: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEdouble(), 0UL)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:652: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  650|       const char *MinNormalStr = "2.22507385850720138309e-308";
#  651|       EXPECT_FALSE(APFloat(APFloat::IEEEdouble(), MinNormalStr).isDenormal());
#  652|->     EXPECT_FALSE(APFloat(APFloat::IEEEdouble(), 0).isDenormal());
#  653|   
#  654|       APFloat Val2(APFloat::IEEEdouble(), 2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:665: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::x87DoubleExtended(), 0UL)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:665: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  663|       const char *MinNormalStr = "3.36210314311209350626e-4932";
#  664|       EXPECT_FALSE(APFloat(APFloat::x87DoubleExtended(), MinNormalStr).isDenormal());
#  665|->     EXPECT_FALSE(APFloat(APFloat::x87DoubleExtended(), 0).isDenormal());
#  666|   
#  667|       APFloat Val2(APFloat::x87DoubleExtended(), 2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:678: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::IEEEquad(), 0UL)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:678: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  676|       const char *MinNormalStr = "3.36210314311209350626267781732175260e-4932";
#  677|       EXPECT_FALSE(APFloat(APFloat::IEEEquad(), MinNormalStr).isDenormal());
#  678|->     EXPECT_FALSE(APFloat(APFloat::IEEEquad(), 0).isDenormal());
#  679|   
#  680|       APFloat Val2(APFloat::IEEEquad(), 2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:691: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::FloatTF32(), 0UL)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:691: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  689|       const char *MinNormalStr = "1.17549435082228750797e-38";
#  690|       EXPECT_FALSE(APFloat(APFloat::FloatTF32(), MinNormalStr).isDenormal());
#  691|->     EXPECT_FALSE(APFloat(APFloat::FloatTF32(), 0).isDenormal());
#  692|   
#  693|       APFloat Val2(APFloat::FloatTF32(), 2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:762: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:762: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  760|   
#  761|   TEST(APFloatTest, Zero) {
#  762|->   EXPECT_EQ(0.0f,  APFloat(0.0f).convertToFloat());
#  763|     EXPECT_EQ(-0.0f, APFloat(-0.0f).convertToFloat());
#  764|     EXPECT_TRUE(APFloat(-0.0f).isNegative());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:763: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:763: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  761|   TEST(APFloatTest, Zero) {
#  762|     EXPECT_EQ(0.0f,  APFloat(0.0f).convertToFloat());
#  763|->   EXPECT_EQ(-0.0f, APFloat(-0.0f).convertToFloat());
#  764|     EXPECT_TRUE(APFloat(-0.0f).isNegative());
#  765|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:764: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:764: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  762|     EXPECT_EQ(0.0f,  APFloat(0.0f).convertToFloat());
#  763|     EXPECT_EQ(-0.0f, APFloat(-0.0f).convertToFloat());
#  764|->   EXPECT_TRUE(APFloat(-0.0f).isNegative());
#  765|   
#  766|     EXPECT_EQ(0.0,  APFloat(0.0).convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:766: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:766: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  764|     EXPECT_TRUE(APFloat(-0.0f).isNegative());
#  765|   
#  766|->   EXPECT_EQ(0.0,  APFloat(0.0).convertToDouble());
#  767|     EXPECT_EQ(-0.0, APFloat(-0.0).convertToDouble());
#  768|     EXPECT_TRUE(APFloat(-0.0).isNegative());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:767: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:767: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  765|   
#  766|     EXPECT_EQ(0.0,  APFloat(0.0).convertToDouble());
#  767|->   EXPECT_EQ(-0.0, APFloat(-0.0).convertToDouble());
#  768|     EXPECT_TRUE(APFloat(-0.0).isNegative());
#  769|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:768: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:768: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  766|     EXPECT_EQ(0.0,  APFloat(0.0).convertToDouble());
#  767|     EXPECT_EQ(-0.0, APFloat(-0.0).convertToDouble());
#  768|->   EXPECT_TRUE(APFloat(-0.0).isNegative());
#  769|   
#  770|     EXPECT_EQ(fcPosZero, APFloat(0.0).classify());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:770: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:770: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  768|     EXPECT_TRUE(APFloat(-0.0).isNegative());
#  769|   
#  770|->   EXPECT_EQ(fcPosZero, APFloat(0.0).classify());
#  771|     EXPECT_EQ(fcNegZero, APFloat(-0.0).classify());
#  772|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:771: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-0.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:771: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#  769|   
#  770|     EXPECT_EQ(fcPosZero, APFloat(0.0).classify());
#  771|->   EXPECT_EQ(fcNegZero, APFloat(-0.0).classify());
#  772|   }
#  773|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1101: var_decl: Declaring variable "F".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1102: uninit_use_in_call: Using uninitialized value "F.U" when calling "convertFromString".
# 1100|   
# 1101|               APFloat F(Sem);
# 1102|->             bool HasError = !F.convertFromString(
# 1103|                   TestStr, llvm::APFloat::rmNearestTiesToEven);
# 1104|               EXPECT_FALSE(HasError);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1269: var_decl: Declaring variable "UnnormalZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1270: uninit_use_in_call: Using uninitialized value "UnnormalZero.U" when calling "toString".
# 1268|       SmallString<64> Str;
# 1269|       APFloat UnnormalZero(APFloat::x87DoubleExtended(), APInt(80, {0, 1}));
# 1270|->     UnnormalZero.toString(Str);
# 1271|       ASSERT_EQ("NaN", Str);
# 1272|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1571: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(2.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1571: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1569|   
# 1570|     // Trivial operation.
# 1571|->   EXPECT_TRUE(APFloat(2.0).getExactInverse(&inv));
# 1572|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5)));
# 1573|     EXPECT_TRUE(APFloat(2.0f).getExactInverse(&inv));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1572: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.5)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1572: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1570|     // Trivial operation.
# 1571|     EXPECT_TRUE(APFloat(2.0).getExactInverse(&inv));
# 1572|->   EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5)));
# 1573|     EXPECT_TRUE(APFloat(2.0f).getExactInverse(&inv));
# 1574|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5f)));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1573: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(2f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1573: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1571|     EXPECT_TRUE(APFloat(2.0).getExactInverse(&inv));
# 1572|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5)));
# 1573|->   EXPECT_TRUE(APFloat(2.0f).getExactInverse(&inv));
# 1574|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5f)));
# 1575|     EXPECT_TRUE(APFloat(APFloat::IEEEquad(), "2.0").getExactInverse(&inv));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1574: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.5f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1574: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1572|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5)));
# 1573|     EXPECT_TRUE(APFloat(2.0f).getExactInverse(&inv));
# 1574|->   EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(0.5f)));
# 1575|     EXPECT_TRUE(APFloat(APFloat::IEEEquad(), "2.0").getExactInverse(&inv));
# 1576|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(APFloat::IEEEquad(), "0.5")));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1583: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1.17549e-38f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1583: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1581|   
# 1582|     // FLT_MIN
# 1583|->   EXPECT_TRUE(APFloat(1.17549435e-38f).getExactInverse(&inv));
# 1584|     EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(8.5070592e+37f)));
# 1585|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1584: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(8.50706e+37f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1584: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1582|     // FLT_MIN
# 1583|     EXPECT_TRUE(APFloat(1.17549435e-38f).getExactInverse(&inv));
# 1584|->   EXPECT_TRUE(inv.bitwiseIsEqual(APFloat(8.5070592e+37f)));
# 1585|   
# 1586|     // Large float, inverse is a denormal.

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1587: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1.70141e+38f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1587: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1585|   
# 1586|     // Large float, inverse is a denormal.
# 1587|->   EXPECT_FALSE(APFloat(1.7014118e38f).getExactInverse(nullptr));
# 1588|     // Zero
# 1589|     EXPECT_FALSE(APFloat(0.0).getExactInverse(nullptr));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1589: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(0.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1589: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1587|     EXPECT_FALSE(APFloat(1.7014118e38f).getExactInverse(nullptr));
# 1588|     // Zero
# 1589|->   EXPECT_FALSE(APFloat(0.0).getExactInverse(nullptr));
# 1590|     // Denormalized float
# 1591|     EXPECT_FALSE(APFloat(1.40129846e-45f).getExactInverse(nullptr));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1591: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1.4013e-45f)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1591: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1589|     EXPECT_FALSE(APFloat(0.0).getExactInverse(nullptr));
# 1590|     // Denormalized float
# 1591|->   EXPECT_FALSE(APFloat(1.40129846e-45f).getExactInverse(nullptr));
# 1592|   }
# 1593|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1595: var_decl: Declaring variable "T".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1597: uninit_use_in_call: Using uninitialized value "T.U" when calling "operator =".
# 1595|     APFloat T(-0.5), S(3.14), R(APFloat::getLargest(APFloat::IEEEdouble())), P(0.0);
# 1596|   
# 1597|->   P = T;
# 1598|     P.roundToIntegral(APFloat::rmTowardZero);
# 1599|     EXPECT_EQ(-0.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1595: var_decl: Declaring variable "S".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1610: uninit_use_in_call: Using uninitialized value "S.U" when calling "operator =".
# 1608|     EXPECT_EQ(-0.0, P.convertToDouble());
# 1609|   
# 1610|->   P = S;
# 1611|     P.roundToIntegral(APFloat::rmTowardZero);
# 1612|     EXPECT_EQ(3.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1716: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1e-100.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1716: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1714|     EXPECT_EQ(APFloat::opOK, St);
# 1715|   
# 1716|->   P = APFloat(1E-100);
# 1717|     St = P.roundToIntegral(APFloat::rmTowardNegative);
# 1718|     EXPECT_TRUE(P.isZero());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1722: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1e-100.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1722: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1720|     EXPECT_EQ(APFloat::opInexact, St);
# 1721|   
# 1722|->   P = APFloat(1E-100);
# 1723|     St = P.roundToIntegral(APFloat::rmTowardPositive);
# 1724|     EXPECT_EQ(1.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1728: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-1e-100.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1728: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1726|     EXPECT_EQ(APFloat::opInexact, St);
# 1727|   
# 1728|->   P = APFloat(-1E-100);
# 1729|     St = P.roundToIntegral(APFloat::rmTowardNegative);
# 1730|     EXPECT_TRUE(P.isNegative());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1734: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-1e-100.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1734: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1732|     EXPECT_EQ(APFloat::opInexact, St);
# 1733|   
# 1734|->   P = APFloat(-1E-100);
# 1735|     St = P.roundToIntegral(APFloat::rmTowardPositive);
# 1736|     EXPECT_TRUE(P.isZero());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1740: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(10.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1740: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1738|     EXPECT_EQ(APFloat::opInexact, St);
# 1739|   
# 1740|->   P = APFloat(10.0);
# 1741|     St = P.roundToIntegral(APFloat::rmTowardZero);
# 1742|     EXPECT_EQ(10.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1745: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(10.5)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1745: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1743|     EXPECT_EQ(APFloat::opOK, St);
# 1744|   
# 1745|->   P = APFloat(10.5);
# 1746|     St = P.roundToIntegral(APFloat::rmTowardZero);
# 1747|     EXPECT_EQ(10.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1750: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(10.5)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1750: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1748|     EXPECT_EQ(APFloat::opInexact, St);
# 1749|   
# 1750|->   P = APFloat(10.5);
# 1751|     St = P.roundToIntegral(APFloat::rmTowardPositive);
# 1752|     EXPECT_EQ(11.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1755: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(10.5)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1755: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1753|     EXPECT_EQ(APFloat::opInexact, St);
# 1754|   
# 1755|->   P = APFloat(10.5);
# 1756|     St = P.roundToIntegral(APFloat::rmTowardNegative);
# 1757|     EXPECT_EQ(10.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1760: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(10.5)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1760: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1758|     EXPECT_EQ(APFloat::opInexact, St);
# 1759|   
# 1760|->   P = APFloat(10.5);
# 1761|     St = P.roundToIntegral(APFloat::rmNearestTiesToAway);
# 1762|     EXPECT_EQ(11.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1765: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(10.5)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1765: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1763|     EXPECT_EQ(APFloat::opInexact, St);
# 1764|   
# 1765|->   P = APFloat(10.5);
# 1766|     St = P.roundToIntegral(APFloat::rmNearestTiesToEven);
# 1767|     EXPECT_EQ(10.0, P.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1772: var_decl: Declaring variable "T".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1773: uninit_use_in_call: Using uninitialized value "T.U" when calling "isInteger".
# 1771|   TEST(APFloatTest, isInteger) {
# 1772|     APFloat T(-0.0);
# 1773|->   EXPECT_TRUE(T.isInteger());
# 1774|     T = APFloat(3.14159);
# 1775|     EXPECT_FALSE(T.isInteger());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1774: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(3.14159)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:1774: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 1772|     APFloat T(-0.0);
# 1773|     EXPECT_TRUE(T.isInteger());
# 1774|->   T = APFloat(3.14159);
# 1775|     EXPECT_FALSE(T.isInteger());
# 1776|     T = APFloat::getNaN(APFloat::IEEEdouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2011: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-1.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2011: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2009|   
# 2010|   TEST(APFloatTest, copySign) {
# 2011|->   EXPECT_TRUE(APFloat(-42.0).bitwiseIsEqual(
# 2012|         APFloat::copySign(APFloat(42.0), APFloat(-1.0))));
# 2013|     EXPECT_TRUE(APFloat(42.0).bitwiseIsEqual(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2013: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-42.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2013: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2011|     EXPECT_TRUE(APFloat(-42.0).bitwiseIsEqual(
# 2012|         APFloat::copySign(APFloat(42.0), APFloat(-1.0))));
# 2013|->   EXPECT_TRUE(APFloat(42.0).bitwiseIsEqual(
# 2014|         APFloat::copySign(APFloat(-42.0), APFloat(1.0))));
# 2015|     EXPECT_TRUE(APFloat(-42.0).bitwiseIsEqual(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2015: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-1.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2015: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2013|     EXPECT_TRUE(APFloat(42.0).bitwiseIsEqual(
# 2014|         APFloat::copySign(APFloat(-42.0), APFloat(1.0))));
# 2015|->   EXPECT_TRUE(APFloat(-42.0).bitwiseIsEqual(
# 2016|         APFloat::copySign(APFloat(-42.0), APFloat(-1.0))));
# 2017|     EXPECT_TRUE(APFloat(42.0).bitwiseIsEqual(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2017: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2017: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2015|     EXPECT_TRUE(APFloat(-42.0).bitwiseIsEqual(
# 2016|         APFloat::copySign(APFloat(-42.0), APFloat(-1.0))));
# 2017|->   EXPECT_TRUE(APFloat(42.0).bitwiseIsEqual(
# 2018|         APFloat::copySign(APFloat(42.0), APFloat(1.0))));
# 2019|     // For floating-point formats with unsigned 0, copySign() to a zero is a noop

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2023: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(-1.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2023: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2021|          {APFloat::S_Float8E4M3FNUZ, APFloat::S_Float8E4M3B11FNUZ}) {
# 2022|       const llvm::fltSemantics &Sem = APFloat::EnumToSemantics(S);
# 2023|->     EXPECT_TRUE(APFloat::getZero(Sem).bitwiseIsEqual(
# 2024|           APFloat::copySign(APFloat::getZero(Sem), APFloat(-1.0))));
# 2025|       EXPECT_TRUE(APFloat::getNaN(Sem, true).bitwiseIsEqual(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2025: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(1.)".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:2025: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 2023|       EXPECT_TRUE(APFloat::getZero(Sem).bitwiseIsEqual(
# 2024|           APFloat::copySign(APFloat::getZero(Sem), APFloat(-1.0))));
# 2025|->     EXPECT_TRUE(APFloat::getNaN(Sem, true).bitwiseIsEqual(
# 2026|           APFloat::copySign(APFloat::getNaN(Sem, true), APFloat(1.0))));
# 2027|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3775: var_decl: Declaring variable "One".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3823: uninit_use_in_call: Using uninitialized value "One.U" when calling "frexp".
# 3821|   
# 3822|   
# 3823|->   Frac = frexp(One, Exp, RM);
# 3824|     EXPECT_EQ(1, Exp);
# 3825|     EXPECT_TRUE(APFloat(APFloat::IEEEdouble(), "0x1p-1").bitwiseIsEqual(Frac));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3776: var_decl: Declaring variable "MOne".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3827: uninit_use_in_call: Using uninitialized value "MOne.U" when calling "frexp".
# 3825|     EXPECT_TRUE(APFloat(APFloat::IEEEdouble(), "0x1p-1").bitwiseIsEqual(Frac));
# 3826|   
# 3827|->   Frac = frexp(MOne, Exp, RM);
# 3828|     EXPECT_EQ(1, Exp);
# 3829|     EXPECT_TRUE(APFloat(APFloat::IEEEdouble(), "-0x1p-1").bitwiseIsEqual(Frac));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3778: var_decl: Declaring variable "MTwo".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3894: uninit_use_in_call: Using uninitialized value "MTwo.U" when calling "~APFloat".
# 3892|     EXPECT_EQ(52, Exp);
# 3893|     EXPECT_TRUE(APFloat(APFloat::IEEEdouble(), "0x1.c60f120d9f87cp-1").bitwiseIsEqual(Frac));
# 3894|-> }
# 3895|   
# 3896|   TEST(APFloatTest, mod) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3777: var_decl: Declaring variable "Two".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:3894: uninit_use_in_call: Using uninitialized value "Two.U" when calling "~APFloat".
# 3892|     EXPECT_EQ(52, Exp);
# 3893|     EXPECT_TRUE(APFloat(APFloat::IEEEdouble(), "0x1.c60f120d9f87cp-1").bitwiseIsEqual(Frac));
# 3894|-> }
# 3895|   
# 3896|   TEST(APFloatTest, mod) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4456: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4458: uninit_use_in_call: Using uninitialized value "A1.U" when calling "add".
# 4456|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4457|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4458|->       A1.add(A2, RM);
# 4459|   
# 4460|         EXPECT_EQ(Expected, A1.getCategory())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4467: var_decl: Declaring variable "A2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4468: uninit_use_in_call: Using uninitialized value "A2.U" when calling "add".
# 4466|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4467|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4468|->       A2.add(A1, RM);
# 4469|   
# 4470|         EXPECT_EQ(Expected, A2.getCategory())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4520: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4522: uninit_use_in_call: Using uninitialized value "A1.U" when calling "add".
# 4520|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4521|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4522|->       A1.add(A2, RM);
# 4523|   
# 4524|         EXPECT_EQ(Expected[0], A1.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4535: var_decl: Declaring variable "A2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4536: uninit_use_in_call: Using uninitialized value "A2.U" when calling "add".
# 4534|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4535|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4536|->       A2.add(A1, RM);
# 4537|   
# 4538|         EXPECT_EQ(Expected[0], A2.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4569: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4571: uninit_use_in_call: Using uninitialized value "A1.U" when calling "subtract".
# 4569|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4570|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4571|->     A1.subtract(A2, RM);
# 4572|   
# 4573|       EXPECT_EQ(Expected[0], A1.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4624: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4626: uninit_use_in_call: Using uninitialized value "A1.U" when calling "multiply".
# 4624|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4625|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4626|->       A1.multiply(A2, RM);
# 4627|   
# 4628|         EXPECT_EQ(Expected, A1.getCategory())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4635: var_decl: Declaring variable "A2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4636: uninit_use_in_call: Using uninitialized value "A2.U" when calling "multiply".
# 4634|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4635|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4636|->       A2.multiply(A1, RM);
# 4637|   
# 4638|         EXPECT_EQ(Expected, A2.getCategory())

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4697: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4699: uninit_use_in_call: Using uninitialized value "A1.U" when calling "multiply".
# 4697|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4698|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4699|->       A1.multiply(A2, RM);
# 4700|   
# 4701|         EXPECT_EQ(Expected[0], A1.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4712: var_decl: Declaring variable "A2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4713: uninit_use_in_call: Using uninitialized value "A2.U" when calling "multiply".
# 4711|         APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4712|         APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4713|->       A2.multiply(A1, RM);
# 4714|   
# 4715|         EXPECT_EQ(Expected[0], A2.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4744: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4746: uninit_use_in_call: Using uninitialized value "A1.U" when calling "divide".
# 4744|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4745|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4746|->     A1.divide(A2, RM);
# 4747|   
# 4748|       EXPECT_EQ(Expected[0], A1.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4777: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4779: uninit_use_in_call: Using uninitialized value "A1.U" when calling "remainder".
# 4777|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4778|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4779|->     A1.remainder(A2);
# 4780|   
# 4781|       EXPECT_EQ(Expected[0], A1.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4812: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4814: uninit_use_in_call: Using uninitialized value "A1.U" when calling "mod".
# 4812|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4813|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4814|->     A1.mod(A2);
# 4815|   
# 4816|       EXPECT_EQ(Expected[0], A1.bitcastToAPInt().getRawData()[0])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4885: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4887: uninit_use_in_call: Using uninitialized value "A1.U" when calling "compare".
# 4885|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4886|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4887|->     EXPECT_EQ(Expected, A1.compare(A2))
# 4888|           << formatv("compare(({0:x} + {1:x}), ({2:x} + {3:x}))", Op1[0], Op1[1],
# 4889|                      Op2[0], Op2[1])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4917: var_decl: Declaring variable "A1".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4919: uninit_use_in_call: Using uninitialized value "A1.U" when calling "bitwiseIsEqual".
# 4917|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4918|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4919|->     EXPECT_EQ(Expected, A1.bitwiseIsEqual(A2))
# 4920|           << formatv("({0:x} + {1:x}) = ({2:x} + {3:x})", Op1[0], Op1[1], Op2[0],
# 4921|                      Op2[1])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4918: var_decl: Declaring variable "A2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4919: uninit_use_in_call: Using uninitialized value "A2.U" when calling "bitwiseIsEqual".
# 4917|       APFloat A1(APFloat::PPCDoubleDouble(), APInt(128, 2, Op1));
# 4918|       APFloat A2(APFloat::PPCDoubleDouble(), APInt(128, 2, Op2));
# 4919|->     EXPECT_EQ(Expected, A1.bitwiseIsEqual(A2))
# 4920|           << formatv("({0:x} + {1:x}) = ({2:x} + {3:x})", Op1[0], Op1[1], Op2[0],
# 4921|                      Op2[1])

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4930: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::PPCDoubleDouble(), llvm::APInt(128U, 2U, Data1))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4930: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 4928|     uint64_t Data2[] = {0x3ff0000000000001ull, 0};
# 4929|     // The hash values are *hopefully* different.
# 4930|->   EXPECT_NE(
# 4931|         hash_value(APFloat(APFloat::PPCDoubleDouble(), APInt(128, 2, Data1))),
# 4932|         hash_value(APFloat(APFloat::PPCDoubleDouble(), APInt(128, 2, Data2))));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4939: var_decl: Declaring variable "Float".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:4941: uninit_use_in_call: Using uninitialized value "Float.U" when calling "APFloat".
# 4939|     APFloat Float(APFloat::PPCDoubleDouble(), APInt(128, 2, Data));
# 4940|     {
# 4941|->     APFloat Actual =
# 4942|           APFloat::copySign(Float, APFloat(APFloat::IEEEdouble(), "1"));
# 4943|       EXPECT_EQ(0x400f000000000000ull, Actual.bitcastToAPInt().getRawData()[0]);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5029: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::PPCDoubleDouble(), llvm::APInt(128U, 2U, Data))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5029: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5027|           0x4010000000000000ull, 0x4008000000000000ull,
# 5028|       };
# 5029|->     EXPECT_TRUE(
# 5030|           APFloat(APFloat::PPCDoubleDouble(), APInt(128, 2, Data)).isDenormal());
# 5031|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5039: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::PPCDoubleDouble(), llvm::APInt(128U, 2U, Input))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5039: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5037|         0x4008000000000000ull, 0x3cb8000000000000ull,
# 5038|     };
# 5039|->   APFloat Result =
# 5040|         scalbn(APFloat(APFloat::PPCDoubleDouble(), APInt(128, 2, Input)), 1,
# 5041|                APFloat::rmNearestTiesToEven);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5054: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::PPCDoubleDouble(), llvm::APInt(128U, 2U, Input))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5054: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5052|     int Exp;
# 5053|     // 0.75 + 0.75 << 53
# 5054|->   APFloat Result =
# 5055|         frexp(APFloat(APFloat::PPCDoubleDouble(), APInt(128, 2, Input)), Exp,
# 5056|               APFloat::rmNearestTiesToEven);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5083: var_decl: Declaring variable "x".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5087: uninit_use_in_call: Using uninitialized value "x.U" when calling "APFloat".
# 5085|   
# 5086|           bool losesInfo;
# 5087|->         APFloat x16 = x;
# 5088|           x16.convert(APFloat::IEEEhalf(), APFloat::rmNearestTiesToEven,
# 5089|                       &losesInfo);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5084: var_decl: Declaring variable "y".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5091: uninit_use_in_call: Using uninitialized value "y.U" when calling "APFloat".
# 5089|                       &losesInfo);
# 5090|           EXPECT_FALSE(losesInfo);
# 5091|->         APFloat y16 = y;
# 5092|           y16.convert(APFloat::IEEEhalf(), APFloat::rmNearestTiesToEven,
# 5093|                       &losesInfo);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5368: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5368: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5366|     // nextUp on positive numbers
# 5367|     for (int i = 0; i < 127; i++) {
# 5368|->     test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5369|       expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i + 1));
# 5370|       EXPECT_EQ(test.next(false), APFloat::opOK);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5369: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i + 1, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5369: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5367|     for (int i = 0; i < 127; i++) {
# 5368|       test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5369|->     expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i + 1));
# 5370|       EXPECT_EQ(test.next(false), APFloat::opOK);
# 5371|       EXPECT_TRUE(test.bitwiseIsEqual(expected));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5382: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5382: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5380|     // nextUp on negative nonzero numbers
# 5381|     for (int i = 129; i < 255; i++) {
# 5382|->     test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5383|       expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i - 1));
# 5384|       EXPECT_EQ(test.next(false), APFloat::opOK);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5383: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i - 1, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5383: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5381|     for (int i = 129; i < 255; i++) {
# 5382|       test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5383|->     expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i - 1));
# 5384|       EXPECT_EQ(test.next(false), APFloat::opOK);
# 5385|       EXPECT_TRUE(test.bitwiseIsEqual(expected));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5396: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5396: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5394|     // nextDown on positive nonzero finite numbers
# 5395|     for (int i = 1; i < 127; i++) {
# 5396|->     test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5397|       expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i - 1));
# 5398|       EXPECT_EQ(test.next(true), APFloat::opOK);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5397: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i - 1, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5397: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5395|     for (int i = 1; i < 127; i++) {
# 5396|       test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5397|->     expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i - 1));
# 5398|       EXPECT_EQ(test.next(true), APFloat::opOK);
# 5399|       EXPECT_TRUE(test.bitwiseIsEqual(expected));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5410: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5410: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5408|     // nextDown on negative finite numbers
# 5409|     for (int i = 128; i < 255; i++) {
# 5410|->     test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5411|       expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i + 1));
# 5412|       EXPECT_EQ(test.next(true), APFloat::opOK);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5411: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(llvm::APFloatBase::Float8E4M3FN(), llvm::APInt(8U, i + 1, false))".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5411: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
# 5409|     for (int i = 128; i < 255; i++) {
# 5410|       test = APFloat(APFloat::Float8E4M3FN(), APInt(8, i));
# 5411|->     expected = APFloat(APFloat::Float8E4M3FN(), APInt(8, i + 1));
# 5412|       EXPECT_EQ(test.next(true), APFloat::opOK);
# 5413|       EXPECT_TRUE(test.bitwiseIsEqual(expected));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5426: var_decl: Declaring variable "test".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5431: uninit_use_in_call: Using uninitialized value "test.U" when calling "isLargest".
# 5429|       // isLargest
# 5430|       if (i == 126 || i == 254) {
# 5431|->       EXPECT_TRUE(test.isLargest());
# 5432|         EXPECT_EQ(abs(test).convertToDouble(), 448.);
# 5433|       } else {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5426: var_decl: Declaring variable "test".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5434: uninit_use_in_call: Using uninitialized value "test.U" when calling "isLargest".
# 5432|         EXPECT_EQ(abs(test).convertToDouble(), 448.);
# 5433|       } else {
# 5434|->       EXPECT_FALSE(test.isLargest());
# 5435|       }
# 5436|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5676: var_decl: Declaring variable "test".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5680: uninit_use_in_call: Using uninitialized value "test.U" when calling "isLargest".
# 5678|         // isLargest
# 5679|         if (i == 127 || i == 255) {
# 5680|->         EXPECT_TRUE(test.isLargest());
# 5681|           EXPECT_EQ(abs(test).convertToDouble(), testInfo.largest);
# 5682|         } else {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5676: var_decl: Declaring variable "test".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5683: uninit_use_in_call: Using uninitialized value "test.U" when calling "isLargest".
# 5681|           EXPECT_EQ(abs(test).convertToDouble(), testInfo.largest);
# 5682|         } else {
# 5683|->         EXPECT_FALSE(test.isLargest());
# 5684|         }
# 5685|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5973: var_decl: Declaring variable "test".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5975: uninit_use_in_call: Using uninitialized value "test.U" when calling "toString".
# 5973|         APFloat test(APFloat::EnumToSemantics(S), APInt(8, i));
# 5974|         llvm::SmallString<128> str;
# 5975|->       test.toString(str);
# 5976|   
# 5977|         if (test.isNaN()) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5996: var_decl: Declaring variable "test".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:5997: uninit_use_in_call: Using uninitialized value "test.U" when calling "bitcastToAPInt".
# 5995|         APInt bits_in = APInt(8, i);
# 5996|         APFloat test(APFloat::EnumToSemantics(S), bits_in);
# 5997|->       APInt bits_out = test.bitcastToAPInt();
# 5998|         EXPECT_EQ(bits_in, bits_out);
# 5999|       }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6016: var_decl: Declaring variable "test2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6018: uninit_use_in_call: Using uninitialized value "test2.U" when calling "isNaN".
# 6016|           APFloat test2 = APFloat(Sem, bits);
# 6017|           if (test.isNaN()) {
# 6018|->           EXPECT_TRUE(test2.isNaN());
# 6019|           } else {
# 6020|             EXPECT_TRUE(test.bitwiseIsEqual(test2));

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6016: var_decl: Declaring variable "test2".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6020: uninit_use_in_call: Using uninitialized value "test2.U" when calling "bitwiseIsEqual".
# 6018|             EXPECT_TRUE(test2.isNaN());
# 6019|           } else {
# 6020|->           EXPECT_TRUE(test.bitwiseIsEqual(test2));
# 6021|           }
# 6022|         }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6028: var_decl: Declaring variable "DPosZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6029: uninit_use_in_call: Using uninitialized value "DPosZero.U" when calling "convertToDouble".
# 6027|   TEST(APFloatTest, IEEEdoubleToDouble) {
# 6028|     APFloat DPosZero(0.0);
# 6029|->   APFloat DPosZeroToDouble(DPosZero.convertToDouble());
# 6030|     EXPECT_TRUE(DPosZeroToDouble.isPosZero());
# 6031|     APFloat DNegZero(-0.0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6029: var_decl: Declaring variable "DPosZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6030: uninit_use_in_call: Using uninitialized value "DPosZeroToDouble.U" when calling "isPosZero".
# 6028|     APFloat DPosZero(0.0);
# 6029|     APFloat DPosZeroToDouble(DPosZero.convertToDouble());
# 6030|->   EXPECT_TRUE(DPosZeroToDouble.isPosZero());
# 6031|     APFloat DNegZero(-0.0);
# 6032|     APFloat DNegZeroToDouble(DNegZero.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6031: var_decl: Declaring variable "DNegZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6032: uninit_use_in_call: Using uninitialized value "DNegZero.U" when calling "convertToDouble".
# 6030|     EXPECT_TRUE(DPosZeroToDouble.isPosZero());
# 6031|     APFloat DNegZero(-0.0);
# 6032|->   APFloat DNegZeroToDouble(DNegZero.convertToDouble());
# 6033|     EXPECT_TRUE(DNegZeroToDouble.isNegZero());
# 6034|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6032: var_decl: Declaring variable "DNegZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6033: uninit_use_in_call: Using uninitialized value "DNegZeroToDouble.U" when calling "isNegZero".
# 6031|     APFloat DNegZero(-0.0);
# 6032|     APFloat DNegZeroToDouble(DNegZero.convertToDouble());
# 6033|->   EXPECT_TRUE(DNegZeroToDouble.isNegZero());
# 6034|   
# 6035|     APFloat DOne(1.0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6035: var_decl: Declaring variable "DOne".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6036: uninit_use_in_call: Using uninitialized value "DOne.U" when calling "convertToDouble".
# 6034|   
# 6035|     APFloat DOne(1.0);
# 6036|->   EXPECT_EQ(1.0, DOne.convertToDouble());
# 6037|     APFloat DPosLargest = APFloat::getLargest(APFloat::IEEEdouble(), false);
# 6038|     EXPECT_EQ(std::numeric_limits<double>::max(), DPosLargest.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6066: var_decl: Declaring variable "FPosZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6067: uninit_use_in_call: Using uninitialized value "FPosZero.U" when calling "convertToDouble".
# 6065|   TEST(APFloatTest, IEEEsingleToDouble) {
# 6066|     APFloat FPosZero(0.0F);
# 6067|->   APFloat FPosZeroToDouble(FPosZero.convertToDouble());
# 6068|     EXPECT_TRUE(FPosZeroToDouble.isPosZero());
# 6069|     APFloat FNegZero(-0.0F);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6067: var_decl: Declaring variable "FPosZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6068: uninit_use_in_call: Using uninitialized value "FPosZeroToDouble.U" when calling "isPosZero".
# 6066|     APFloat FPosZero(0.0F);
# 6067|     APFloat FPosZeroToDouble(FPosZero.convertToDouble());
# 6068|->   EXPECT_TRUE(FPosZeroToDouble.isPosZero());
# 6069|     APFloat FNegZero(-0.0F);
# 6070|     APFloat FNegZeroToDouble(FNegZero.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6069: var_decl: Declaring variable "FNegZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6070: uninit_use_in_call: Using uninitialized value "FNegZero.U" when calling "convertToDouble".
# 6068|     EXPECT_TRUE(FPosZeroToDouble.isPosZero());
# 6069|     APFloat FNegZero(-0.0F);
# 6070|->   APFloat FNegZeroToDouble(FNegZero.convertToDouble());
# 6071|     EXPECT_TRUE(FNegZeroToDouble.isNegZero());
# 6072|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6070: var_decl: Declaring variable "FNegZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6071: uninit_use_in_call: Using uninitialized value "FNegZeroToDouble.U" when calling "isNegZero".
# 6069|     APFloat FNegZero(-0.0F);
# 6070|     APFloat FNegZeroToDouble(FNegZero.convertToDouble());
# 6071|->   EXPECT_TRUE(FNegZeroToDouble.isNegZero());
# 6072|   
# 6073|     APFloat FOne(1.0F);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6073: var_decl: Declaring variable "FOne".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6074: uninit_use_in_call: Using uninitialized value "FOne.U" when calling "convertToDouble".
# 6072|   
# 6073|     APFloat FOne(1.0F);
# 6074|->   EXPECT_EQ(1.0, FOne.convertToDouble());
# 6075|     APFloat FPosLargest = APFloat::getLargest(APFloat::IEEEsingle(), false);
# 6076|     EXPECT_EQ(std::numeric_limits<float>::max(), FPosLargest.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6104: var_decl: Declaring variable "HPosZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6105: uninit_use_in_call: Using uninitialized value "HPosZeroToDouble.U" when calling "isPosZero".
# 6103|     APFloat HPosZero = APFloat::getZero(APFloat::IEEEhalf());
# 6104|     APFloat HPosZeroToDouble(HPosZero.convertToDouble());
# 6105|->   EXPECT_TRUE(HPosZeroToDouble.isPosZero());
# 6106|     APFloat HNegZero = APFloat::getZero(APFloat::IEEEhalf(), true);
# 6107|     APFloat HNegZeroToDouble(HNegZero.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6107: var_decl: Declaring variable "HNegZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6108: uninit_use_in_call: Using uninitialized value "HNegZeroToDouble.U" when calling "isNegZero".
# 6106|     APFloat HNegZero = APFloat::getZero(APFloat::IEEEhalf(), true);
# 6107|     APFloat HNegZeroToDouble(HNegZero.convertToDouble());
# 6108|->   EXPECT_TRUE(HNegZeroToDouble.isNegZero());
# 6109|   
# 6110|     APFloat HOne(APFloat::IEEEhalf(), "1.0");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6139: var_decl: Declaring variable "BPosZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6140: uninit_use_in_call: Using uninitialized value "BPosZeroToDouble.U" when calling "isPosZero".
# 6138|     APFloat BPosZero = APFloat::getZero(APFloat::IEEEhalf());
# 6139|     APFloat BPosZeroToDouble(BPosZero.convertToDouble());
# 6140|->   EXPECT_TRUE(BPosZeroToDouble.isPosZero());
# 6141|     APFloat BNegZero = APFloat::getZero(APFloat::IEEEhalf(), true);
# 6142|     APFloat BNegZeroToDouble(BNegZero.convertToDouble());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6142: var_decl: Declaring variable "BNegZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6143: uninit_use_in_call: Using uninitialized value "BNegZeroToDouble.U" when calling "isNegZero".
# 6141|     APFloat BNegZero = APFloat::getZero(APFloat::IEEEhalf(), true);
# 6142|     APFloat BNegZeroToDouble(BNegZero.convertToDouble());
# 6143|->   EXPECT_TRUE(BNegZeroToDouble.isNegZero());
# 6144|   }
# 6145|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6312: var_decl: Declaring variable "PosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6313: uninit_use_in_call: Using uninitialized value "PosZeroToFloat.U" when calling "isPosZero".
# 6311|     APFloat PosZero = APFloat::getZero(APFloat::Float8E5M2FNUZ());
# 6312|     APFloat PosZeroToFloat(PosZero.convertToFloat());
# 6313|->   EXPECT_TRUE(PosZeroToFloat.isPosZero());
# 6314|     // Negative zero is not supported
# 6315|     APFloat NegZero = APFloat::getZero(APFloat::Float8E5M2FNUZ(), true);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6316: var_decl: Declaring variable "NegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6317: uninit_use_in_call: Using uninitialized value "NegZeroToFloat.U" when calling "isPosZero".
# 6315|     APFloat NegZero = APFloat::getZero(APFloat::Float8E5M2FNUZ(), true);
# 6316|     APFloat NegZeroToFloat(NegZero.convertToFloat());
# 6317|->   EXPECT_TRUE(NegZeroToFloat.isPosZero());
# 6318|     APFloat One(APFloat::Float8E5M2FNUZ(), "1.0");
# 6319|     EXPECT_EQ(1.0F, One.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6344: var_decl: Declaring variable "PosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6345: uninit_use_in_call: Using uninitialized value "PosZeroToFloat.U" when calling "isPosZero".
# 6343|     APFloat PosZero = APFloat::getZero(APFloat::Float8E4M3FNUZ());
# 6344|     APFloat PosZeroToFloat(PosZero.convertToFloat());
# 6345|->   EXPECT_TRUE(PosZeroToFloat.isPosZero());
# 6346|     // Negative zero is not supported
# 6347|     APFloat NegZero = APFloat::getZero(APFloat::Float8E4M3FNUZ(), true);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6348: var_decl: Declaring variable "NegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6349: uninit_use_in_call: Using uninitialized value "NegZeroToFloat.U" when calling "isPosZero".
# 6347|     APFloat NegZero = APFloat::getZero(APFloat::Float8E4M3FNUZ(), true);
# 6348|     APFloat NegZeroToFloat(NegZero.convertToFloat());
# 6349|->   EXPECT_TRUE(NegZeroToFloat.isPosZero());
# 6350|     APFloat One(APFloat::Float8E4M3FNUZ(), "1.0");
# 6351|     EXPECT_EQ(1.0F, One.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6375: var_decl: Declaring variable "FPosZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6376: uninit_use_in_call: Using uninitialized value "FPosZero.U" when calling "convertToFloat".
# 6374|   TEST(APFloatTest, IEEEsingleToFloat) {
# 6375|     APFloat FPosZero(0.0F);
# 6376|->   APFloat FPosZeroToFloat(FPosZero.convertToFloat());
# 6377|     EXPECT_TRUE(FPosZeroToFloat.isPosZero());
# 6378|     APFloat FNegZero(-0.0F);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6376: var_decl: Declaring variable "FPosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6377: uninit_use_in_call: Using uninitialized value "FPosZeroToFloat.U" when calling "isPosZero".
# 6375|     APFloat FPosZero(0.0F);
# 6376|     APFloat FPosZeroToFloat(FPosZero.convertToFloat());
# 6377|->   EXPECT_TRUE(FPosZeroToFloat.isPosZero());
# 6378|     APFloat FNegZero(-0.0F);
# 6379|     APFloat FNegZeroToFloat(FNegZero.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6378: var_decl: Declaring variable "FNegZero".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6379: uninit_use_in_call: Using uninitialized value "FNegZero.U" when calling "convertToFloat".
# 6377|     EXPECT_TRUE(FPosZeroToFloat.isPosZero());
# 6378|     APFloat FNegZero(-0.0F);
# 6379|->   APFloat FNegZeroToFloat(FNegZero.convertToFloat());
# 6380|     EXPECT_TRUE(FNegZeroToFloat.isNegZero());
# 6381|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6379: var_decl: Declaring variable "FNegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6380: uninit_use_in_call: Using uninitialized value "FNegZeroToFloat.U" when calling "isNegZero".
# 6378|     APFloat FNegZero(-0.0F);
# 6379|     APFloat FNegZeroToFloat(FNegZero.convertToFloat());
# 6380|->   EXPECT_TRUE(FNegZeroToFloat.isNegZero());
# 6381|   
# 6382|     APFloat FOne(1.0F);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6382: var_decl: Declaring variable "FOne".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6383: uninit_use_in_call: Using uninitialized value "FOne.U" when calling "convertToFloat".
# 6381|   
# 6382|     APFloat FOne(1.0F);
# 6383|->   EXPECT_EQ(1.0F, FOne.convertToFloat());
# 6384|     APFloat FPosLargest = APFloat::getLargest(APFloat::IEEEsingle(), false);
# 6385|     EXPECT_EQ(std::numeric_limits<float>::max(), FPosLargest.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6412: var_decl: Declaring variable "HPosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6413: uninit_use_in_call: Using uninitialized value "HPosZeroToFloat.U" when calling "isPosZero".
# 6411|     APFloat HPosZero = APFloat::getZero(APFloat::IEEEhalf());
# 6412|     APFloat HPosZeroToFloat(HPosZero.convertToFloat());
# 6413|->   EXPECT_TRUE(HPosZeroToFloat.isPosZero());
# 6414|     APFloat HNegZero = APFloat::getZero(APFloat::IEEEhalf(), true);
# 6415|     APFloat HNegZeroToFloat(HNegZero.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6415: var_decl: Declaring variable "HNegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6416: uninit_use_in_call: Using uninitialized value "HNegZeroToFloat.U" when calling "isNegZero".
# 6414|     APFloat HNegZero = APFloat::getZero(APFloat::IEEEhalf(), true);
# 6415|     APFloat HNegZeroToFloat(HNegZero.convertToFloat());
# 6416|->   EXPECT_TRUE(HNegZeroToFloat.isNegZero());
# 6417|   
# 6418|     APFloat HOne(APFloat::IEEEhalf(), "1.0");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6448: var_decl: Declaring variable "BPosZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6449: uninit_use_in_call: Using uninitialized value "BPosZeroToDouble.U" when calling "isPosZero".
# 6447|     APFloat BPosZero = APFloat::getZero(APFloat::BFloat());
# 6448|     APFloat BPosZeroToDouble(BPosZero.convertToFloat());
# 6449|->   EXPECT_TRUE(BPosZeroToDouble.isPosZero());
# 6450|     APFloat BNegZero = APFloat::getZero(APFloat::BFloat(), true);
# 6451|     APFloat BNegZeroToDouble(BNegZero.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6451: var_decl: Declaring variable "BNegZeroToDouble".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6452: uninit_use_in_call: Using uninitialized value "BNegZeroToDouble.U" when calling "isNegZero".
# 6450|     APFloat BNegZero = APFloat::getZero(APFloat::BFloat(), true);
# 6451|     APFloat BNegZeroToDouble(BNegZero.convertToFloat());
# 6452|->   EXPECT_TRUE(BNegZeroToDouble.isNegZero());
# 6453|   
# 6454|     APFloat BOne(APFloat::BFloat(), "1.0");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6488: var_decl: Declaring variable "PosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6489: uninit_use_in_call: Using uninitialized value "PosZeroToFloat.U" when calling "isPosZero".
# 6487|     APFloat PosZero = APFloat::getZero(APFloat::Float8E5M2());
# 6488|     APFloat PosZeroToFloat(PosZero.convertToFloat());
# 6489|->   EXPECT_TRUE(PosZeroToFloat.isPosZero());
# 6490|     APFloat NegZero = APFloat::getZero(APFloat::Float8E5M2(), true);
# 6491|     APFloat NegZeroToFloat(NegZero.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6491: var_decl: Declaring variable "NegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6492: uninit_use_in_call: Using uninitialized value "NegZeroToFloat.U" when calling "isNegZero".
# 6490|     APFloat NegZero = APFloat::getZero(APFloat::Float8E5M2(), true);
# 6491|     APFloat NegZeroToFloat(NegZero.convertToFloat());
# 6492|->   EXPECT_TRUE(NegZeroToFloat.isNegZero());
# 6493|   
# 6494|     APFloat One(APFloat::Float8E5M2(), "1.0");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6524: var_decl: Declaring variable "PosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6525: uninit_use_in_call: Using uninitialized value "PosZeroToFloat.U" when calling "isPosZero".
# 6523|     APFloat PosZero = APFloat::getZero(APFloat::Float8E4M3FN());
# 6524|     APFloat PosZeroToFloat(PosZero.convertToFloat());
# 6525|->   EXPECT_TRUE(PosZeroToFloat.isPosZero());
# 6526|     APFloat NegZero = APFloat::getZero(APFloat::Float8E4M3FN(), true);
# 6527|     APFloat NegZeroToFloat(NegZero.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6527: var_decl: Declaring variable "NegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6528: uninit_use_in_call: Using uninitialized value "NegZeroToFloat.U" when calling "isNegZero".
# 6526|     APFloat NegZero = APFloat::getZero(APFloat::Float8E4M3FN(), true);
# 6527|     APFloat NegZeroToFloat(NegZero.convertToFloat());
# 6528|->   EXPECT_TRUE(NegZeroToFloat.isNegZero());
# 6529|   
# 6530|     APFloat One(APFloat::Float8E4M3FN(), "1.0");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6556: var_decl: Declaring variable "PosZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6557: uninit_use_in_call: Using uninitialized value "PosZeroToFloat.U" when calling "isPosZero".
# 6555|     APFloat PosZero = APFloat::getZero(APFloat::FloatTF32());
# 6556|     APFloat PosZeroToFloat(PosZero.convertToFloat());
# 6557|->   EXPECT_TRUE(PosZeroToFloat.isPosZero());
# 6558|     APFloat NegZero = APFloat::getZero(APFloat::FloatTF32(), true);
# 6559|     APFloat NegZeroToFloat(NegZero.convertToFloat());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6559: var_decl: Declaring variable "NegZeroToFloat".
llvm-17.0.6.src/unittests/ADT/APFloatTest.cpp:6560: uninit_use_in_call: Using uninitialized value "NegZeroToFloat.U" when calling "isNegZero".
# 6558|     APFloat NegZero = APFloat::getZero(APFloat::FloatTF32(), true);
# 6559|     APFloat NegZeroToFloat(NegZero.convertToFloat());
# 6560|->   EXPECT_TRUE(NegZeroToFloat.isNegZero());
# 6561|   
# 6562|     APFloat One(APFloat::FloatTF32(), "1.0");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/APIntTest.cpp:1030: var_decl: Declaring variable "sr" without initializer.
llvm-17.0.6.src/unittests/ADT/APIntTest.cpp:1031: uninit_use_in_call: Using uninitialized value "sr" when calling "sdivrem".
# 1029|       EXPECT_EQ(c, r);
# 1030|     int64_t sr;
# 1031|->   APInt::sdivrem(p, b, q, sr);
# 1032|     EXPECT_EQ(a, q);
# 1033|     if (c.isNegative())

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/AnyTest.cpp:57: move: "C" is moved (indicated by "std::move(C)").
llvm-17.0.6.src/unittests/ADT/AnyTest.cpp:58: use_after_move: "C" is used after it has been already moved.
#   56|     // isn't.
#   57|     llvm::Any G(std::move(C));
#   58|->   EXPECT_FALSE(C.has_value());
#   59|     EXPECT_TRUE(G.has_value());
#   60|     EXPECT_TRUE(any_cast<int>(&G));

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/AnyTest.cpp:71: move: "G" is moved (indicated by "std::move(G)").
llvm-17.0.6.src/unittests/ADT/AnyTest.cpp:73: use_after_move: "G" is used after it has been already moved.
#   71|     B = std::move(G);
#   72|     EXPECT_TRUE(B.has_value());
#   73|->   EXPECT_FALSE(G.has_value());
#   74|     EXPECT_TRUE(any_cast<int>(&B));
#   75|     EXPECT_FALSE(any_cast<int>(&G));

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/AnyTest.cpp:113: move: "E" is moved (indicated by "std::move(E)").
llvm-17.0.6.src/unittests/ADT/AnyTest.cpp:114: use_after_move: "E" is used after it has been already moved.
#  112|     // in the process.
#  113|     EXPECT_EQ(8, llvm::any_cast<int>(std::move(E)));
#  114|->   EXPECT_TRUE(E.has_value());
#  115|   
#  116|     // Make sure moving from pointers gives back pointers, and that we can modify

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:74: identity_transfer: Passing "9223372036854775807UL" as argument 2 to constructor for class "ArrayRef", which sets "AR.Length" to that argument.
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:80: identity_transfer: Member function call "AR.size()" returns field "Length".
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:80: overrun-buffer-arg: Calling "drop_front" with "AR.Data" and "AR.size() - 1UL" is suspicious because of the very large index, 9223372036854775806. The index may be due to a negative parameter being interpreted as unsigned.
#   78|   
#   79|     // Check that drop_front accepts size_t-sized numbers.
#   80|->   EXPECT_EQ(1U, AR.drop_front(AR.size() - 1).size());
#   81|   
#   82|     // Check that slice accepts size_t-sized numbers.

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:74: identity_transfer: Passing "9223372036854775807UL" as argument 2 to constructor for class "ArrayRef", which sets "AR.Length" to that argument.
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:83: identity_transfer: Member function call "AR.size()" returns field "Length".
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:83: overrun-buffer-arg: Calling "slice" with "AR.Data" and "AR.size() - 1UL" is suspicious because of the very large index, 9223372036854775806. The index may be due to a negative parameter being interpreted as unsigned.
#   81|   
#   82|     // Check that slice accepts size_t-sized numbers.
#   83|->   EXPECT_EQ(1U, AR.slice(AR.size() - 1).size());
#   84|     EXPECT_EQ(AR.size() - 1, AR.slice(1, AR.size() - 1).size());
#   85|   }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:244: move: "A" is moved (indicated by "std::move(A)").
llvm-17.0.6.src/unittests/ADT/ArrayRefTest.cpp:245: use_after_move: "A" is used after it has been already moved.
#  243|     OwningArrayRef<int> A{ArrayRef(A1)};
#  244|     OwningArrayRef<int> B(std::move(A));
#  245|->   EXPECT_EQ(A.data(), nullptr);
#  246|   }
#  247|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/DenseMapTest.cpp:281: var_decl: Declaring variable "otherMap".
llvm-17.0.6.src/unittests/ADT/DenseMapTest.cpp:283: uninit_use_in_call: Using uninitialized value "otherMap.NumEntries" when calling "swap".
llvm-17.0.6.src/unittests/ADT/DenseMapTest.cpp:283: uninit_use_in_call: Using uninitialized value "otherMap.NumTombstones" when calling "swap".
#  281|     TypeParam otherMap;
#  282|   
#  283|->   this->Map.swap(otherMap);
#  284|     EXPECT_EQ(0u, this->Map.size());
#  285|     EXPECT_TRUE(this->Map.empty());

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/DenseSetTest.cpp:57: var_decl: Declaring variable "Set".
llvm-17.0.6.src/unittests/ADT/DenseSetTest.cpp:61: uninit_use: Using uninitialized value "Set". Field "Set.TheMap.NumEntries" is uninitialized.
#   59|       Set.insert(1);
#   60|       Set.insert(2);
#   61|->     return Set;
#   62|     }
#   63|   };

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/FallibleIteratorTest.cpp:211: move: "Err" is moved (indicated by "std::move(Err)").
llvm-17.0.6.src/unittests/ADT/FallibleIteratorTest.cpp:213: use_after_move: "Err" is used after it has been already moved.
#  211|       EXPECT_THAT_ERROR(std::move(Err), Succeeded());
#  212|       ++I;
#  213|->     EXPECT_THAT_ERROR(std::move(Err), Failed()) << "Expected failure value";
#  214|     }
#  215|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/FallibleIteratorTest.cpp:229: move: "Err" is moved (indicated by "std::move(Err)").
llvm-17.0.6.src/unittests/ADT/FallibleIteratorTest.cpp:231: use_after_move: "Err" is used after it has been already moved.
#  229|       EXPECT_THAT_ERROR(std::move(Err), Succeeded());
#  230|       --I;
#  231|->     EXPECT_THAT_ERROR(std::move(Err), Failed());
#  232|     }
#  233|   }

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:162: overrun-buffer-val: Overrunning buffer pointed to by "&dummy" of 4 bytes by passing it to a function which accesses it at byte offset 63.
#  160|     // Leave this uninitialized in the hope that valgrind will catch bad reads.
#  161|     int dummy;
#  162|->   hash_code dummy_hash = hash_combine_range(&dummy, &dummy);
#  163|     EXPECT_NE(hash_code(0), dummy_hash);
#  164|   

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:314: overrun-buffer-val: Overrunning array "arr1" of 24 bytes by passing it to a function which accesses it at byte offset 63.
#  312|     const int i1 = 42, i2 = 43, i3 = 123, i4 = 999, i5 = 0, i6 = 79;
#  313|     const int arr1[] = { i1, i2, i3, i4, i5, i6 };
#  314|->   EXPECT_EQ(hash_combine_range(arr1, arr1 + 1), hash_combine(i1));
#  315|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 2), hash_combine(i1, i2));
#  316|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 3), hash_combine(i1, i2, i3));

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:315: overrun-buffer-val: Overrunning array "arr1" of 24 bytes by passing it to a function which accesses it at byte offset 63.
#  313|     const int arr1[] = { i1, i2, i3, i4, i5, i6 };
#  314|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 1), hash_combine(i1));
#  315|->   EXPECT_EQ(hash_combine_range(arr1, arr1 + 2), hash_combine(i1, i2));
#  316|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 3), hash_combine(i1, i2, i3));
#  317|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 4), hash_combine(i1, i2, i3, i4));

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:316: overrun-buffer-val: Overrunning array "arr1" of 24 bytes by passing it to a function which accesses it at byte offset 63.
#  314|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 1), hash_combine(i1));
#  315|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 2), hash_combine(i1, i2));
#  316|->   EXPECT_EQ(hash_combine_range(arr1, arr1 + 3), hash_combine(i1, i2, i3));
#  317|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 4), hash_combine(i1, i2, i3, i4));
#  318|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 5),

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:317: overrun-buffer-val: Overrunning array "arr1" of 24 bytes by passing it to a function which accesses it at byte offset 63.
#  315|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 2), hash_combine(i1, i2));
#  316|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 3), hash_combine(i1, i2, i3));
#  317|->   EXPECT_EQ(hash_combine_range(arr1, arr1 + 4), hash_combine(i1, i2, i3, i4));
#  318|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 5),
#  319|               hash_combine(i1, i2, i3, i4, i5));

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:318: overrun-buffer-val: Overrunning array "arr1" of 24 bytes by passing it to a function which accesses it at byte offset 63.
#  316|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 3), hash_combine(i1, i2, i3));
#  317|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 4), hash_combine(i1, i2, i3, i4));
#  318|->   EXPECT_EQ(hash_combine_range(arr1, arr1 + 5),
#  319|               hash_combine(i1, i2, i3, i4, i5));
#  320|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 6),

Error: OVERRUN (CWE-119):
llvm-17.0.6.src/unittests/ADT/HashingTest.cpp:320: overrun-buffer-val: Overrunning array "arr1" of 24 bytes by passing it to a function which accesses it at byte offset 63.
#  318|     EXPECT_EQ(hash_combine_range(arr1, arr1 + 5),
#  319|               hash_combine(i1, i2, i3, i4, i5));
#  320|->   EXPECT_EQ(hash_combine_range(arr1, arr1 + 6),
#  321|               hash_combine(i1, i2, i3, i4, i5, i6));
#  322|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/MappedIteratorTest.cpp:175: move: "I2" is moved (indicated by "std::move(I2)").
llvm-17.0.6.src/unittests/ADT/MappedIteratorTest.cpp:177: use_after_move: "I2" is used after it has been already moved.
#  175|       I3 = std::move(I2);
#  176|   
#  177|->     EXPECT_EQ(I2, I1) << "move assigned iterator is a different position";
#  178|     }
#  179|   }

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/unittests/ADT/PointerIntPairTest.cpp:116: address_of: Taking address with "&IntPtr" yields a singleton pointer.
llvm-17.0.6.src/unittests/ADT/PointerIntPairTest.cpp:116: assign: Assigning: "IntPtrBegin" = "&IntPtr".
llvm-17.0.6.src/unittests/ADT/PointerIntPairTest.cpp:117: ptr_arith: Using "IntPtrBegin" as an array.  This might corrupt or misinterpret adjacent memory locations.
#  115|   
#  116|     int **IntPtrBegin = &IntPtr;
#  117|->   int **IntPtrEnd = IntPtrBegin + 1;
#  118|   
#  119|     PointerIntPair<int *, 1> Pair;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ADT/STLExtrasTest.cpp:816: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/unittests/ADT/STLExtrasTest.cpp:816: leaked_storage: Ignoring storage allocated by "V2.release()" leaks it.
#  814|     V2.reset(V1);
#  815|     EXPECT_EQ(V1, llvm::to_address(V2));
#  816|->   V2.release();
#  817|   
#  818|     // Check fancy pointer overload for shared_ptr

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ADT/STLExtrasTest.cpp:939: var_decl: Declaring variable "Foos".
llvm-17.0.6.src/unittests/ADT/STLExtrasTest.cpp:941: uninit_use: Using uninitialized value "Foos". Field "Foos.InlineElts" is uninitialized.
#  939|       SmallVector<Foo, 4U> Foos;
#  940|       Foos.resize(4U);
#  941|->     return Foos;
#  942|     };
#  943|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/ScopeExitTest.cpp:36: move: "G" is moved (indicated by "std::move(G)").
llvm-17.0.6.src/unittests/ADT/ScopeExitTest.cpp:37: use_after_move: "G" is used after it has been already moved.
#   35|       auto G = make_scope_exit(Increment);
#   36|       auto H = std::move(G);
#   37|->     auto I = std::move(G);
#   38|       EXPECT_EQ(0, Count);
#   39|     }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/SmallPtrSetTest.cpp:139: move: "s1" is moved (indicated by "std::move(s1)").
llvm-17.0.6.src/unittests/ADT/SmallPtrSetTest.cpp:141: use_after_move: "s1" is used after it has been already moved.
#  139|     SmallPtrSet<int *, 4> s3(std::move(s1));
#  140|     EXPECT_EQ(4U, s3.size());
#  141|->   EXPECT_TRUE(s1.empty());
#  142|     for (int i = 0; i < 8; ++i)
#  143|       if (i < 4)

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/SmallPtrSetTest.cpp:154: move: "s3" is moved (indicated by "std::move(s3)").
llvm-17.0.6.src/unittests/ADT/SmallPtrSetTest.cpp:156: use_after_move: "s3" is used after it has been already moved.
#  154|     s1 = std::move(s3);
#  155|     EXPECT_EQ(8U, s1.size());
#  156|->   EXPECT_TRUE(s3.empty());
#  157|     for (int i = 0; i < 8; ++i)
#  158|       EXPECT_TRUE(s1.count(&buf[i]));

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/SmallVectorTest.cpp:1086: move: "A0" is moved (indicated by "std::move(A0)").
llvm-17.0.6.src/unittests/ADT/SmallVectorTest.cpp:1097: use_after_move: "A0" is used after it has been already moved.
# 1095|     {
# 1096|       SmallVector<Emplaceable, 3> V;
# 1097|->     Emplaceable &back = V.emplace_back(std::move(A0), A1, std::move(A2), A3);
# 1098|       EXPECT_TRUE(&back == &V.back());
# 1099|       EXPECT_TRUE(V.size() == 1);

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/SparseBitVectorTest.cpp:46: move: "Vec" is moved (indicated by "std::move(Vec)").
llvm-17.0.6.src/unittests/ADT/SparseBitVectorTest.cpp:47: use_after_move: "Vec" is used after it has been already moved.
#   45|     EXPECT_FALSE(Vec.empty());
#   46|     SparseBitVector<> MovedVec(std::move(Vec));
#   47|->   EXPECT_TRUE(Vec.empty());
#   48|     EXPECT_TRUE(MovedVec.test(5));
#   49|     EXPECT_TRUE(MovedVec.test(1337));

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/SparseBitVectorTest.cpp:51: move: "MovedVec" is moved (indicated by "std::move(MovedVec)").
llvm-17.0.6.src/unittests/ADT/SparseBitVectorTest.cpp:52: use_after_move: "MovedVec" is used after it has been already moved.
#   50|   
#   51|     Vec = std::move(MovedVec);
#   52|->   EXPECT_TRUE(MovedVec.empty());
#   53|     EXPECT_FALSE(Vec.empty());
#   54|   }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/StringMapTest.cpp:407: move: "A" is moved (indicated by "std::move(A)").
llvm-17.0.6.src/unittests/ADT/StringMapTest.cpp:408: use_after_move: "A" is used after it has been already moved.
#  406|     A["x"] = 42;
#  407|     StringMap<int> B = std::move(A);
#  408|->   ASSERT_EQ(A.size(), 0u);
#  409|     ASSERT_EQ(B.size(), 1u);
#  410|     ASSERT_EQ(B["x"], 42);

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/StringMapTest.cpp:419: move: "B" is moved (indicated by "std::move(B)").
llvm-17.0.6.src/unittests/ADT/StringMapTest.cpp:421: use_after_move: "B" is used after it has been already moved.
#  419|     A = std::move(B);
#  420|     ASSERT_EQ(A.size(), 1u);
#  421|->   ASSERT_EQ(B.size(), 0u);
#  422|     ASSERT_EQ(A["y"], 117);
#  423|     ASSERT_EQ(B.count("x"), 0u);

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/StringMapTest.cpp:522: move: "A" is moved (indicated by "std::move(A)").
llvm-17.0.6.src/unittests/ADT/StringMapTest.cpp:524: use_after_move: "A" is used after it has been already moved.
#  522|     B = std::move(A);
#  523|     ASSERT_EQ(InstanceCount, 1);
#  524|->   ASSERT_TRUE(A.empty());
#  525|     I = B.find("x");
#  526|     ASSERT_NE(I, B.end());

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/TinyPtrVectorTest.cpp:160: move: "Copy2" is moved (indicated by "std::move(Copy2)").
llvm-17.0.6.src/unittests/ADT/TinyPtrVectorTest.cpp:162: use_after_move: "Copy2" is used after it has been already moved.
#  160|     TypeParam Move(std::move(Copy2));
#  161|     this->expectValues(Move, this->testArray(42));
#  162|->   this->expectValues(Copy2, this->testArray(0));
#  163|   
#  164|     TypeParam MultipleElements(this->testArray(2));

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ADT/TinyPtrVectorTest.cpp:166: move: "SingleElement" is moved (indicated by "std::move(SingleElement)").
llvm-17.0.6.src/unittests/ADT/TinyPtrVectorTest.cpp:168: use_after_move: "SingleElement" is used after it has been already moved.
#  166|     MultipleElements = std::move(SingleElement);
#  167|     this->expectValues(MultipleElements, this->testArray(1));
#  168|->   this->expectValues(SingleElement, this->testArray(0));
#  169|   }
#  170|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp:1434: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp:1435: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
# 1433|   
# 1434|     LegalizerInfo LI;
# 1435|->   LI.getActionDefinitionsBuilder(TargetOpcode::G_AND)
# 1436|       .legalFor({v6s32})
# 1437|       .clampMinNumElements(0, s32, 6);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp:1486: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp:1487: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
# 1485|   
# 1486|     LegalizerInfo LI;
# 1487|->   LI.getActionDefinitionsBuilder(TargetOpcode::G_PHI)
# 1488|       .legalFor({v2s32})
# 1489|       .clampMinNumElements(0, s32, 2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:52: var_decl: Declaring variable "L".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:67: uninit_use_in_call: Using uninitialized element of array "L.RulesForOpcode". Field "L.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getAction".
#   65|     for (unsigned opcode : {G_ADD, G_SUB}) {
#   66|       // Check we infer the correct types and actually do what we're told.
#   67|->     EXPECT_EQ(L.getAction({opcode, {LLT::scalar(8)}}),
#   68|                 LegalizeActionStep(WidenScalar, 0, LLT::scalar(32)));
#   69|       EXPECT_EQ(L.getAction({opcode, {LLT::scalar(16)}}),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:95: var_decl: Declaring variable "L".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:121: uninit_use_in_call: Using uninitialized element of array "L.RulesForOpcode". Field "L.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getAction".
#  119|     // Check we infer the correct types and actually do what we're told for some
#  120|     // simple cases.
#  121|->   EXPECT_EQ(L.getAction({G_ADD, {LLT::fixed_vector(8, 8)}}),
#  122|               LegalizeActionStep(Legal, 0, LLT{}));
#  123|     EXPECT_EQ(L.getAction({G_ADD, {LLT::fixed_vector(8, 7)}}),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:138: var_decl: Declaring variable "L".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:153: uninit_use_in_call: Using uninitialized element of array "L.RulesForOpcode". Field "L.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getAction".
#  151|   
#  152|     // Check we infer the correct types and actually do what we're told.
#  153|->   EXPECT_EQ(L.getAction({G_PTRTOINT, {s64, p0}}),
#  154|               LegalizeActionStep(Legal, 0, LLT{}));
#  155|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:167: var_decl: Declaring variable "L".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:179: uninit_use_in_call: Using uninitialized element of array "L.RulesForOpcode". Field "L.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getAction".
#  177|     LegacyInfo.computeTables();
#  178|   
#  179|->   EXPECT_EQ(L.getAction({G_UREM, {LLT::scalar(16)}}),
#  180|               LegalizeActionStep(WidenScalar, 0, LLT::scalar(32)));
#  181|     EXPECT_EQ(L.getAction({G_UREM, {LLT::scalar(32)}}),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:187: var_decl: Declaring variable "L".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:199: uninit_use_in_call: Using uninitialized element of array "L.RulesForOpcode". Field "L.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getAction".
#  197|     // Check we infer the correct types and actually do what we're told.
#  198|     for (unsigned Size : {1, 8, 16, 32}) {
#  199|->     EXPECT_EQ(L.getAction({G_UREM, {LLT::scalar(Size)}}),
#  200|                 LegalizeActionStep(Legal, 0, LLT{}));
#  201|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:253: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:256: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  254|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  255|   
#  256|->     LI.getActionDefinitionsBuilder(G_IMPLICIT_DEF)
#  257|         .legalFor({v4s32, v4p0})
#  258|         .moreElementsToNextPow2(0);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:269: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:271: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  269|       LegalizerInfo LI;
#  270|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  271|->     LI.getActionDefinitionsBuilder(G_OR)
#  272|         .legalFor({s32})
#  273|         .minScalarOrElt(0, s32);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:282: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:284: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  282|       LegalizerInfo LI;
#  283|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  284|->     LI.getActionDefinitionsBuilder(G_AND)
#  285|         .legalFor({s16})
#  286|         .maxScalarOrElt(0, s16);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:295: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:297: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  295|       LegalizerInfo LI;
#  296|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  297|->     LI.getActionDefinitionsBuilder(G_XOR)
#  298|         .legalFor({s16})
#  299|         .clampScalarOrElt(0, s16, s32);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:312: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:314: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  312|       LegalizerInfo LI;
#  313|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  314|->     LI.getActionDefinitionsBuilder(G_OR)
#  315|         .legalFor({s32})
#  316|         .minScalar(0, s32);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:327: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:329: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  327|       LegalizerInfo LI;
#  328|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  329|->     LI.getActionDefinitionsBuilder(G_OR)
#  330|         .legalFor({s32})
#  331|         .minScalarIf([&](const LegalityQuery &Query) {

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:347: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:349: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  347|       LegalizerInfo LI;
#  348|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  349|->     LI.getActionDefinitionsBuilder(G_AND)
#  350|         .legalFor({s16})
#  351|         .maxScalar(0, s16);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:361: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:364: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  362|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  363|   
#  364|->     LI.getActionDefinitionsBuilder(G_XOR)
#  365|         .legalFor({s16})
#  366|         .clampScalar(0, s16, s32);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:379: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:382: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  380|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  381|   
#  382|->     LI.getActionDefinitionsBuilder(G_AND)
#  383|         .legalFor({s32})
#  384|         .widenScalarOrEltToNextPow2(0, 32);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:396: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:399: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  397|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  398|   
#  399|->     LI.getActionDefinitionsBuilder(G_AND)
#  400|         .legalFor({s32})
#  401|         .widenScalarToNextPow2(0, 32);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:414: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:418: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  416|   
#  417|       // Type index form
#  418|->     LI.getActionDefinitionsBuilder(G_SELECT)
#  419|         .moreElementsIf(isScalar(1), changeElementCountTo(1, 0));
#  420|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:455: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:458: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  456|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  457|   
#  458|->     LI.getActionDefinitionsBuilder(G_SELECT).minScalarEltSameAsIf(
#  459|           all(isVector(0), isVector(1)), 1, 0);
#  460|       LegacyInfo.computeTables();

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:476: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:478: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  476|       LegalizerInfo LI;
#  477|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  478|->     LI.getActionDefinitionsBuilder(G_LOAD)
#  479|         .legalForTypesWithMemDesc({{s32, p0, s32, 32}});
#  480|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:502: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:504: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  502|       LegalizerInfo LI;
#  503|       auto &LegacyInfo = LI.getLegacyLegalizerInfo();
#  504|->     LI.getActionDefinitionsBuilder(G_LOAD)
#  505|         .legalForTypesWithMemDesc({{s32, p0, s32, MaxAlignInBits}});
#  506|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:525: var_decl: Declaring variable "LI".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/LegalizerInfoTest.cpp:526: uninit_use_in_call: Using uninitialized element of array "LI.RulesForOpcode". Field "LI.RulesForOpcode[0].Rules.InlineElts" is uninitialized when calling "getActionDefinitionsBuilder".
#  524|     const LLT P0 = LLT::pointer(0, 32);
#  525|     LegalizerInfo LI;
#  526|->   auto Builder = LI.getActionDefinitionsBuilder(TargetOpcode::G_PTRTOINT);
#  527|     (void)Builder.legalForCartesianProduct({S1}, {P0});
#  528|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/PatternMatchTest.cpp:421: var_decl: Declaring variable "APF".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/PatternMatchTest.cpp:422: uninit_use_in_call: Using uninitialized value "APF.U" when calling "get".
#  420|     EXPECT_TRUE(TmpFP);
#  421|     APFloat APF((float).5);
#  422|->   auto *CFP = ConstantFP::get(Context, APF);
#  423|     EXPECT_EQ(CFP, TmpFP);
#  424|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/PatternMatchTest.cpp:432: var_decl: Declaring variable "APF64".
llvm-17.0.6.src/unittests/CodeGen/GlobalISel/PatternMatchTest.cpp:433: uninit_use_in_call: Using uninitialized value "APF64.U" when calling "get".
#  431|     EXPECT_TRUE(TmpFP64);
#  432|     APFloat APF64(.5);
#  433|->   auto CFP64 = ConstantFP::get(Context, APF64);
#  434|     EXPECT_EQ(CFP64, TmpFP64);
#  435|     EXPECT_NE(TmpFP64, TmpFP);

Error: RETURN_LOCAL (CWE-562):
llvm-17.0.6.src/unittests/CodeGen/MFCommon.inc:107: escape_local_addr: Returning, through "this->TheTarget", the address of stack variable "<temporary>".
#  105|   public:
#  106|     BogusTargetMachine()
#  107|->       : LLVMTargetMachine(Target(), "", Triple(""), "", "",
#  108|                             getTargetOptionsForBogusMachine(), Reloc::Static,
#  109|                             CodeModel::Small, CodeGenOpt::Default),

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/CodeGen/MLRegallocDevelopmentFeatures.cpp:50: var_decl: Declaring variable "PositionsToReturn".
llvm-17.0.6.src/unittests/CodeGen/MLRegallocDevelopmentFeatures.cpp:80: uninit_use: Using uninitialized value "PositionsToReturn". Field "PositionsToReturn.InlineElts" is uninitialized.
#   78|         CurrentIndex += SlotIndex::InstrDist;
#   79|       }
#   80|->     return PositionsToReturn;
#   81|     }
#   82|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/DebugInfo/GSYM/GSYMTest.cpp:466: var_decl: Declaring variable "Empty".
llvm-17.0.6.src/unittests/DebugInfo/GSYM/GSYMTest.cpp:475: uninit_use_in_call: Using uninitialized value "Empty". Field "Empty.Ranges.Ranges.InlineElts" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  473|     InlineInfo ContainsEmpty;
#  474|     ContainsEmpty.Ranges.insert({0x100, 0x200});
#  475|->   ContainsEmpty.Children.push_back(Empty);
#  476|     TestInlineInfoEncodeError(llvm::support::little, ContainsEmpty, EmptyErr);
#  477|     TestInlineInfoEncodeError(llvm::support::big, ContainsEmpty, EmptyErr);

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/unittests/DebugInfo/LogicalView/CodeViewReaderTest.cpp:464: extract: Calling "get" which extracts wrapped state from local "Reference".
llvm-17.0.6.src/unittests/DebugInfo/LogicalView/CodeViewReaderTest.cpp:464: escape: The internal representation of local "Reference" escapes, but is destroyed when it exits scope.
#  462|     std::unique_ptr<LVReader> Target =
#  463|         createReader(ReaderHandler, InputsDir, CodeViewMsvc);
#  464|->   checkElementComparison(Reference.get(), Target.get());
#  465|   }
#  466|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/unittests/DebugInfo/LogicalView/ELFReaderTest.cpp:323: extract: Calling "get" which extracts wrapped state from local "Reference".
llvm-17.0.6.src/unittests/DebugInfo/LogicalView/ELFReaderTest.cpp:323: escape: The internal representation of local "Reference" escapes, but is destroyed when it exits scope.
#  321|     std::unique_ptr<LVReader> Target =
#  322|         createReader(ReaderHandler, InputsDir, DwarfGcc);
#  323|->   checkElementComparison(Reference.get(), Target.get());
#  324|   }
#  325|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManagerTest.cpp:37: move: "MB" is moved (indicated by "std::move(MB)").
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManagerTest.cpp:38: use_after_move: "MB" is used after it has been already moved.
#   36|         return errorCodeToError(EC);
#   37|       Blocks[MB.base()] = sys::OwningMemoryBlock(std::move(MB));
#   38|->     return ExecutorAddr::fromPtr(MB.base());
#   39|     }
#   40|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/MemoryMapperTest.cpp:91: var_decl: Declaring variable "Seg1".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/MemoryMapperTest.cpp:98: uninit_use_in_call: Using uninitialized value "Seg1". Field "Seg1.WorkingMem" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   96|   
#   97|         Alloc1.MappingBase = Mem1->Start;
#   98|->       Alloc1.Segments.push_back(Seg1);
#   99|         Alloc1.Actions.push_back(
#  100|             {cantFail(WrapperFunctionCall::Create<SPSArgList<SPSExecutorAddr>>(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/MemoryMapperTest.cpp:115: var_decl: Declaring variable "Seg2".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/MemoryMapperTest.cpp:122: uninit_use_in_call: Using uninitialized value "Seg2". Field "Seg2.WorkingMem" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  120|   
#  121|         Alloc2.MappingBase = Mem1->Start;
#  122|->       Alloc2.Segments.push_back(Seg2);
#  123|         Alloc2.Actions.push_back(
#  124|             {cantFail(WrapperFunctionCall::Create<SPSArgList<SPSExecutorAddr>>(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/MemoryMapperTest.cpp:167: var_decl: Declaring variable "Seg3".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/MemoryMapperTest.cpp:174: uninit_use_in_call: Using uninitialized value "Seg3". Field "Seg3.WorkingMem" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  172|   
#  173|           Alloc3.MappingBase = Mem2->Start;
#  174|->         Alloc3.Segments.push_back(Seg3);
#  175|           Alloc3.Actions.push_back(
#  176|               {cantFail(WrapperFunctionCall::Create<SPSArgList<SPSExecutorAddr>>(

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:96: alloc_fn: Storage is returned from allocation function "LLVMOrcJITTargetMachineBuilderDetectHost".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:96: var_assign: Assigning: "E1" = storage returned from "LLVMOrcJITTargetMachineBuilderDetectHost(&JTMB)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:108: leaked_storage: Variable "E1" going out of scope leaks the storage it points to.
#  106|       ExecutionSession = LLVMOrcLLJITGetExecutionSession(Jit);
#  107|       MainDylib = LLVMOrcLLJITGetMainJITDylib(Jit);
#  108|->   }
#  109|     void TearDown() override {
#  110|       // Check whether Jit has already been torn down -- we allow clients to do

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:444: alloc_fn: Storage is returned from allocation function "LLVMOrcResourceTrackerRemove".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:444: leaked_storage: Ignoring storage allocated by "LLVMOrcResourceTrackerRemove(RT)" leaks it.
#  442|              << "): " << toString(E);
#  443|     ASSERT_TRUE(!!TestFnAddr);
#  444|->   LLVMOrcResourceTrackerRemove(RT);
#  445|     LLVMOrcJITTargetAddress OutAddr;
#  446|     LLVMErrorRef Err = LLVMOrcLLJITLookup(Jit, &OutAddr, "sum");

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:537: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityGetSymbols".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:537: var_assign: Assigning: "Symbols" = storage returned from "LLVMOrcMaterializationResponsibilityGetSymbols(MR, &NumSymbols)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:540: leaked_storage: Variable "Symbols" going out of scope leaks the storage it points to.
#  538|         LLVMOrcMaterializationResponsibilityGetSymbols(MR, &NumSymbols);
#  539|   
#  540|->   ASSERT_TRUE(!!Symbols);
#  541|     ASSERT_EQ(NumSymbols, (size_t)1);
#  542|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:537: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityGetSymbols".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:537: var_assign: Assigning: "Symbols" = storage returned from "LLVMOrcMaterializationResponsibilityGetSymbols(MR, &NumSymbols)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:541: leaked_storage: Variable "Symbols" going out of scope leaks the storage it points to.
#  539|   
#  540|     ASSERT_TRUE(!!Symbols);
#  541|->   ASSERT_EQ(NumSymbols, (size_t)1);
#  542|   
#  543|     LLVMOrcSymbolStringPoolEntryRef *RequestedSymbols =

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:543: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityGetRequestedSymbols".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:543: var_assign: Assigning: "RequestedSymbols" = storage returned from "LLVMOrcMaterializationResponsibilityGetRequestedSymbols(MR, &NumSymbols)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:546: leaked_storage: Variable "RequestedSymbols" going out of scope leaks the storage it points to.
#  544|         LLVMOrcMaterializationResponsibilityGetRequestedSymbols(MR, &NumSymbols);
#  545|   
#  546|->   ASSERT_TRUE(!!RequestedSymbols);
#  547|     ASSERT_EQ(NumSymbols, (size_t)1);
#  548|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:543: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityGetRequestedSymbols".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:543: var_assign: Assigning: "RequestedSymbols" = storage returned from "LLVMOrcMaterializationResponsibilityGetRequestedSymbols(MR, &NumSymbols)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:547: leaked_storage: Variable "RequestedSymbols" going out of scope leaks the storage it points to.
#  545|   
#  546|     ASSERT_TRUE(!!RequestedSymbols);
#  547|->   ASSERT_EQ(NumSymbols, (size_t)1);
#  548|   
#  549|     LLVMOrcCSymbolFlagsMapPair TargetSym = Symbols[0];

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:543: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityGetRequestedSymbols".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:543: var_assign: Assigning: "RequestedSymbols" = storage returned from "LLVMOrcMaterializationResponsibilityGetRequestedSymbols(MR, &NumSymbols)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:551: noescape: Resource "RequestedSymbols[0]" is not freed or pointed-to in "Compare".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:551: leaked_storage: Variable "RequestedSymbols" going out of scope leaks the storage it points to.
#  549|     LLVMOrcCSymbolFlagsMapPair TargetSym = Symbols[0];
#  550|   
#  551|->   ASSERT_EQ(RequestedSymbols[0], TargetSym.Name);
#  552|     LLVMOrcRetainSymbolStringPoolEntry(TargetSym.Name);
#  553|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:537: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityGetSymbols".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:537: var_assign: Assigning: "Symbols" = storage returned from "LLVMOrcMaterializationResponsibilityGetSymbols(MR, &NumSymbols)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:551: leaked_storage: Variable "Symbols" going out of scope leaks the storage it points to.
#  549|     LLVMOrcCSymbolFlagsMapPair TargetSym = Symbols[0];
#  550|   
#  551|->   ASSERT_EQ(RequestedSymbols[0], TargetSym.Name);
#  552|     LLVMOrcRetainSymbolStringPoolEntry(TargetSym.Name);
#  553|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:579: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityDefineMaterializing".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:579: leaked_storage: Ignoring storage allocated by "LLVMOrcMaterializationResponsibilityDefineMaterializing(MR, NewSymbols, 2UL)" leaks it.
#  577|         {DependencySymbol, Flags},
#  578|     };
#  579|->   LLVMOrcMaterializationResponsibilityDefineMaterializing(MR, NewSymbols, 2);
#  580|   
#  581|     LLVMOrcRetainSymbolStringPoolEntry(OtherSymbol);

Error: MULTIPLE_INIT_SMART_PTRS (CWE-1341):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:598: assign: Assigning: "OtherMU" = "LLVMOrcAbsoluteSymbols(&OtherPair, 1UL)".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:601: set_unmanaged_raw_ptr: Function "LLVMOrcMaterializationResponsibilityReplace" sets a smart pointer with "OtherMU".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:613: multiple_init_smart_ptr: Function "LLVMOrcDisposeMaterializationUnit" sets a smart pointer with "OtherMU", but it is already managed by another smart pointer.
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:613: remediation: Either release the raw pointer from the smart pointer, or share/transfer the raw pointer by using a copy/move/assignment operation.
#  611|         LLVMOrcDisposeMaterializationResponsibility(OtherMR);
#  612|         LLVMOrcDisposeMaterializationResponsibility(MR);
#  613|->       LLVMOrcDisposeMaterializationUnit(OtherMU);
#  614|         return;
#  615|       }

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:639: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityNotifyResolved".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:639: leaked_storage: Ignoring storage allocated by "LLVMOrcMaterializationResponsibilityNotifyResolved(MR, &Pair, 1UL)" leaks it.
#  637|     // See FIXME above
#  638|     LLVMOrcCSymbolMapPair Pair = {DependencySymbol, Sym};
#  639|->   LLVMOrcMaterializationResponsibilityNotifyResolved(MR, &Pair, 1);
#  640|     // DependencySymbol no longer owned by us
#  641|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:643: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityNotifyResolved".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:643: leaked_storage: Ignoring storage allocated by "LLVMOrcMaterializationResponsibilityNotifyResolved(MR, &Pair, 1UL)" leaks it.
#  641|   
#  642|     Pair = {TargetSym.Name, Sym};
#  643|->   LLVMOrcMaterializationResponsibilityNotifyResolved(MR, &Pair, 1);
#  644|   
#  645|     LLVMOrcMaterializationResponsibilityNotifyEmitted(MR);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:645: alloc_fn: Storage is returned from allocation function "LLVMOrcMaterializationResponsibilityNotifyEmitted".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:645: leaked_storage: Ignoring storage allocated by "LLVMOrcMaterializationResponsibilityNotifyEmitted(MR)" leaks it.
#  643|     LLVMOrcMaterializationResponsibilityNotifyResolved(MR, &Pair, 1);
#  644|   
#  645|->   LLVMOrcMaterializationResponsibilityNotifyEmitted(MR);
#  646|     LLVMOrcDisposeMaterializationResponsibility(MR);
#  647|   }

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:658: alloc_fn: Storage is returned from allocation function "LLVMOrcJITDylibDefine".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/OrcCAPITest.cpp:658: leaked_storage: Ignoring storage allocated by "LLVMOrcJITDylibDefine(JD, MU)" leaks it.
#  656|         "MU", (void *)Jit, &Sym, 1, NULL, &Materialize, NULL, &Destroy);
#  657|     LLVMOrcJITDylibRef JD = LLVMOrcLLJITGetMainJITDylib(Jit);
#  658|->   LLVMOrcJITDylibDefine(JD, MU);
#  659|   
#  660|     LLVMOrcJITTargetAddress Addr;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/ResourceTrackerTest.cpp:81: var_decl: Declaring variable "DstResources" without initializer.
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/ResourceTrackerTest.cpp:82: uninit_use_in_call: Using uninitialized value "DstResources" when calling "swap".
#   80|       auto &DstResourceRef = Resources[DstKey];
#   81|       ResourceT DstResources;
#   82|->     std::swap(DstResourceRef, DstResources);
#   83|   
#   84|       auto SI = Resources.find(SrcKey);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/SharedMemoryMapperTest.cpp:80: var_decl: Declaring variable "SI".
llvm-17.0.6.src/unittests/ExecutionEngine/Orc/SharedMemoryMapperTest.cpp:87: uninit_use_in_call: Using uninitialized value "SI". Field "SI.WorkingMem" is uninitialized when calling "push_back". [Note: The source code implementation of the function has been overridden by a builtin model.]
#   85|   
#   86|           AI.MappingBase = Reservation.Start;
#   87|->         AI.Segments.push_back(SI);
#   88|           AI.Actions.push_back(
#   89|               {cantFail(WrapperFunctionCall::Create<SPSArgList<SPSExecutorAddr>>(

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/IR/IRBuilderTest.cpp:959: var_decl: Declaring variable "Names".
llvm-17.0.6.src/unittests/IR/IRBuilderTest.cpp:971: uninit_use: Using uninitialized value "Names". Field "Names.InlineElts" is uninitialized.
#  969|         if (auto *MN = dyn_cast_or_null<DIMacro>(Node))
#  970|           Names.push_back(MN->getName());
#  971|->     return Names;
#  972|     };
#  973|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/IR/PatternMatch.cpp:1513: var_decl: Declaring variable "F32Pi".
llvm-17.0.6.src/unittests/IR/PatternMatch.cpp:1519: uninit_use_in_call: Using uninitialized value "F32Pi.U" when calling "get".
# 1517|     Constant *CF32NaN = ConstantFP::get(F32Ty, F32NaN);
# 1518|     Constant *CF32Zero = ConstantFP::get(F32Ty, F32Zero);
# 1519|->   Constant *CF32Pi = ConstantFP::get(F32Ty, F32Pi);
# 1520|   
# 1521|     EXPECT_TRUE(match(CF32NaN, cstfp_pred_ty<is_float_nan_pred>()));

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/MI/LiveIntervalTest.cpp:70: alloc_fn: Storage is returned from allocation function "operator new".
llvm-17.0.6.src/unittests/MI/LiveIntervalTest.cpp:70: var_assign: Assigning: "MMIWP" = storage returned from "new llvm::MachineModuleInfoWrapperPass(TM)".
llvm-17.0.6.src/unittests/MI/LiveIntervalTest.cpp:71: noescape: Resource "MMIWP" is not freed or pointed-to in "getMMI".
llvm-17.0.6.src/unittests/MI/LiveIntervalTest.cpp:72: leaked_storage: Variable "MMIWP" going out of scope leaks the storage it points to.
#   70|     MachineModuleInfoWrapperPass *MMIWP = new MachineModuleInfoWrapperPass(&TM);
#   71|     if (MIR->parseMachineFunctions(*M, MMIWP->getMMI()))
#   72|->     return nullptr;
#   73|     PM.add(MMIWP);
#   74|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Object/ELFObjectFileTest.cpp:774: var_decl: Declaring variable "FoundRela" without initializer.
llvm-17.0.6.src/unittests/Object/ELFObjectFileTest.cpp:792: uninit_use_in_call: Using uninitialized value "FoundRela" when calling "AssertionResult".
#  790|         EXPECT_EQ(TextSecName, ".text");
#  791|       }
#  792|->     ASSERT_TRUE(FoundRela);
#  793|     };
#  794|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ObjectYAML/DWARFYAMLTest.cpp:51: var_decl: Declaring variable "AddrTableEntry".
llvm-17.0.6.src/unittests/ObjectYAML/DWARFYAMLTest.cpp:52: uninit_use_in_call: Using uninitialized value "AddrTableEntry.Format" when calling "parseDWARFYAML".
llvm-17.0.6.src/unittests/ObjectYAML/DWARFYAMLTest.cpp:52: uninit_use_in_call: Using uninitialized value "AddrTableEntry.SegSelectorSize.value" when calling "parseDWARFYAML".
#   50|   )";
#   51|     DWARFYAML::AddrTableEntry AddrTableEntry;
#   52|->   EXPECT_THAT_ERROR(parseDWARFYAML(Yaml, AddrTableEntry),
#   53|                       FailedWithMessage("missing required key 'Version'"));
#   54|   }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ObjectYAML/DWARFYAMLTest.cpp:63: var_decl: Declaring variable "AddrTableEntry".
llvm-17.0.6.src/unittests/ObjectYAML/DWARFYAMLTest.cpp:64: uninit_use_in_call: Using uninitialized value "AddrTableEntry.Format" when calling "parseDWARFYAML".
llvm-17.0.6.src/unittests/ObjectYAML/DWARFYAMLTest.cpp:64: uninit_use_in_call: Using uninitialized value "AddrTableEntry.SegSelectorSize.value" when calling "parseDWARFYAML".
#   62|   )";
#   63|     DWARFYAML::AddrTableEntry AddrTableEntry;
#   64|->   EXPECT_THAT_ERROR(parseDWARFYAML(Yaml, AddrTableEntry),
#   65|                       FailedWithMessage("unknown key 'Blah'"));
#   66|   }

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:19: alloc_fn: Storage is returned from allocation function "LLVMGetDefaultTargetTriple".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:19: var_assign: Assigning: "Triple" = storage returned from "LLVMGetDefaultTargetTriple()".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:20: noescape: Resource "Triple" is not freed or pointed-to in "strlen".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:21: leaked_storage: Variable "Triple" going out of scope leaks the storage it points to.
#   19|       char *Triple = LLVMGetDefaultTargetTriple();
#   20|       if (strlen(Triple) == 0) {
#   21|->       GTEST_SKIP();
#   22|         LLVMDisposeMessage(Triple);
#   23|         return;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:73: alloc_fn: Storage is returned from allocation function "LLVMCreatePassBuilderOptions".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:73: var_assign: Assigning: "Options" = storage returned from "LLVMCreatePassBuilderOptions()".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:74: noescape: Resource "Options" is not freed or pointed-to in "LLVMRunPasses".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:75: noescape: Resource "Options" is not freed or pointed-to in "LLVMRunPasses".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:76: leaked_storage: Variable "Options" going out of scope leaks the storage it points to.
#   74|     LLVMErrorRef E1 = LLVMRunPasses(Module, "", TM, Options);
#   75|     LLVMErrorRef E2 = LLVMRunPasses(Module, "does-not-exist-pass", TM, Options);
#   76|->   ASSERT_TRUE(E1);
#   77|     ASSERT_TRUE(E2);
#   78|     LLVMConsumeError(E1);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:73: alloc_fn: Storage is returned from allocation function "LLVMCreatePassBuilderOptions".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:73: var_assign: Assigning: "Options" = storage returned from "LLVMCreatePassBuilderOptions()".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:74: noescape: Resource "Options" is not freed or pointed-to in "LLVMRunPasses".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:75: noescape: Resource "Options" is not freed or pointed-to in "LLVMRunPasses".
llvm-17.0.6.src/unittests/Passes/PassBuilderBindings/PassBuilderBindingsTest.cpp:77: leaked_storage: Variable "Options" going out of scope leaks the storage it points to.
#   75|     LLVMErrorRef E2 = LLVMRunPasses(Module, "does-not-exist-pass", TM, Options);
#   76|     ASSERT_TRUE(E1);
#   77|->   ASSERT_TRUE(E2);
#   78|     LLVMConsumeError(E1);
#   79|     LLVMConsumeError(E2);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ProfileData/CoverageMappingTest.cpp:27: var_decl: Declaring variable "Found" without initializer.
llvm-17.0.6.src/unittests/ProfileData/CoverageMappingTest.cpp:33: uninit_use: Using uninitialized value "Found".
#   31|       FoundMsg = CME.message();
#   32|     });
#   33|->   if (Expected == Found)
#   34|       return ::testing::AssertionSuccess();
#   35|     return ::testing::AssertionFailure() << "error: " << FoundMsg << "\n";

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ProfileData/InstrProfTest.cpp:31: var_decl: Declaring variable "Found" without initializer.
llvm-17.0.6.src/unittests/ProfileData/InstrProfTest.cpp:37: uninit_use: Using uninitialized value "Found".
#   35|       FoundMsg = IPE.message();
#   36|     });
#   37|->   if (Expected == Found)
#   38|       return ::testing::AssertionSuccess();
#   39|     return ::testing::AssertionFailure() << "error: " << FoundMsg << "\n";

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ProfileData/InstrProfTest.cpp:348: var_decl: Declaring variable "MR".
llvm-17.0.6.src/unittests/ProfileData/InstrProfTest.cpp:353: uninit_use: Using uninitialized value "MR". Field "MR.AllocSites.InlineElts" is uninitialized.
#  351|     for (const auto &Frames : CallSiteFrames)
#  352|       MR.CallSites.push_back(Frames);
#  353|->   return MR;
#  354|   }
#  355|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ProfileData/MemProfTest.cpp:87: var_decl: Declaring variable "Result".
llvm-17.0.6.src/unittests/ProfileData/MemProfTest.cpp:90: uninit_use: Using uninitialized value "Result". Field "Result.InlineElts" is uninitialized.
#   88|     // Mimic an entry for a non position independent executable.
#   89|     Result.emplace_back(0x0, 0x40000, 0x0);
#   90|->   return Result;
#   91|   }
#   92|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/ProfileData/MemProfTest.cpp:121: var_decl: Declaring variable "Schema".
llvm-17.0.6.src/unittests/ProfileData/MemProfTest.cpp:125: uninit_use: Using uninitialized value "Schema". Field "Schema.InlineElts" is uninitialized.
#  123|   #include "llvm/ProfileData/MIBEntryDef.inc"
#  124|   #undef MIBEntryDef
#  125|->   return Schema;
#  126|   }
#  127|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/Support/AllocatorTest.cpp:32: move: "Alloc" is moved (indicated by "std::move(Alloc)").
llvm-17.0.6.src/unittests/Support/AllocatorTest.cpp:33: use_after_move: "Alloc" is used after it has been already moved.
#   31|   
#   32|     BumpPtrAllocator Alloc2 = std::move(Alloc);
#   33|->   EXPECT_EQ(0U, Alloc.GetNumSlabs());
#   34|     EXPECT_EQ(1U, Alloc2.GetNumSlabs());
#   35|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/Support/AllocatorTest.cpp:43: move: "Alloc2" is moved (indicated by "std::move(Alloc2)").
llvm-17.0.6.src/unittests/Support/AllocatorTest.cpp:44: use_after_move: "Alloc2" is used after it has been already moved.
#   42|   
#   43|     Alloc = std::move(Alloc2);
#   44|->   EXPECT_EQ(0U, Alloc2.GetNumSlabs());
#   45|     EXPECT_EQ(1U, Alloc.GetNumSlabs());
#   46|   }

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/Casting.cpp:183: alloc_fn: Storage is returned from allocation function "release". [Note: The source code implementation of the function has been overridden by a builtin model.]
llvm-17.0.6.src/unittests/Support/Casting.cpp:183: leaked_storage: Ignoring storage allocated by "FP.release()" leaks it.
#  181|                   "Incorrect deduced return type!");
#  182|     EXPECT_NE(FP.get(), null_foo);
#  183|->   FP.release();
#  184|   }
#  185|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/unittests/Support/Casting.cpp:275: extract: Calling "get" which extracts wrapped state from local "D".
llvm-17.0.6.src/unittests/Support/Casting.cpp:275: assign: Assigning: "OrigD" = "D.get()".
llvm-17.0.6.src/unittests/Support/Casting.cpp:297: invalidate: Calling "operator =" invalidates the internal representation of local "D".
llvm-17.0.6.src/unittests/Support/Casting.cpp:298: use_after_free: Using invalidated internal representation of local "D".
#  296|     // nullptr;
#  297|     D = unique_dyn_cast<derived>(NewB);
#  298|->   ASSERT_EQ(OrigD, D.get());
#  299|     ASSERT_EQ(nullptr, NewB);
#  300|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Support/DivisionByConstantTest.cpp:78: var_decl: Declaring variable "Magics".
llvm-17.0.6.src/unittests/Support/DivisionByConstantTest.cpp:81: uninit_use_in_call: Using uninitialized value "Magics.ShiftAmount" when calling "SignedDivisionByConstantInfo".
#   79|         if (!(Divisor.isOne() || Divisor.isAllOnes()))
#   80|           Magics = SignedDivisionByConstantInfo::get(Divisor);
#   81|->       EnumerateAPInts(Bits, [Divisor, Magics, Bits](const APInt &Numerator) {
#   82|           if (Numerator.isMinSignedValue() && Divisor.isAllOnes())
#   83|             return; // Overflow is undefined behavior.

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/Support/FormatVariadicTest.cpp:678: move: "R" is moved (indicated by "std::move(R)").
llvm-17.0.6.src/unittests/Support/FormatVariadicTest.cpp:680: use_after_move: "R" is used after it has been already moved.
#  678|     EXPECT_EQ("0C 3M", formatv("{0}", std::move(R)).str());
#  679|     EXPECT_EQ("0C 3M", formatv("{0}", Recorder()).str());
#  680|->   EXPECT_EQ(0, R.Copied);
#  681|     EXPECT_EQ(0, R.Moved);
#  682|   }

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/Support/FormatVariadicTest.cpp:697: move: "E1" is moved (indicated by "std::move(E1)").
llvm-17.0.6.src/unittests/Support/FormatVariadicTest.cpp:698: use_after_move: "E1" is used after it has been already moved.
#  696|     EXPECT_TRUE(E1.isA<StringError>()); // not consumed
#  697|     EXPECT_EQ("X", formatv("{0}", fmt_consume(std::move(E1))).str());
#  698|->   EXPECT_FALSE(E1.isA<StringError>()); // consumed
#  699|   }
#  700|   

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/Support/Path.cpp:1429: move: "mfr" is moved (indicated by "std::move(mfr)").
llvm-17.0.6.src/unittests/Support/Path.cpp:1430: use_after_move: "mfr" is used after it has been already moved.
# 1428|       // Move it out of the scope and confirm mfr is reset.
# 1429|       MaybeMFR = std::move(mfr);
# 1430|->     EXPECT_FALSE(mfr);
# 1431|   #if !defined(NDEBUG) && GTEST_HAS_DEATH_TEST
# 1432|       EXPECT_DEATH(mfr.data(), "Mapping failed but used anyway!");

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/Path.cpp:1449: open_arg: "openFileForRead" opens handle stored into "FD".
llvm-17.0.6.src/unittests/Support/Path.cpp:1450: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
# 1448|       int FD;
# 1449|       EC = fs::openFileForRead(Twine(TempPath), FD);
# 1450|->     ASSERT_NO_ERROR(EC);
# 1451|       fs::mapped_file_region mfr(fs::convertFDToNativeFile(FD),
# 1452|                                  fs::mapped_file_region::readonly, Size, 0, EC);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/Path.cpp:1705: open_arg: "openFileForRead" opens handle stored into "FileDescriptor2".
llvm-17.0.6.src/unittests/Support/Path.cpp:1705: leaked_handle: Handle variable "FileDescriptor2" going out of scope leaks the handle.
# 1703|     int FileDescriptor2;
# 1704|     SmallString<64> ResultPath;
# 1705|->   ASSERT_NO_ERROR(fs::openFileForRead(Twine(TempPath), FileDescriptor2,
# 1706|                                         fs::OF_None, &ResultPath))
# 1707|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/Path.cpp:1923: open_arg: "openFileForRead" opens handle stored into "FD".
llvm-17.0.6.src/unittests/Support/Path.cpp:1923: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
# 1921|   
# 1922|     int FD;
# 1923|->   ASSERT_NO_ERROR(fs::openFileForRead(NonExistantFile, FD));
# 1924|     FileDescriptorCloser Closer(FD);
# 1925|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/Path.cpp:1947: open_arg: "openFileForReadWrite" opens handle stored into "FD".
llvm-17.0.6.src/unittests/Support/Path.cpp:1947: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
# 1945|   
# 1946|     int FD;
# 1947|->   ASSERT_NO_ERROR(fs::openFileForReadWrite(NonExistantFile, FD,
# 1948|                                              fs::CD_OpenExisting, fs::OF_None));
# 1949|     FileDescriptorCloser Closer(FD);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:373: open_arg: "openFileForRead" opens handle stored into "fd".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:373: leaked_handle: Handle variable "fd" going out of scope leaks the handle.
#  371|                                                sys::WEM_UTF16));
#  372|     int fd = 0;
#  373|->   ASSERT_NO_ERROR(fs::openFileForRead(file_pathname.c_str(), fd));
#  374|   #if defined(_WIN32)
#  375|     char buf[18];

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:427: open_arg: "openFileForReadWrite" opens handle stored into "FD2".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:427: leaked_handle: Handle variable "FD2" going out of scope leaks the handle.
#  425|       // Child process.
#  426|       int FD2;
#  427|->     ASSERT_NO_ERROR(fs::openFileForReadWrite(LockedFile, FD2,
#  428|                                                fs::CD_OpenExisting, fs::OF_None));
#  429|   

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:427: open_arg: "openFileForReadWrite" opens handle stored into "FD2".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:430: noescape: Resource "FD2" is not freed or pointed-to in "tryLockFile".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:431: leaked_handle: Handle variable "FD2" going out of scope leaks the handle.
#  429|   
#  430|       std::error_code ErrC = fs::tryLockFile(FD2, std::chrono::seconds(5));
#  431|->     ASSERT_NO_ERROR(ErrC);
#  432|       ASSERT_NO_ERROR(fs::unlockFile(FD2));
#  433|       close(FD2);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:427: open_arg: "openFileForReadWrite" opens handle stored into "FD2".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:430: noescape: Resource "FD2" is not freed or pointed-to in "tryLockFile".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:432: noescape: Resource "FD2" is not freed or pointed-to in "unlockFile".
llvm-17.0.6.src/unittests/Support/ProgramTest.cpp:432: leaked_handle: Handle variable "FD2" going out of scope leaks the handle.
#  430|       std::error_code ErrC = fs::tryLockFile(FD2, std::chrono::seconds(5));
#  431|       ASSERT_NO_ERROR(ErrC);
#  432|->     ASSERT_NO_ERROR(fs::unlockFile(FD2));
#  433|       close(FD2);
#  434|       exit(0);

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/Support/RegexTest.cpp:169: move: "r1" is moved (indicated by "std::move(r1)").
llvm-17.0.6.src/unittests/Support/RegexTest.cpp:172: use_after_move: "r1" is used after it has been already moved.
#  170|     EXPECT_TRUE(r2.match("916"));
#  171|     std::string Error;
#  172|->   EXPECT_FALSE(r1.isValid(Error));
#  173|   }
#  174|   

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/unittests/Support/TrailingObjectsTest.cpp:77: new_object: Calling single-object form of 'new': "new (Mem) <unnamed>::Class2(HasShort, HasDouble)".
llvm-17.0.6.src/unittests/Support/TrailingObjectsTest.cpp:77: assign: Assigning: "C" = "new (Mem) <unnamed>::Class2(HasShort, HasDouble)".
llvm-17.0.6.src/unittests/Support/TrailingObjectsTest.cpp:79: callee_ptr_arith: Passing "C" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#   77|       Class2 *C = new (Mem) Class2(HasShort, HasDouble);
#   78|       if (HasShort)
#   79|->       *C->getTrailingObjects<short>() = S;
#   80|       if (HasDouble)
#   81|         *C->getTrailingObjects<double>() = D;

Error: ARRAY_VS_SINGLETON (CWE-119):
llvm-17.0.6.src/unittests/Support/TrailingObjectsTest.cpp:77: new_object: Calling single-object form of 'new': "new (Mem) <unnamed>::Class2(HasShort, HasDouble)".
llvm-17.0.6.src/unittests/Support/TrailingObjectsTest.cpp:77: assign: Assigning: "C" = "new (Mem) <unnamed>::Class2(HasShort, HasDouble)".
llvm-17.0.6.src/unittests/Support/TrailingObjectsTest.cpp:81: callee_ptr_arith: Passing "C" to function "getTrailingObjects" which uses it as an array. This might corrupt or misinterpret adjacent memory locations.
#   79|         *C->getTrailingObjects<short>() = S;
#   80|       if (HasDouble)
#   81|->       *C->getTrailingObjects<double>() = D;
#   82|       return C;
#   83|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Support/YAMLIOTest.cpp:1782: var_decl: Declaring variable "num" without initializer.
llvm-17.0.6.src/unittests/Support/YAMLIOTest.cpp:1783: uninit_use_in_call: Using uninitialized value "num" when calling "mapRequired".
# 1781|       static void mappingFraction(IO &io, MyDouble &d) {
# 1782|           double num, denom;
# 1783|->         io.mapRequired("numerator",      num);
# 1784|           io.mapRequired("denominator",    denom);
# 1785|           // convert fraction to double

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Support/YAMLIOTest.cpp:1782: var_decl: Declaring variable "denom" without initializer.
llvm-17.0.6.src/unittests/Support/YAMLIOTest.cpp:1784: uninit_use_in_call: Using uninitialized value "denom" when calling "mapRequired".
# 1782|           double num, denom;
# 1783|           io.mapRequired("numerator",      num);
# 1784|->         io.mapRequired("denominator",    denom);
# 1785|           // convert fraction to double
# 1786|           d.value = num/denom;

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/Support/raw_pwrite_stream_test.cpp:62: open_arg: "openFileForRead" opens handle stored into "FD".
llvm-17.0.6.src/unittests/Support/raw_pwrite_stream_test.cpp:62: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
#   60|     if (ParentPath) {
#   61|       Path = ParentPath;
#   62|->     ASSERT_NO_ERROR(sys::fs::openFileForRead(Path, FD));
#   63|     } else {
#   64|       ASSERT_NO_ERROR(sys::fs::createTemporaryFile("foo", "bar", FD, Path));

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/unittests/TargetParser/Host.cpp:400: open_arg: "openFileForRead" opens handle stored into "FD".
llvm-17.0.6.src/unittests/TargetParser/Host.cpp:400: leaked_handle: Handle variable "FD" going out of scope leaks the handle.
#  398|   
#  399|       int FD = 0;
#  400|->     ASSERT_NO_ERROR(fs::openFileForRead(OutputPath, FD));
#  401|       Size = ::lseek(FD, 0, SEEK_END);
#  402|       ASSERT_NE(-1, Size);

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:60: var_decl: Declaring variable "AC".
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:61: uninit_use_in_call: Using uninitialized value "AC.IPOAmendableCB". Field "AC.IPOAmendableCB.callable" is uninitialized when calling "AttributorConfig".
#   59|     InformationCache InfoCache(M, AG, Allocator, nullptr);
#   60|     AttributorConfig AC(CGUpdater);
#   61|->   Attributor A(Functions, InfoCache, AC);
#   62|   
#   63|     Function *F = M.getFunction("foo");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:60: var_decl: Declaring variable "AC".
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:61: uninit_use_in_call: Using uninitialized value "AC.OREGetter". Field "AC.OREGetter.callable" is uninitialized when calling "AttributorConfig".
#   59|     InformationCache InfoCache(M, AG, Allocator, nullptr);
#   60|     AttributorConfig AC(CGUpdater);
#   61|->   Attributor A(Functions, InfoCache, AC);
#   62|   
#   63|     Function *F = M.getFunction("foo");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:155: var_decl: Declaring variable "AC".
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:157: uninit_use_in_call: Using uninitialized value "AC.IPOAmendableCB". Field "AC.IPOAmendableCB.callable" is uninitialized when calling "AttributorConfig".
#  155|     AttributorConfig AC(CGUpdater);
#  156|     AC.DeleteFns = false;
#  157|->   Attributor A(Functions, InfoCache, AC);
#  158|   
#  159|     Function &F1 = *M.getFunction("func1");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:155: var_decl: Declaring variable "AC".
llvm-17.0.6.src/unittests/Transforms/IPO/AttributorTest.cpp:157: uninit_use_in_call: Using uninitialized value "AC.OREGetter". Field "AC.OREGetter.callable" is uninitialized when calling "AttributorConfig".
#  155|     AttributorConfig AC(CGUpdater);
#  156|     AC.DeleteFns = false;
#  157|->   Attributor A(Functions, InfoCache, AC);
#  158|   
#  159|     Function &F1 = *M.getFunction("func1");

Error: UNINIT (CWE-457):
llvm-17.0.6.src/unittests/Transforms/Utils/FunctionComparatorTest.cpp:99: temporary: Creating temporary of type "llvm::APFloat" in "llvm::APFloat(2.)".
llvm-17.0.6.src/unittests/Transforms/Utils/FunctionComparatorTest.cpp:99: uninit_use_in_call: Using uninitialized value "<temporary>.U" when calling "~APFloat".
#   97|     int testCmpPrimitives() {
#   98|       beginCompare();
#   99|->     return
#  100|         cmpNumbers(2, 3) +
#  101|         cmpAPInts(APInt(32, 2), APInt(32, 3)) +

Error: USE_AFTER_MOVE (CWE-457):
llvm-17.0.6.src/unittests/XRay/ProfileTest.cpp:95: move: "P0" is moved (indicated by "std::move(P0)").
llvm-17.0.6.src/unittests/XRay/ProfileTest.cpp:109: use_after_move: "P0" is used after it has been already moved.
#  107|                                      Field(&Profile::Data::CumulativeLocalTime,
#  108|                                            Eq(100u)))))))));
#  109|->   EXPECT_THAT(P0, UnorderedElementsAre());
#  110|   }
#  111|   

Error: INTEGER_OVERFLOW (CWE-190):
llvm-17.0.6.src/utils/TableGen/CodeGenMapTable.cpp:543: underflow: The decrement operator on the unsigned variable "j" might result in an underflow.
llvm-17.0.6.src/utils/TableGen/CodeGenMapTable.cpp:541: overflow_sink: "j", which might have underflowed, is passed to "FieldValues[j]". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  539|         Init *CurVal = FieldValues[i];
#  540|         for (unsigned j = i+1; j < FieldValues.size(); j++) {
#  541|->         if (CurVal == FieldValues[j]) {
#  542|             FieldValues.erase(FieldValues.begin()+j);
#  543|             --j;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/utils/TableGen/CodeGenRegisters.cpp:491: var_decl: Declaring variable "Parts".
llvm-17.0.6.src/utils/TableGen/CodeGenRegisters.cpp:515: uninit_use_in_call: Using uninitialized value "Parts". Field "Parts.InlineElts" is uninitialized when calling "getConcatSubRegIndex".
#  513|         // Each part of Cand is a sub-register of this. Make the full Cand also
#  514|         // a sub-register with a concatenated sub-register index.
#  515|->       CodeGenSubRegIndex *Concat = RegBank.getConcatSubRegIndex(Parts);
#  516|         std::pair<CodeGenSubRegIndex*,CodeGenRegister*> NewSubReg =
#  517|             std::make_pair(Concat, Cand);

Error: RESOURCE_LEAK (CWE-772):
llvm-17.0.6.src/utils/TableGen/DAGISelMatcher.cpp:47: alloc_fn: Storage is returned from allocation function "takeNext".
llvm-17.0.6.src/utils/TableGen/DAGISelMatcher.cpp:47: leaked_storage: Ignoring storage allocated by "Cur->takeNext()" leaks it.
#   45|   
#   46|     if (!Cur) return nullptr;
#   47|->   Cur->takeNext();
#   48|     Cur->setNext(Other->takeNext());
#   49|     return this;

Error: UNINIT (CWE-457):
llvm-17.0.6.src/utils/TableGen/DFAEmitter.cpp:61: var_decl: Declaring variable "NewStates".
llvm-17.0.6.src/utils/TableGen/DFAEmitter.cpp:83: uninit_use_in_call: Using uninitialized value "NewStates". Field "NewStates.InlineElts" is uninitialized when calling "insert".
#   81|       sort(TI);
#   82|       TI.erase(std::unique(TI.begin(), TI.end()), TI.end());
#   83|->     unsigned ToId = DfaStates.insert(NewStates);
#   84|       DfaTransitions.emplace(std::make_pair(FromId, A), std::make_pair(ToId, TI));
#   85|     }

Error: UNINIT (CWE-457):
llvm-17.0.6.src/utils/TableGen/DFAPacketizerEmitter.cpp:178: var_decl: Declaring variable "Resources".
llvm-17.0.6.src/utils/TableGen/DFAPacketizerEmitter.cpp:188: uninit_use: Using uninitialized value "Resources". Field "Resources.InlineElts" is uninitialized.
#  186|         Resources.push_back(StageResources);
#  187|     }
#  188|->   return Resources;
#  189|   }
#  190|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/utils/TableGen/FastISelEmitter.cpp:152: var_decl: Declaring variable "Result".
llvm-17.0.6.src/utils/TableGen/FastISelEmitter.cpp:158: uninit_use: Using uninitialized value "Result". Field "Result.Operands.InlineElts" is uninitialized.
#  156|         else
#  157|           Result.Operands.push_back(OpKind::getImm(0));
#  158|->     return Result;
#  159|     }
#  160|   

Error: WRAPPER_ESCAPE (CWE-825):
llvm-17.0.6.src/utils/TableGen/GlobalISel/GIMatchTree.cpp:352: extract: Calling "get" which extracts wrapped state from local "TreeRoot".
llvm-17.0.6.src/utils/TableGen/GlobalISel/GIMatchTree.cpp:352: escape: The internal representation of local "TreeRoot" escapes into "this->TreeNode", but is destroyed when it exits scope.
#  350|   
#  351|     std::unique_ptr<GIMatchTree> TreeRoot = std::make_unique<GIMatchTree>();
#  352|->   TreeNode = TreeRoot.get();
#  353|     runStep();
#  354|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/utils/TableGen/X86DisassemblerTables.cpp:823: var_decl: Declaring variable "OperandList".
llvm-17.0.6.src/utils/TableGen/X86DisassemblerTables.cpp:830: uninit_use_in_call: Using uninitialized value "OperandList". Field "OperandList.InlineElts" is uninitialized when calling "operator []". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  828|         OperandList.push_back(std::make_pair(Encoding, Type));
#  829|       }
#  830|->     unsigned &N = OperandSets[OperandList];
#  831|       if (N != 0) continue;
#  832|   

Error: UNINIT (CWE-457):
llvm-17.0.6.src/utils/TableGen/X86DisassemblerTables.cpp:854: var_decl: Declaring variable "OperandList".
llvm-17.0.6.src/utils/TableGen/X86DisassemblerTables.cpp:860: uninit_use_in_call: Using uninitialized value "OperandList". Field "OperandList.InlineElts" is uninitialized when calling "operator []". [Note: The source code implementation of the function has been overridden by a builtin model.]
#  858|         OperandList.push_back(std::make_pair(Encoding, Type));
#  859|       }
#  860|->     o.indent(i * 2) << (OperandSets[OperandList] - 1) << ",\n";
#  861|   
#  862|       o.indent(i * 2) << "/* " << InstructionSpecifiers[index].name << " */\n";

Error: OVERRUN (CWE-119):
third-party/unittest/googlemock/src/gmock.cc:208: alias: Assigning: "argv" = "&argv0". "argv" now points to element 0 of "argv0" (which consists of 1 8-byte elements).
third-party/unittest/googlemock/src/gmock.cc:210: overrun-buffer-val: Overrunning buffer pointed to by "argv" of 1 8-byte elements by passing it to a function which accesses it at element index 2 (byte offset 23).
#  208|     char** argv = &argv0;
#  209|   
#  210|->   internal::InitGoogleMockImpl(&argc, argv);
#  211|   }
#  212|   

Error: CTOR_DTOR_LEAK (CWE-401):
third-party/unittest/googletest/src/gtest-port.cc:1075: alloc_fn: Calling allocation function "dup".
third-party/unittest/googletest/src/gtest-port.cc:1075: assign: Assigning: "this->uncaptured_fd_" = "dup(fd)".
third-party/unittest/googletest/src/gtest-port.cc:1075: ctor_dtor_leak: The constructor allocates field "uncaptured_fd_" of "testing::internal::CapturedStream" but the destructor and whatever functions it calls do not free it.
# 1073|    public:
# 1074|     // The ctor redirects the stream to a temporary file.
# 1075|->   explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) {
# 1076|   # if GTEST_OS_WINDOWS
# 1077|       char temp_dir_path[MAX_PATH + 1] = { '\0' };  // NOLINT

Error: OVERRUN (CWE-119):
third-party/unittest/googletest/src/gtest-port.cc:1214: return_constant: Function call "testing::internal::GetFileSize(file)" may return 18446744073709551615.
third-party/unittest/googletest/src/gtest-port.cc:1214: assignment: Assigning: "file_size" = "testing::internal::GetFileSize(file)". The value of "file_size" is now 18446744073709551615.
third-party/unittest/googletest/src/gtest-port.cc:1227: cond_at_least: Checking "bytes_read < file_size" implies that "bytes_read" is at least 18446744073709551615 on the false branch.
third-party/unittest/googletest/src/gtest-port.cc:1229: overrun-buffer-arg: Calling "basic_string" with "buffer" and "bytes_read" is suspicious because of the very large index, 18446744073709551615. The index may be due to a negative parameter being interpreted as unsigned. [Note: The source code implementation of the function has been overridden by a builtin model.]
# 1227|     } while (bytes_last_read > 0 && bytes_read < file_size);
# 1228|   
# 1229|->   const std::string content(buffer, bytes_read);
# 1230|     delete[] buffer;
# 1231|   

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/include/llvm/ADT/SmallVector.h:634: identical_branches: The same code is executed regardless of whether "false" is true, because the 'then' and 'else' branches are identical. Should one of the branches be modified, or the entire 'if' statement replaced?
#  632|       this->reserve(N);
#  633|       for (auto I = this->end(), E = this->begin() + N; I != E; ++I)
#  634|->       if (ForOverwrite)
#  635|           new (&*I) T;
#  636|         else

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Analysis/ValueTracking.cpp:4842: original: "KnownLHS.isKnownNeverLogicalNegZero(F, Op->getType())" looks like the original copy.
llvm-17.0.6.src/lib/Analysis/ValueTracking.cpp:4852: copy_paste_error: "isKnownNeverLogicalNegZero" in "KnownLHS.isKnownNeverLogicalNegZero(F, Op->getType())" looks like a copy-paste error.
llvm-17.0.6.src/lib/Analysis/ValueTracking.cpp:4852: remediation: Should it say "isKnownNeverLogicalPosZero" instead?
# 4850|   
# 4851|           // Only fsub -0, +0 can return -0
# 4852|->         if ((KnownLHS.isKnownNeverLogicalNegZero(*F, Op->getType()) ||
# 4853|                KnownRHS.isKnownNeverLogicalPosZero(*F, Op->getType())) &&
# 4854|               // Make sure output negative denormal can't flush to -0

Error: SNYK_CODE_WARNING (CWE-125):
llvm-17.0.6.src/lib/CodeGen/GlobalMerge.cpp:350:15: error[cpp/SizeAsIndex]: The size of the buffer from size is used as an array index. This value could be one larger than the last possible index of the array, causing a buffer overread or overwrite.
#  348|               CreateGlobalSet().Globals.set(GI);
#  349|             } else {
#  350|->             ++UsedGlobalSets[CurGVOnlySetIdx].UsageCount;
#  351|             }
#  352|   

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3860: original: "SUB" looks like the original copy.
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3846: copy_paste_error: "SUB" looks like a copy-paste error.
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3846: remediation: Should it say "ADD" instead?
# 3844|       SDValue N11 = N1.getOperand(1);
# 3845|       if (SDValue NewC = DAG.FoldConstantArithmetic(ISD::SUB, DL, VT, {N0, N11}))
# 3846|->       return DAG.getNode(ISD::SUB, DL, VT, NewC, N1.getOperand(0));
# 3847|     }
# 3848|   

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3957: original: "ADD" looks like the original copy.
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3963: copy_paste_error: "ADD" looks like a copy-paste error.
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:3963: remediation: Should it say "SUB" instead?
# 3961|     }
# 3962|     // y - (x + C)  ->  (y - x) - C
# 3963|->   if (N1.getOpcode() == ISD::ADD && N1.hasOneUse() &&
# 3964|         isConstantOrConstantVector(N1.getOperand(1), /*NoOpaques=*/true)) {
# 3965|       SDValue Sub = DAG.getNode(ISD::SUB, DL, VT, N0, N1.getOperand(0));

Error: UNEXPECTED_CONTROL_FLOW (CWE-398):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18182: continue_in_do_while_false: A "continue" statement within a "do ... while (...)" loop only continues execution of the loop body if the loop continuation condition is still true.  Since the condition will never be true in a "do ... while (false)" loop, the "continue"statement has the same effect as a "break" statement.  Did you intend execution to continue at the top of the loop?
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18196: do_while_false_condition: This loop will never continue since the condition "false" is never true.
#18180|     do {
#18181|       if (!getTruncatedStoreValue(ST, Val))
#18182|->       continue;
#18183|       if (!isTypeLegal(LDMemType))
#18184|         continue;

Error: UNEXPECTED_CONTROL_FLOW (CWE-398):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18184: continue_in_do_while_false: A "continue" statement within a "do ... while (...)" loop only continues execution of the loop body if the loop continuation condition is still true.  Since the condition will never be true in a "do ... while (false)" loop, the "continue"statement has the same effect as a "break" statement.  Did you intend execution to continue at the top of the loop?
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18196: do_while_false_condition: This loop will never continue since the condition "false" is never true.
#18182|         continue;
#18183|       if (!isTypeLegal(LDMemType))
#18184|->       continue;
#18185|       if (STMemType != LDMemType) {
#18186|         // TODO: Support vectors? This requires extract_subvector/bitcast.

Error: UNEXPECTED_CONTROL_FLOW (CWE-398):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18191: continue_in_do_while_false: A "continue" statement within a "do ... while (...)" loop only continues execution of the loop body if the loop continuation condition is still true.  Since the condition will never be true in a "do ... while (false)" loop, the "continue"statement has the same effect as a "break" statement.  Did you intend execution to continue at the top of the loop?
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18196: do_while_false_condition: This loop will never continue since the condition "false" is never true.
#18189|           Val = DAG.getNode(ISD::TRUNCATE, SDLoc(LD), LDMemType, Val);
#18190|         else
#18191|->         continue;
#18192|       }
#18193|       if (!extendLoadedValueToExtension(LD, Val))

Error: UNEXPECTED_CONTROL_FLOW (CWE-398):
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18194: continue_in_do_while_false: A "continue" statement within a "do ... while (...)" loop only continues execution of the loop body if the loop continuation condition is still true.  Since the condition will never be true in a "do ... while (false)" loop, the "continue"statement has the same effect as a "break" statement.  Did you intend execution to continue at the top of the loop?
llvm-17.0.6.src/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18196: do_while_false_condition: This loop will never continue since the condition "false" is never true.
#18192|       }
#18193|       if (!extendLoadedValueToExtension(LD, Val))
#18194|->       continue;
#18195|       return ReplaceLd(LD, Val, Chain);
#18196|     } while (false);

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:4828: original: "this->SelectMultiVectorMove(Node, 4U, ZAD0, MOVA_4ZMXI_H_D)" looks like the original copy.
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:4786: copy_paste_error: "SelectMultiVectorMove" in "this->SelectMultiVectorMove(Node, 2U, ZAD0, MOVA_2ZMXI_H_D)" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:4786: remediation: Should it say "SelectMultiVectorMove" instead?
# 4784|           return;
# 4785|         } else if (VT == MVT::nxv2i64 || VT == MVT::nxv2f64) {
# 4786|->         SelectMultiVectorMove<0, 2>(Node, 2, AArch64::ZAD0,
# 4787|                                       AArch64::MOVA_2ZMXI_H_D);
# 4788|           return;

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:18072: original: "CTVal->isOne() || CFVal->isOne()" looks like the original copy.
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:18074: copy_paste_error: "isOne" in "CTVal->isOne() || CFVal->isAllOnes()" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:18074: remediation: Should it say "isAllOnes" instead?
#18072|           (CTVal->isOne() || CFVal->isOne())) &&
#18073|         !(LHS.getOpcode() == AArch64ISD::CSNEG &&
#18074|->         (CTVal->isOne() || CFVal->isAllOnes())))
#18075|       return SDValue();
#18076|   

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:22871: original: "LHS" looks like the original copy.
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:22878: copy_paste_error: "LHS" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/AArch64/AArch64ISelLowering.cpp:22878: remediation: Should it say "RHS" instead?
#22876|                LHS.getOpcode() == ISD::TRUNCATE) {
#22877|       TruncHigh = LHS;
#22878|->     if (LHS.getOpcode() == ISD::BITCAST)
#22879|         ExtractHigh = RHS.getOperand(0);
#22880|       else

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:4447: original: "ssub" looks like the original copy.
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:4463: copy_paste_error: "ssub" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:4463: remediation: Should it say "hsub" instead?
# 4461|       } else if (EltSize == 32) {
# 4462|         Opc = AArch64::INSvi32lane;
# 4463|->       SubregIdx = AArch64::ssub;
# 4464|       } else if (EltSize == 64) {
# 4465|         Opc = AArch64::INSvi64lane;

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:10310: original: "LHS.getOperand(1U)" looks like the original copy.
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:10309: copy_paste_error: "LHS" in "RHS.getOperand(0U) == LHS.getOperand(0U)" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/AMDGPU/SIISelLowering.cpp:10309: remediation: Should it say "RHS" instead?
#10307|       const ConstantSDNode *Mask = dyn_cast<ConstantSDNode>(RHS.getOperand(1));
#10308|       if ((LCC == ISD::SETO || LCC == ISD::SETUO) && Mask &&
#10309|->         (RHS.getOperand(0) == LHS.getOperand(0) &&
#10310|            LHS.getOperand(0) == LHS.getOperand(1))) {
#10311|         const unsigned OrdMask = SIInstrFlags::S_NAN | SIInstrFlags::Q_NAN;

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/AMDGPU/SIModeRegister.cpp:73: original: "this->Mask & S.Mask" looks like the original copy.
llvm-17.0.6.src/lib/Target/AMDGPU/SIModeRegister.cpp:73: copy_paste_error: "Mask" in "this->Mode & S.Mask" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/AMDGPU/SIModeRegister.cpp:73: remediation: Should it say "Mode" instead?
#   71|   
#   72|     bool isCompatible(Status &S) {
#   73|->     return ((Mask & S.Mask) == S.Mask) && ((Mode & S.Mask) == S.Mode);
#   74|     }
#   75|   

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5811: identical_branches: Ternary expression on condition "target->isThumb()" has identical then and else expressions: "4". Should one of the expressions be modified, or the entire ternary expression replaced?
# 5809|   
# 5810|     OutlinerCosts(const ARMSubtarget &target)
# 5811|->       : CallTailCall(target.isThumb() ? 4 : 4),
# 5812|           FrameTailCall(target.isThumb() ? 0 : 0),
# 5813|           CallThunk(target.isThumb() ? 4 : 4),

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5812: identical_branches: Ternary expression on condition "target->isThumb()" has identical then and else expressions: "0". Should one of the expressions be modified, or the entire ternary expression replaced?
# 5810|     OutlinerCosts(const ARMSubtarget &target)
# 5811|         : CallTailCall(target.isThumb() ? 4 : 4),
# 5812|->         FrameTailCall(target.isThumb() ? 0 : 0),
# 5813|           CallThunk(target.isThumb() ? 4 : 4),
# 5814|           FrameThunk(target.isThumb() ? 0 : 0),

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5813: identical_branches: Ternary expression on condition "target->isThumb()" has identical then and else expressions: "4". Should one of the expressions be modified, or the entire ternary expression replaced?
# 5811|         : CallTailCall(target.isThumb() ? 4 : 4),
# 5812|           FrameTailCall(target.isThumb() ? 0 : 0),
# 5813|->         CallThunk(target.isThumb() ? 4 : 4),
# 5814|           FrameThunk(target.isThumb() ? 0 : 0),
# 5815|           CallNoLRSave(target.isThumb() ? 4 : 4),

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5814: identical_branches: Ternary expression on condition "target->isThumb()" has identical then and else expressions: "0". Should one of the expressions be modified, or the entire ternary expression replaced?
# 5812|           FrameTailCall(target.isThumb() ? 0 : 0),
# 5813|           CallThunk(target.isThumb() ? 4 : 4),
# 5814|->         FrameThunk(target.isThumb() ? 0 : 0),
# 5815|           CallNoLRSave(target.isThumb() ? 4 : 4),
# 5816|           FrameNoLRSave(target.isThumb() ? 2 : 4),

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5815: identical_branches: Ternary expression on condition "target->isThumb()" has identical then and else expressions: "4". Should one of the expressions be modified, or the entire ternary expression replaced?
# 5813|           CallThunk(target.isThumb() ? 4 : 4),
# 5814|           FrameThunk(target.isThumb() ? 0 : 0),
# 5815|->         CallNoLRSave(target.isThumb() ? 4 : 4),
# 5816|           FrameNoLRSave(target.isThumb() ? 2 : 4),
# 5817|           CallRegSave(target.isThumb() ? 8 : 12),

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:5821: identical_branches: Ternary expression on condition "target->isThumb()" has identical then and else expressions: "8". Should one of the expressions be modified, or the entire ternary expression replaced?
# 5819|           CallDefault(target.isThumb() ? 8 : 12),
# 5820|           FrameDefault(target.isThumb() ? 2 : 4),
# 5821|->         SaveRestoreLROnStack(target.isThumb() ? 8 : 8) {}
# 5822|   };
# 5823|   

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:6319: original: "MI->readsRegister(llvm::Register(LR), TRI)" looks like the original copy.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:6417: copy_paste_error: "readsRegister" in "MI->readsRegister(llvm::Register(ITSTATE), TRI)" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/ARM/ARMBaseInstrInfo.cpp:6417: remediation: Should it say "modifiesRegister" instead?
# 6415|   
# 6416|     // Be conservative with IT blocks.
# 6417|->   if (MI.readsRegister(ARM::ITSTATE, TRI) ||
# 6418|         MI.modifiesRegister(ARM::ITSTATE, TRI))
# 6419|       return outliner::InstrType::Illegal;

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:14907: original: "llvm::isNullConstant(CSInc.getOperand(1U))" looks like the original copy.
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:14912: copy_paste_error: "isNullConstant" in "llvm::isNullConstant(CSInc.getOperand(1U))" looks like a copy-paste error.
llvm-17.0.6.src/lib/Target/ARM/ARMISelLowering.cpp:14912: remediation: Should it say "isOneConstant" instead?
#14910|     }
#14911|     if (CSInc.getOpcode() == ARMISD::CMOV && isOneConstant(CSInc.getOperand(0)) &&
#14912|->       isNullConstant(CSInc.getOperand(1)) && CSInc->hasOneUse()) {
#14913|       CC = (ARMCC::CondCodes)CSInc.getConstantOperandVal(2);
#14914|       return CSInc.getOperand(4);

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3454: original: "llvm::BinaryOperator::CreateOr(Op0, A, llvm::Twine const(""))" looks like the original copy.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3432: copy_paste_error: "Op0" in "llvm::BinaryOperator::CreateOr(Op0, C, llvm::Twine const(""))" looks like a copy-paste error.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:3432: remediation: Should it say "Op1" instead?
# 3430|     // B | ((A & B) ^ C) -> B | C
# 3431|     if (match(Op1, m_c_Xor(m_c_And(m_Value(A), m_Specific(Op0)), m_Value(C))))
# 3432|->     return BinaryOperator::CreateOr(Op0, C);
# 3433|   
# 3434|     // ((B | C) & A) | B -> B | (A & C)

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCalls.cpp:2255: original: "this->replaceOperand(II, 0U, X)" looks like the original copy.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCalls.cpp:2247: copy_paste_error: "X" in "this->replaceOperand(II, 0U, X)" looks like a copy-paste error.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineCalls.cpp:2247: remediation: Should it say "Y" instead?
# 2245|       Value *X, *Y;
# 2246|       if (match(Src0, m_FNeg(m_Value(X))) && match(Src1, m_FNeg(m_Value(Y)))) {
# 2247|->       replaceOperand(*II, 0, X);
# 2248|         replaceOperand(*II, 1, Y);
# 2249|         return II;

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineSelect.cpp:2292: original: "SI->getFalseValue()" looks like the original copy.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineSelect.cpp:2299: copy_paste_error: "getFalseValue" in "SI->getFalseValue()" looks like a copy-paste error.
llvm-17.0.6.src/lib/Transforms/InstCombine/InstCombineSelect.cpp:2299: remediation: Should it say "getTrueValue" instead?
# 2297|     if (auto *X = isExtractFromCmpXchg(SI.getFalseValue(), 0))
# 2298|       if (X == CmpXchg && X->getCompareOperand() == SI.getTrueValue())
# 2299|->       return SI.getFalseValue();
# 2300|   
# 2301|     return nullptr;

Error: COPY_PASTE_ERROR (CWE-398):
llvm-17.0.6.src/lib/Transforms/Scalar/EarlyCSE.cpp:1007: original: "masked_store" looks like the original copy.
llvm-17.0.6.src/lib/Transforms/Scalar/EarlyCSE.cpp:1001: copy_paste_error: "masked_store" looks like a copy-paste error.
llvm-17.0.6.src/lib/Transforms/Scalar/EarlyCSE.cpp:1001: remediation: Should it say "masked_load" instead?
#  999|         return isa<UndefValue>(ThruOp(Later));
# 1000|       }
# 1001|->     if (IDE == Intrinsic::masked_load && IDL == Intrinsic::masked_store) {
# 1002|         // Trying to remove a store of the loaded value.
# 1003|         // Check that the pointers are the same, and

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40437: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40435: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#40433|     case 34: // WriteLDIdx_ReadAdrBase
#40434|       if (CPUID == 1) { // A64FXModel
#40435|->       if (AArch64_MC::isScaledAddr(*MI))
#40436|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#40437|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40447: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40445: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#40443|       }
#40444|       if (CPUID == 9) { // ExynosM3Model
#40445|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#40446|           return 1620; // WriteLDIdx_ReadDefault
#40447|         return 1620; // WriteLDIdx_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40571: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40569: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#40567|     case 43: // WriteSTIdx_ReadST_ReadAdrBase
#40568|       if (CPUID == 1) { // A64FXModel
#40569|->       if (AArch64_MC::isScaledAddr(*MI))
#40570|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#40571|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40581: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40579: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#40577|       }
#40578|       if (CPUID == 9) { // ExynosM3Model
#40579|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#40580|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#40581|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40618: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40616: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#40614|       }
#40615|       if (CPUID == 18) { // ThunderX2T99Model
#40616|->       if (AArch64_MC::isScaledAddr(*MI))
#40617|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#40618|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40623: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:40621: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#40619|       }
#40620|       if (CPUID == 19) { // ThunderX3T110Model
#40621|->       if (AArch64_MC::isScaledAddr(*MI))
#40622|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#40623|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41082: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41080: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41078|     case 653: // LDRBroW
#41079|       if (CPUID == 1) { // A64FXModel
#41080|->       if (AArch64_MC::isScaledAddr(*MI))
#41081|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41082|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41092: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41090: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41088|       }
#41089|       if (CPUID == 9) { // ExynosM3Model
#41090|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41091|           return 1699; // M3WriteLE_ReadDefault
#41092|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41100: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41095: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41093|       }
#41094|       if (CPUID == 10) { // ExynosM4Model
#41095|->       if ((
#41096|               AArch64_MC::isScaledAddr(*MI)
#41097|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41108: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41103: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41101|       }
#41102|       if (CPUID == 11) { // ExynosM5Model
#41103|->       if ((
#41104|               AArch64_MC::isScaledAddr(*MI)
#41105|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41127: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41125: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41123|       }
#41124|       if (CPUID == 18) { // ThunderX2T99Model
#41125|->       if (AArch64_MC::isScaledAddr(*MI))
#41126|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41127|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41132: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41130: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41128|       }
#41129|       if (CPUID == 19) { // ThunderX3T110Model
#41130|->       if (AArch64_MC::isScaledAddr(*MI))
#41131|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41132|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41139: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41137: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41135|     case 654: // LDRBroX
#41136|       if (CPUID == 1) { // A64FXModel
#41137|->       if (AArch64_MC::isScaledAddr(*MI))
#41138|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41139|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41149: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41147: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41145|       }
#41146|       if (CPUID == 9) { // ExynosM3Model
#41147|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41148|           return 1706; // WriteVLD_ReadDefault
#41149|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41157: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41152: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41150|       }
#41151|       if (CPUID == 10) { // ExynosM4Model
#41152|->       if ((
#41153|               AArch64_MC::isScaledAddr(*MI)
#41154|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41165: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41160: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41158|       }
#41159|       if (CPUID == 11) { // ExynosM5Model
#41160|->       if ((
#41161|               AArch64_MC::isScaledAddr(*MI)
#41162|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41184: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41182: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41180|       }
#41181|       if (CPUID == 18) { // ThunderX2T99Model
#41182|->       if (AArch64_MC::isScaledAddr(*MI))
#41183|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41184|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41189: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41187: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41185|       }
#41186|       if (CPUID == 19) { // ThunderX3T110Model
#41187|->       if (AArch64_MC::isScaledAddr(*MI))
#41188|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41189|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41196: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41194: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41192|     case 659: // LDRDroW
#41193|       if (CPUID == 1) { // A64FXModel
#41194|->       if (AArch64_MC::isScaledAddr(*MI))
#41195|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41196|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41206: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41204: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41202|       }
#41203|       if (CPUID == 9) { // ExynosM3Model
#41204|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41205|           return 1699; // M3WriteLE_ReadDefault
#41206|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41214: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41209: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41207|       }
#41208|       if (CPUID == 10) { // ExynosM4Model
#41209|->       if ((
#41210|               AArch64_MC::isScaledAddr(*MI)
#41211|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41222: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41217: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41215|       }
#41216|       if (CPUID == 11) { // ExynosM5Model
#41217|->       if ((
#41218|               AArch64_MC::isScaledAddr(*MI)
#41219|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41241: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41239: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41237|       }
#41238|       if (CPUID == 18) { // ThunderX2T99Model
#41239|->       if (AArch64_MC::isScaledAddr(*MI))
#41240|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41241|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41246: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41244: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41242|       }
#41243|       if (CPUID == 19) { // ThunderX3T110Model
#41244|->       if (AArch64_MC::isScaledAddr(*MI))
#41245|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41246|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41253: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41251: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41249|     case 660: // LDRDroX
#41250|       if (CPUID == 1) { // A64FXModel
#41251|->       if (AArch64_MC::isScaledAddr(*MI))
#41252|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41253|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41263: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41261: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41259|       }
#41260|       if (CPUID == 9) { // ExynosM3Model
#41261|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41262|           return 1706; // WriteVLD_ReadDefault
#41263|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41271: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41266: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41264|       }
#41265|       if (CPUID == 10) { // ExynosM4Model
#41266|->       if ((
#41267|               AArch64_MC::isScaledAddr(*MI)
#41268|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41279: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41274: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41272|       }
#41273|       if (CPUID == 11) { // ExynosM5Model
#41274|->       if ((
#41275|               AArch64_MC::isScaledAddr(*MI)
#41276|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41298: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41296: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41294|       }
#41295|       if (CPUID == 18) { // ThunderX2T99Model
#41296|->       if (AArch64_MC::isScaledAddr(*MI))
#41297|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41298|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41303: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41301: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41299|       }
#41300|       if (CPUID == 19) { // ThunderX3T110Model
#41301|->       if (AArch64_MC::isScaledAddr(*MI))
#41302|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41303|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41310: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41308: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41306|     case 662: // LDRHHroW
#41307|       if (CPUID == 1) { // A64FXModel
#41308|->       if (AArch64_MC::isScaledAddr(*MI))
#41309|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41310|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41320: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41318: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41316|       }
#41317|       if (CPUID == 9) { // ExynosM3Model
#41318|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41319|           return 1707; // M3WriteLB_ReadDefault
#41320|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41328: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41323: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41321|       }
#41322|       if (CPUID == 10) { // ExynosM4Model
#41323|->       if ((
#41324|               AArch64_MC::isScaledAddr(*MI)
#41325|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41336: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41331: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41329|       }
#41330|       if (CPUID == 11) { // ExynosM5Model
#41331|->       if ((
#41332|               AArch64_MC::isScaledAddr(*MI)
#41333|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41344: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41342: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41340|       }
#41341|       if (CPUID == 18) { // ThunderX2T99Model
#41342|->       if (AArch64_MC::isScaledAddr(*MI))
#41343|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41344|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41349: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41347: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41345|       }
#41346|       if (CPUID == 19) { // ThunderX3T110Model
#41347|->       if (AArch64_MC::isScaledAddr(*MI))
#41348|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41349|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41356: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41354: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41352|     case 663: // LDRHHroX
#41353|       if (CPUID == 1) { // A64FXModel
#41354|->       if (AArch64_MC::isScaledAddr(*MI))
#41355|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41356|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41406: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41404: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41402|       }
#41403|       if (CPUID == 18) { // ThunderX2T99Model
#41404|->       if (AArch64_MC::isScaledAddr(*MI))
#41405|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41406|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41411: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41409: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41407|       }
#41408|       if (CPUID == 19) { // ThunderX3T110Model
#41409|->       if (AArch64_MC::isScaledAddr(*MI))
#41410|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41411|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41418: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41416: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41414|     case 666: // LDRHroW
#41415|       if (CPUID == 1) { // A64FXModel
#41416|->       if (AArch64_MC::isScaledAddr(*MI))
#41417|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41418|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41428: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41426: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41424|       }
#41425|       if (CPUID == 9) { // ExynosM3Model
#41426|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41427|           return 1699; // M3WriteLE_ReadDefault
#41428|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41436: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41431: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41429|       }
#41430|       if (CPUID == 10) { // ExynosM4Model
#41431|->       if ((
#41432|               AArch64_MC::isScaledAddr(*MI)
#41433|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41444: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41439: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41437|       }
#41438|       if (CPUID == 11) { // ExynosM5Model
#41439|->       if ((
#41440|               AArch64_MC::isScaledAddr(*MI)
#41441|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41463: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41461: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41459|       }
#41460|       if (CPUID == 18) { // ThunderX2T99Model
#41461|->       if (AArch64_MC::isScaledAddr(*MI))
#41462|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41463|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41468: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41466: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41464|       }
#41465|       if (CPUID == 19) { // ThunderX3T110Model
#41466|->       if (AArch64_MC::isScaledAddr(*MI))
#41467|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41468|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41475: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41473: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41471|     case 667: // LDRHroX
#41472|       if (CPUID == 1) { // A64FXModel
#41473|->       if (AArch64_MC::isScaledAddr(*MI))
#41474|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41475|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41485: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41483: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41481|       }
#41482|       if (CPUID == 9) { // ExynosM3Model
#41483|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41484|           return 1706; // WriteVLD_ReadDefault
#41485|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41493: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41488: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41486|       }
#41487|       if (CPUID == 10) { // ExynosM4Model
#41488|->       if ((
#41489|               AArch64_MC::isScaledAddr(*MI)
#41490|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41501: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41496: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41494|       }
#41495|       if (CPUID == 11) { // ExynosM5Model
#41496|->       if ((
#41497|               AArch64_MC::isScaledAddr(*MI)
#41498|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41520: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41518: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41516|       }
#41517|       if (CPUID == 18) { // ThunderX2T99Model
#41518|->       if (AArch64_MC::isScaledAddr(*MI))
#41519|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41520|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41525: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41523: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41521|       }
#41522|       if (CPUID == 19) { // ThunderX3T110Model
#41523|->       if (AArch64_MC::isScaledAddr(*MI))
#41524|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41525|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41532: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41530: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41528|     case 672: // LDRQroW
#41529|       if (CPUID == 1) { // A64FXModel
#41530|->       if (AArch64_MC::isScaledAddr(*MI))
#41531|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41532|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41550: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41545: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41543|       }
#41544|       if (CPUID == 10) { // ExynosM4Model
#41545|->       if ((
#41546|               AArch64_MC::isScaledAddr(*MI)
#41547|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41558: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41553: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41551|       }
#41552|       if (CPUID == 11) { // ExynosM5Model
#41553|->       if ((
#41554|               AArch64_MC::isScaledAddr(*MI)
#41555|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41577: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41575: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41573|       }
#41574|       if (CPUID == 18) { // ThunderX2T99Model
#41575|->       if (AArch64_MC::isScaledAddr(*MI))
#41576|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41577|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41582: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41580: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41578|       }
#41579|       if (CPUID == 19) { // ThunderX3T110Model
#41580|->       if (AArch64_MC::isScaledAddr(*MI))
#41581|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41582|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41589: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41587: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41585|     case 673: // LDRQroX
#41586|       if (CPUID == 1) { // A64FXModel
#41587|->       if (AArch64_MC::isScaledAddr(*MI))
#41588|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41589|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41650: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41648: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41646|       }
#41647|       if (CPUID == 18) { // ThunderX2T99Model
#41648|->       if (AArch64_MC::isScaledAddr(*MI))
#41649|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41650|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41655: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41653: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41651|       }
#41652|       if (CPUID == 19) { // ThunderX3T110Model
#41653|->       if (AArch64_MC::isScaledAddr(*MI))
#41654|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41655|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41662: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41660: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41658|     case 675: // LDRSHWroW
#41659|       if (CPUID == 1) { // A64FXModel
#41660|->       if (AArch64_MC::isScaledAddr(*MI))
#41661|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41662|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41672: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41670: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41668|       }
#41669|       if (CPUID == 9) { // ExynosM3Model
#41670|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41671|           return 1707; // M3WriteLB_ReadDefault
#41672|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41680: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41675: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41673|       }
#41674|       if (CPUID == 10) { // ExynosM4Model
#41675|->       if ((
#41676|               AArch64_MC::isScaledAddr(*MI)
#41677|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41688: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41683: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41681|       }
#41682|       if (CPUID == 11) { // ExynosM5Model
#41683|->       if ((
#41684|               AArch64_MC::isScaledAddr(*MI)
#41685|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41696: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41694: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41692|       }
#41693|       if (CPUID == 18) { // ThunderX2T99Model
#41694|->       if (AArch64_MC::isScaledAddr(*MI))
#41695|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41696|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41701: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41699: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41697|       }
#41698|       if (CPUID == 19) { // ThunderX3T110Model
#41699|->       if (AArch64_MC::isScaledAddr(*MI))
#41700|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41701|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41708: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41706: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41704|     case 676: // LDRSHWroX
#41705|       if (CPUID == 1) { // A64FXModel
#41706|->       if (AArch64_MC::isScaledAddr(*MI))
#41707|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41708|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41758: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41756: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41754|       }
#41755|       if (CPUID == 18) { // ThunderX2T99Model
#41756|->       if (AArch64_MC::isScaledAddr(*MI))
#41757|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41758|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41763: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41761: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41759|       }
#41760|       if (CPUID == 19) { // ThunderX3T110Model
#41761|->       if (AArch64_MC::isScaledAddr(*MI))
#41762|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41763|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41770: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41768: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41766|     case 677: // LDRSHXroW
#41767|       if (CPUID == 1) { // A64FXModel
#41768|->       if (AArch64_MC::isScaledAddr(*MI))
#41769|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41770|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41780: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41778: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41776|       }
#41777|       if (CPUID == 9) { // ExynosM3Model
#41778|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41779|           return 1707; // M3WriteLB_ReadDefault
#41780|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41788: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41783: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41781|       }
#41782|       if (CPUID == 10) { // ExynosM4Model
#41783|->       if ((
#41784|               AArch64_MC::isScaledAddr(*MI)
#41785|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41796: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41791: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41789|       }
#41790|       if (CPUID == 11) { // ExynosM5Model
#41791|->       if ((
#41792|               AArch64_MC::isScaledAddr(*MI)
#41793|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41804: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41802: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41800|       }
#41801|       if (CPUID == 18) { // ThunderX2T99Model
#41802|->       if (AArch64_MC::isScaledAddr(*MI))
#41803|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41804|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41809: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41807: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41805|       }
#41806|       if (CPUID == 19) { // ThunderX3T110Model
#41807|->       if (AArch64_MC::isScaledAddr(*MI))
#41808|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41809|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41816: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41814: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41812|     case 678: // LDRSHXroX
#41813|       if (CPUID == 1) { // A64FXModel
#41814|->       if (AArch64_MC::isScaledAddr(*MI))
#41815|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41816|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41866: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41864: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41862|       }
#41863|       if (CPUID == 18) { // ThunderX2T99Model
#41864|->       if (AArch64_MC::isScaledAddr(*MI))
#41865|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41866|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41871: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41869: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41867|       }
#41868|       if (CPUID == 19) { // ThunderX3T110Model
#41869|->       if (AArch64_MC::isScaledAddr(*MI))
#41870|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41871|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41878: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41876: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41874|     case 682: // LDRSroW
#41875|       if (CPUID == 1) { // A64FXModel
#41876|->       if (AArch64_MC::isScaledAddr(*MI))
#41877|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41878|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41888: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41886: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41884|       }
#41885|       if (CPUID == 9) { // ExynosM3Model
#41886|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41887|           return 1699; // M3WriteLE_ReadDefault
#41888|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41896: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41891: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41889|       }
#41890|       if (CPUID == 10) { // ExynosM4Model
#41891|->       if ((
#41892|               AArch64_MC::isScaledAddr(*MI)
#41893|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41904: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41899: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41897|       }
#41898|       if (CPUID == 11) { // ExynosM5Model
#41899|->       if ((
#41900|               AArch64_MC::isScaledAddr(*MI)
#41901|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41923: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41921: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41919|       }
#41920|       if (CPUID == 18) { // ThunderX2T99Model
#41921|->       if (AArch64_MC::isScaledAddr(*MI))
#41922|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41923|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41928: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41926: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41924|       }
#41925|       if (CPUID == 19) { // ThunderX3T110Model
#41926|->       if (AArch64_MC::isScaledAddr(*MI))
#41927|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41928|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41935: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41933: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41931|     case 683: // LDRSroX
#41932|       if (CPUID == 1) { // A64FXModel
#41933|->       if (AArch64_MC::isScaledAddr(*MI))
#41934|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#41935|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41945: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41943: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41941|       }
#41942|       if (CPUID == 9) { // ExynosM3Model
#41943|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#41944|           return 1706; // WriteVLD_ReadDefault
#41945|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41953: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41948: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41946|       }
#41947|       if (CPUID == 10) { // ExynosM4Model
#41948|->       if ((
#41949|               AArch64_MC::isScaledAddr(*MI)
#41950|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41961: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41956: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41954|       }
#41955|       if (CPUID == 11) { // ExynosM5Model
#41956|->       if ((
#41957|               AArch64_MC::isScaledAddr(*MI)
#41958|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41980: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41978: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41976|       }
#41977|       if (CPUID == 18) { // ThunderX2T99Model
#41978|->       if (AArch64_MC::isScaledAddr(*MI))
#41979|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#41980|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41985: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41983: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41981|       }
#41982|       if (CPUID == 19) { // ThunderX3T110Model
#41983|->       if (AArch64_MC::isScaledAddr(*MI))
#41984|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#41985|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41992: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:41990: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41988|     case 710: // STRBroW
#41989|       if (CPUID == 1) { // A64FXModel
#41990|->       if (AArch64_MC::isScaledAddr(*MI))
#41991|           return 1719; // A64FXWrite_STUR_ReadDefault
#41992|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42002: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42000: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#41998|       }
#41999|       if (CPUID == 9) { // ExynosM3Model
#42000|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42001|           return 1715; // M3WriteSA_ReadDefault
#42002|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42010: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42005: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42003|       }
#42004|       if (CPUID == 10) { // ExynosM4Model
#42005|->       if ((
#42006|               AArch64_MC::isScaledAddr(*MI)
#42007|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42018: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42013: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42011|       }
#42012|       if (CPUID == 11) { // ExynosM5Model
#42013|->       if ((
#42014|               AArch64_MC::isScaledAddr(*MI)
#42015|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42037: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42035: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42033|       }
#42034|       if (CPUID == 18) { // ThunderX2T99Model
#42035|->       if (AArch64_MC::isScaledAddr(*MI))
#42036|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42037|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42042: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42040: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42038|       }
#42039|       if (CPUID == 19) { // ThunderX3T110Model
#42040|->       if (AArch64_MC::isScaledAddr(*MI))
#42041|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42042|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42049: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42047: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42045|     case 711: // STRBroX
#42046|       if (CPUID == 1) { // A64FXModel
#42047|->       if (AArch64_MC::isScaledAddr(*MI))
#42048|           return 1719; // A64FXWrite_STUR_ReadDefault
#42049|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42059: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42057: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42055|       }
#42056|       if (CPUID == 9) { // ExynosM3Model
#42057|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42058|           return 1717; // WriteVST_ReadDefault
#42059|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42067: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42062: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42060|       }
#42061|       if (CPUID == 10) { // ExynosM4Model
#42062|->       if ((
#42063|               AArch64_MC::isScaledAddr(*MI)
#42064|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42075: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42070: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42068|       }
#42069|       if (CPUID == 11) { // ExynosM5Model
#42070|->       if ((
#42071|               AArch64_MC::isScaledAddr(*MI)
#42072|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42094: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42092: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42090|       }
#42091|       if (CPUID == 18) { // ThunderX2T99Model
#42092|->       if (AArch64_MC::isScaledAddr(*MI))
#42093|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42094|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42099: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42097: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42095|       }
#42096|       if (CPUID == 19) { // ThunderX3T110Model
#42097|->       if (AArch64_MC::isScaledAddr(*MI))
#42098|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42099|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42106: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42104: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42102|     case 716: // STRHHroW
#42103|       if (CPUID == 1) { // A64FXModel
#42104|->       if (AArch64_MC::isScaledAddr(*MI))
#42105|           return 1719; // A64FXWrite_STUR_ReadDefault
#42106|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42116: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42114: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42112|       }
#42113|       if (CPUID == 9) { // ExynosM3Model
#42114|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42115|           return 1725; // M3WriteSB_ReadDefault
#42116|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42124: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42119: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42117|       }
#42118|       if (CPUID == 10) { // ExynosM4Model
#42119|->       if ((
#42120|               AArch64_MC::isScaledAddr(*MI)
#42121|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42132: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42127: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42125|       }
#42126|       if (CPUID == 11) { // ExynosM5Model
#42127|->       if ((
#42128|               AArch64_MC::isScaledAddr(*MI)
#42129|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42140: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42138: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42136|       }
#42137|       if (CPUID == 18) { // ThunderX2T99Model
#42138|->       if (AArch64_MC::isScaledAddr(*MI))
#42139|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42140|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42145: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42143: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42141|       }
#42142|       if (CPUID == 19) { // ThunderX3T110Model
#42143|->       if (AArch64_MC::isScaledAddr(*MI))
#42144|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42145|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42152: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42150: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42148|     case 717: // STRHHroX
#42149|       if (CPUID == 1) { // A64FXModel
#42150|->       if (AArch64_MC::isScaledAddr(*MI))
#42151|           return 1719; // A64FXWrite_STUR_ReadDefault
#42152|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42162: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42160: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42158|       }
#42159|       if (CPUID == 9) { // ExynosM3Model
#42160|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42161|           return 1728; // WriteST_ReadDefault
#42162|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42170: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42165: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42163|       }
#42164|       if (CPUID == 10) { // ExynosM4Model
#42165|->       if ((
#42166|               AArch64_MC::isScaledAddr(*MI)
#42167|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42178: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42173: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42171|       }
#42172|       if (CPUID == 11) { // ExynosM5Model
#42173|->       if ((
#42174|               AArch64_MC::isScaledAddr(*MI)
#42175|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42186: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42184: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42182|       }
#42183|       if (CPUID == 18) { // ThunderX2T99Model
#42184|->       if (AArch64_MC::isScaledAddr(*MI))
#42185|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42186|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42191: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42189: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42187|       }
#42188|       if (CPUID == 19) { // ThunderX3T110Model
#42189|->       if (AArch64_MC::isScaledAddr(*MI))
#42190|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42191|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42198: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42196: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42194|     case 720: // STRHroW
#42195|       if (CPUID == 1) { // A64FXModel
#42196|->       if (AArch64_MC::isScaledAddr(*MI))
#42197|           return 1719; // A64FXWrite_STUR_ReadDefault
#42198|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42208: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42206: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42204|       }
#42205|       if (CPUID == 9) { // ExynosM3Model
#42206|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42207|           return 1715; // M3WriteSA_ReadDefault
#42208|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42216: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42211: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42209|       }
#42210|       if (CPUID == 10) { // ExynosM4Model
#42211|->       if ((
#42212|               AArch64_MC::isScaledAddr(*MI)
#42213|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42224: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42219: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42217|       }
#42218|       if (CPUID == 11) { // ExynosM5Model
#42219|->       if ((
#42220|               AArch64_MC::isScaledAddr(*MI)
#42221|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42243: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42241: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42239|       }
#42240|       if (CPUID == 18) { // ThunderX2T99Model
#42241|->       if (AArch64_MC::isScaledAddr(*MI))
#42242|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42243|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42248: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42246: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42244|       }
#42245|       if (CPUID == 19) { // ThunderX3T110Model
#42246|->       if (AArch64_MC::isScaledAddr(*MI))
#42247|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42248|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42255: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42253: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42251|     case 721: // STRHroX
#42252|       if (CPUID == 1) { // A64FXModel
#42253|->       if (AArch64_MC::isScaledAddr(*MI))
#42254|           return 1719; // A64FXWrite_STUR_ReadDefault
#42255|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42265: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42263: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42261|       }
#42262|       if (CPUID == 9) { // ExynosM3Model
#42263|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42264|           return 1717; // WriteVST_ReadDefault
#42265|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42273: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42268: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42266|       }
#42267|       if (CPUID == 10) { // ExynosM4Model
#42268|->       if ((
#42269|               AArch64_MC::isScaledAddr(*MI)
#42270|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42281: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42276: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42274|       }
#42275|       if (CPUID == 11) { // ExynosM5Model
#42276|->       if ((
#42277|               AArch64_MC::isScaledAddr(*MI)
#42278|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42300: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42298: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42296|       }
#42297|       if (CPUID == 18) { // ThunderX2T99Model
#42298|->       if (AArch64_MC::isScaledAddr(*MI))
#42299|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42300|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42305: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42303: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42301|       }
#42302|       if (CPUID == 19) { // ThunderX3T110Model
#42303|->       if (AArch64_MC::isScaledAddr(*MI))
#42304|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42305|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42312: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42310: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42308|     case 724: // STRQroW
#42309|       if (CPUID == 1) { // A64FXModel
#42310|->       if (AArch64_MC::isScaledAddr(*MI))
#42311|           return 1719; // A64FXWrite_STUR_ReadDefault
#42312|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42322: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42320: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42318|       }
#42319|       if (CPUID == 9) { // ExynosM3Model
#42320|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#42321|           return 1715; // M3WriteSA_ReadDefault
#42322|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42330: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42325: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42323|       }
#42324|       if (CPUID == 10) { // ExynosM4Model
#42325|->       if ((
#42326|               AArch64_MC::isScaledAddr(*MI)
#42327|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42338: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42333: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42331|       }
#42332|       if (CPUID == 11) { // ExynosM5Model
#42333|->       if ((
#42334|               AArch64_MC::isScaledAddr(*MI)
#42335|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42357: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42355: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42353|       }
#42354|       if (CPUID == 18) { // ThunderX2T99Model
#42355|->       if (AArch64_MC::isScaledAddr(*MI))
#42356|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42357|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42362: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42360: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42358|       }
#42359|       if (CPUID == 19) { // ThunderX3T110Model
#42360|->       if (AArch64_MC::isScaledAddr(*MI))
#42361|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42362|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42369: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42367: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42365|     case 725: // STRQroX
#42366|       if (CPUID == 1) { // A64FXModel
#42367|->       if (AArch64_MC::isScaledAddr(*MI))
#42368|           return 1719; // A64FXWrite_STUR_ReadDefault
#42369|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42430: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42428: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42426|       }
#42427|       if (CPUID == 18) { // ThunderX2T99Model
#42428|->       if (AArch64_MC::isScaledAddr(*MI))
#42429|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#42430|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42435: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:42433: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#42431|       }
#42432|       if (CPUID == 19) { // ThunderX3T110Model
#42433|->       if (AArch64_MC::isScaledAddr(*MI))
#42434|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#42435|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43582: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43580: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43578|     case 924: // STRDroW_STRDroX_STRSroW_STRSroX
#43579|       if (CPUID == 1) { // A64FXModel
#43580|->       if (AArch64_MC::isScaledAddr(*MI))
#43581|           return 1719; // A64FXWrite_STUR_ReadDefault
#43582|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43592: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43590: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43588|       }
#43589|       if (CPUID == 9) { // ExynosM3Model
#43590|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#43591|           return 1717; // WriteVST_ReadDefault
#43592|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43600: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43595: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43593|       }
#43594|       if (CPUID == 10) { // ExynosM4Model
#43595|->       if ((
#43596|               AArch64_MC::isScaledAddr(*MI)
#43597|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43608: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43603: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43601|       }
#43602|       if (CPUID == 11) { // ExynosM5Model
#43603|->       if ((
#43604|               AArch64_MC::isScaledAddr(*MI)
#43605|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43627: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43625: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43623|       }
#43624|       if (CPUID == 18) { // ThunderX2T99Model
#43625|->       if (AArch64_MC::isScaledAddr(*MI))
#43626|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#43627|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43632: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43630: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43628|       }
#43629|       if (CPUID == 19) { // ThunderX3T110Model
#43630|->       if (AArch64_MC::isScaledAddr(*MI))
#43631|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#43632|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43644: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43642: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43640|     case 959: // LDRBBroW_LDRBBroX_LDRWroW_LDRWroX_LDRXroW_LDRXroX
#43641|       if (CPUID == 1) { // A64FXModel
#43642|->       if (AArch64_MC::isScaledAddr(*MI))
#43643|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#43644|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43748: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43746: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43744|     case 966: // LDRSBWroW_LDRSBWroX_LDRSBXroW_LDRSBXroX_LDRSWroW_LDRSWroX
#43745|       if (CPUID == 1) { // A64FXModel
#43746|->       if (AArch64_MC::isScaledAddr(*MI))
#43747|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#43748|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43918: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43916: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43914|     case 1004: // STRBBroW_STRBBroX_STRWroW_STRWroX_STRXroW_STRXroX
#43915|       if (CPUID == 1) { // A64FXModel
#43916|->       if (AArch64_MC::isScaledAddr(*MI))
#43917|           return 1719; // A64FXWrite_STUR_ReadDefault
#43918|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43928: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43926: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43924|       }
#43925|       if (CPUID == 9) { // ExynosM3Model
#43926|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#43927|           return 1728; // WriteST_ReadDefault
#43928|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43936: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43931: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43929|       }
#43930|       if (CPUID == 10) { // ExynosM4Model
#43931|->       if ((
#43932|               AArch64_MC::isScaledAddr(*MI)
#43933|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43944: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43939: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43937|       }
#43938|       if (CPUID == 11) { // ExynosM5Model
#43939|->       if ((
#43940|               AArch64_MC::isScaledAddr(*MI)
#43941|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43952: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43950: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43948|       }
#43949|       if (CPUID == 18) { // ThunderX2T99Model
#43950|->       if (AArch64_MC::isScaledAddr(*MI))
#43951|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#43952|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43957: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:43955: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#43953|       }
#43954|       if (CPUID == 19) { // ThunderX3T110Model
#43955|->       if (AArch64_MC::isScaledAddr(*MI))
#43956|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#43957|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45189: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45187: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45185|     case 1072: // LDRBBroW_LDRWroW_LDRXroW
#45186|       if (CPUID == 1) { // A64FXModel
#45187|->       if (AArch64_MC::isScaledAddr(*MI))
#45188|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#45189|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45199: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45197: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45195|       }
#45196|       if (CPUID == 9) { // ExynosM3Model
#45197|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#45198|           return 1707; // M3WriteLB_ReadDefault
#45199|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45207: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45202: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45200|       }
#45201|       if (CPUID == 10) { // ExynosM4Model
#45202|->       if ((
#45203|               AArch64_MC::isScaledAddr(*MI)
#45204|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45215: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45210: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45208|       }
#45209|       if (CPUID == 11) { // ExynosM5Model
#45210|->       if ((
#45211|               AArch64_MC::isScaledAddr(*MI)
#45212|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45235: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45233: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45231|     case 1073: // LDRSBWroW_LDRSBXroW_LDRSWroW
#45232|       if (CPUID == 1) { // A64FXModel
#45233|->       if (AArch64_MC::isScaledAddr(*MI))
#45234|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#45235|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45245: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45243: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45241|       }
#45242|       if (CPUID == 9) { // ExynosM3Model
#45243|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#45244|           return 1707; // M3WriteLB_ReadDefault
#45245|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45253: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45248: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45246|       }
#45247|       if (CPUID == 10) { // ExynosM4Model
#45248|->       if ((
#45249|               AArch64_MC::isScaledAddr(*MI)
#45250|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45261: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45256: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45254|       }
#45255|       if (CPUID == 11) { // ExynosM5Model
#45256|->       if ((
#45257|               AArch64_MC::isScaledAddr(*MI)
#45258|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45281: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45279: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45277|     case 1074: // PRFMroW
#45278|       if (CPUID == 9) { // ExynosM3Model
#45279|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#45280|           return 1707; // M3WriteLB_ReadDefault
#45281|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45289: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45284: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45282|       }
#45283|       if (CPUID == 10) { // ExynosM4Model
#45284|->       if ((
#45285|               AArch64_MC::isScaledAddr(*MI)
#45286|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45297: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45292: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45290|       }
#45291|       if (CPUID == 11) { // ExynosM5Model
#45292|->       if ((
#45293|               AArch64_MC::isScaledAddr(*MI)
#45294|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45307: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45305: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45303|     case 1075: // STRBBroW_STRWroW_STRXroW
#45304|       if (CPUID == 1) { // A64FXModel
#45305|->       if (AArch64_MC::isScaledAddr(*MI))
#45306|           return 1719; // A64FXWrite_STUR_ReadDefault
#45307|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45317: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45315: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45313|       }
#45314|       if (CPUID == 9) { // ExynosM3Model
#45315|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#45316|           return 1725; // M3WriteSB_ReadDefault
#45317|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45325: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45320: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45318|       }
#45319|       if (CPUID == 10) { // ExynosM4Model
#45320|->       if ((
#45321|               AArch64_MC::isScaledAddr(*MI)
#45322|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45333: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45328: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45326|       }
#45327|       if (CPUID == 11) { // ExynosM5Model
#45328|->       if ((
#45329|               AArch64_MC::isScaledAddr(*MI)
#45330|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45341: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45339: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45337|       }
#45338|       if (CPUID == 18) { // ThunderX2T99Model
#45339|->       if (AArch64_MC::isScaledAddr(*MI))
#45340|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#45341|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45346: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45344: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45342|       }
#45343|       if (CPUID == 19) { // ThunderX3T110Model
#45344|->       if (AArch64_MC::isScaledAddr(*MI))
#45345|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#45346|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45353: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45351: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45349|     case 1085: // STRDroW_STRSroW
#45350|       if (CPUID == 1) { // A64FXModel
#45351|->       if (AArch64_MC::isScaledAddr(*MI))
#45352|           return 1719; // A64FXWrite_STUR_ReadDefault
#45353|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45363: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45361: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45359|       }
#45360|       if (CPUID == 9) { // ExynosM3Model
#45361|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#45362|           return 1715; // M3WriteSA_ReadDefault
#45363|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45371: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45366: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45364|       }
#45365|       if (CPUID == 10) { // ExynosM4Model
#45366|->       if ((
#45367|               AArch64_MC::isScaledAddr(*MI)
#45368|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45379: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45374: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45372|       }
#45373|       if (CPUID == 11) { // ExynosM5Model
#45374|->       if ((
#45375|               AArch64_MC::isScaledAddr(*MI)
#45376|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45398: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45396: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45394|       }
#45395|       if (CPUID == 18) { // ThunderX2T99Model
#45396|->       if (AArch64_MC::isScaledAddr(*MI))
#45397|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#45398|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45403: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:45401: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#45399|       }
#45400|       if (CPUID == 19) { // ThunderX3T110Model
#45401|->       if (AArch64_MC::isScaledAddr(*MI))
#45402|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#45403|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46134: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46132: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46130|     case 1221: // LDRWroW
#46131|       if (CPUID == 1) { // A64FXModel
#46132|->       if (AArch64_MC::isScaledAddr(*MI))
#46133|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#46134|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46144: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46142: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46140|       }
#46141|       if (CPUID == 9) { // ExynosM3Model
#46142|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46143|           return 1707; // M3WriteLB_ReadDefault
#46144|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46152: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46147: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46145|       }
#46146|       if (CPUID == 10) { // ExynosM4Model
#46147|->       if ((
#46148|               AArch64_MC::isScaledAddr(*MI)
#46149|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46160: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46155: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46153|       }
#46154|       if (CPUID == 11) { // ExynosM5Model
#46155|->       if ((
#46156|               AArch64_MC::isScaledAddr(*MI)
#46157|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46168: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46166: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46164|       }
#46165|       if (CPUID == 18) { // ThunderX2T99Model
#46166|->       if (AArch64_MC::isScaledAddr(*MI))
#46167|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#46168|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46173: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46171: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46169|       }
#46170|       if (CPUID == 19) { // ThunderX3T110Model
#46171|->       if (AArch64_MC::isScaledAddr(*MI))
#46172|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#46173|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46180: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46178: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46176|     case 1222: // LDRXroW
#46177|       if (CPUID == 1) { // A64FXModel
#46178|->       if (AArch64_MC::isScaledAddr(*MI))
#46179|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#46180|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46190: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46188: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46186|       }
#46187|       if (CPUID == 9) { // ExynosM3Model
#46188|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46189|           return 1707; // M3WriteLB_ReadDefault
#46190|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46198: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46193: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46191|       }
#46192|       if (CPUID == 10) { // ExynosM4Model
#46193|->       if ((
#46194|               AArch64_MC::isScaledAddr(*MI)
#46195|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46206: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46201: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46199|       }
#46200|       if (CPUID == 11) { // ExynosM5Model
#46201|->       if ((
#46202|               AArch64_MC::isScaledAddr(*MI)
#46203|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46214: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46212: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46210|       }
#46211|       if (CPUID == 18) { // ThunderX2T99Model
#46212|->       if (AArch64_MC::isScaledAddr(*MI))
#46213|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#46214|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46219: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46217: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46215|       }
#46216|       if (CPUID == 19) { // ThunderX3T110Model
#46217|->       if (AArch64_MC::isScaledAddr(*MI))
#46218|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#46219|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46226: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46224: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46222|     case 1223: // LDRWroX
#46223|       if (CPUID == 1) { // A64FXModel
#46224|->       if (AArch64_MC::isScaledAddr(*MI))
#46225|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#46226|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46276: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46274: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46272|       }
#46273|       if (CPUID == 18) { // ThunderX2T99Model
#46274|->       if (AArch64_MC::isScaledAddr(*MI))
#46275|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#46276|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46281: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46279: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46277|       }
#46278|       if (CPUID == 19) { // ThunderX3T110Model
#46279|->       if (AArch64_MC::isScaledAddr(*MI))
#46280|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#46281|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46288: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46286: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46284|     case 1224: // LDRXroX
#46285|       if (CPUID == 1) { // A64FXModel
#46286|->       if (AArch64_MC::isScaledAddr(*MI))
#46287|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#46288|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46338: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46336: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46334|       }
#46335|       if (CPUID == 18) { // ThunderX2T99Model
#46336|->       if (AArch64_MC::isScaledAddr(*MI))
#46337|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#46338|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46343: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46341: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46339|       }
#46340|       if (CPUID == 19) { // ThunderX3T110Model
#46341|->       if (AArch64_MC::isScaledAddr(*MI))
#46342|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#46343|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46350: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46348: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46346|     case 1247: // STRBBroW
#46347|       if (CPUID == 1) { // A64FXModel
#46348|->       if (AArch64_MC::isScaledAddr(*MI))
#46349|           return 1719; // A64FXWrite_STUR_ReadDefault
#46350|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46360: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46358: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46356|       }
#46357|       if (CPUID == 9) { // ExynosM3Model
#46358|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46359|           return 1725; // M3WriteSB_ReadDefault
#46360|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46368: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46363: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46361|       }
#46362|       if (CPUID == 10) { // ExynosM4Model
#46363|->       if ((
#46364|               AArch64_MC::isScaledAddr(*MI)
#46365|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46376: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46371: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46369|       }
#46370|       if (CPUID == 11) { // ExynosM5Model
#46371|->       if ((
#46372|               AArch64_MC::isScaledAddr(*MI)
#46373|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46384: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46382: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46380|       }
#46381|       if (CPUID == 18) { // ThunderX2T99Model
#46382|->       if (AArch64_MC::isScaledAddr(*MI))
#46383|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#46384|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46389: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46387: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46385|       }
#46386|       if (CPUID == 19) { // ThunderX3T110Model
#46387|->       if (AArch64_MC::isScaledAddr(*MI))
#46388|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#46389|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46396: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46394: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46392|     case 1248: // STRBBroX
#46393|       if (CPUID == 1) { // A64FXModel
#46394|->       if (AArch64_MC::isScaledAddr(*MI))
#46395|           return 1719; // A64FXWrite_STUR_ReadDefault
#46396|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46406: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46404: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46402|       }
#46403|       if (CPUID == 9) { // ExynosM3Model
#46404|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46405|           return 1728; // WriteST_ReadDefault
#46406|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46414: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46409: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46407|       }
#46408|       if (CPUID == 10) { // ExynosM4Model
#46409|->       if ((
#46410|               AArch64_MC::isScaledAddr(*MI)
#46411|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46422: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46417: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46415|       }
#46416|       if (CPUID == 11) { // ExynosM5Model
#46417|->       if ((
#46418|               AArch64_MC::isScaledAddr(*MI)
#46419|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46430: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46428: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46426|       }
#46427|       if (CPUID == 18) { // ThunderX2T99Model
#46428|->       if (AArch64_MC::isScaledAddr(*MI))
#46429|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#46430|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46435: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46433: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46431|       }
#46432|       if (CPUID == 19) { // ThunderX3T110Model
#46433|->       if (AArch64_MC::isScaledAddr(*MI))
#46434|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#46435|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46442: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46440: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46438|     case 1249: // STRDroW
#46439|       if (CPUID == 1) { // A64FXModel
#46440|->       if (AArch64_MC::isScaledAddr(*MI))
#46441|           return 1719; // A64FXWrite_STUR_ReadDefault
#46442|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46452: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46450: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46448|       }
#46449|       if (CPUID == 9) { // ExynosM3Model
#46450|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46451|           return 1715; // M3WriteSA_ReadDefault
#46452|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46460: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46455: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46453|       }
#46454|       if (CPUID == 10) { // ExynosM4Model
#46455|->       if ((
#46456|               AArch64_MC::isScaledAddr(*MI)
#46457|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46468: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46463: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46461|       }
#46462|       if (CPUID == 11) { // ExynosM5Model
#46463|->       if ((
#46464|               AArch64_MC::isScaledAddr(*MI)
#46465|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46487: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46485: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46483|       }
#46484|       if (CPUID == 18) { // ThunderX2T99Model
#46485|->       if (AArch64_MC::isScaledAddr(*MI))
#46486|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#46487|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46492: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46490: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46488|       }
#46489|       if (CPUID == 19) { // ThunderX3T110Model
#46490|->       if (AArch64_MC::isScaledAddr(*MI))
#46491|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#46492|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46499: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46497: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46495|     case 1250: // STRDroX
#46496|       if (CPUID == 1) { // A64FXModel
#46497|->       if (AArch64_MC::isScaledAddr(*MI))
#46498|           return 1719; // A64FXWrite_STUR_ReadDefault
#46499|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46509: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46507: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46505|       }
#46506|       if (CPUID == 9) { // ExynosM3Model
#46507|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46508|           return 1717; // WriteVST_ReadDefault
#46509|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46517: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46512: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46510|       }
#46511|       if (CPUID == 10) { // ExynosM4Model
#46512|->       if ((
#46513|               AArch64_MC::isScaledAddr(*MI)
#46514|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46525: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46520: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46518|       }
#46519|       if (CPUID == 11) { // ExynosM5Model
#46520|->       if ((
#46521|               AArch64_MC::isScaledAddr(*MI)
#46522|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46544: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46542: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46540|       }
#46541|       if (CPUID == 18) { // ThunderX2T99Model
#46542|->       if (AArch64_MC::isScaledAddr(*MI))
#46543|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#46544|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46549: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46547: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46545|       }
#46546|       if (CPUID == 19) { // ThunderX3T110Model
#46547|->       if (AArch64_MC::isScaledAddr(*MI))
#46548|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#46549|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46556: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46554: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46552|     case 1251: // STRWroW
#46553|       if (CPUID == 1) { // A64FXModel
#46554|->       if (AArch64_MC::isScaledAddr(*MI))
#46555|           return 1719; // A64FXWrite_STUR_ReadDefault
#46556|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46566: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46564: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46562|       }
#46563|       if (CPUID == 9) { // ExynosM3Model
#46564|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46565|           return 1725; // M3WriteSB_ReadDefault
#46566|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46574: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46569: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46567|       }
#46568|       if (CPUID == 10) { // ExynosM4Model
#46569|->       if ((
#46570|               AArch64_MC::isScaledAddr(*MI)
#46571|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46582: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46577: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46575|       }
#46576|       if (CPUID == 11) { // ExynosM5Model
#46577|->       if ((
#46578|               AArch64_MC::isScaledAddr(*MI)
#46579|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46590: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46588: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46586|       }
#46587|       if (CPUID == 18) { // ThunderX2T99Model
#46588|->       if (AArch64_MC::isScaledAddr(*MI))
#46589|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#46590|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46595: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46593: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46591|       }
#46592|       if (CPUID == 19) { // ThunderX3T110Model
#46593|->       if (AArch64_MC::isScaledAddr(*MI))
#46594|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#46595|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46602: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46600: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46598|     case 1252: // STRWroX
#46599|       if (CPUID == 1) { // A64FXModel
#46600|->       if (AArch64_MC::isScaledAddr(*MI))
#46601|           return 1719; // A64FXWrite_STUR_ReadDefault
#46602|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46612: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46610: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46608|       }
#46609|       if (CPUID == 9) { // ExynosM3Model
#46610|->       if (AArch64_MC::isExynosScaledAddr(*MI))
#46611|           return 1728; // WriteST_ReadDefault
#46612|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46620: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46615: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46613|       }
#46614|       if (CPUID == 10) { // ExynosM4Model
#46615|->       if ((
#46616|               AArch64_MC::isScaledAddr(*MI)
#46617|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46628: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46623: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI) || llvm::AArch64_MC::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46621|       }
#46622|       if (CPUID == 11) { // ExynosM5Model
#46623|->       if ((
#46624|               AArch64_MC::isScaledAddr(*MI)
#46625|               || AArch64_MC::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46636: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46634: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46632|       }
#46633|       if (CPUID == 18) { // ThunderX2T99Model
#46634|->       if (AArch64_MC::isScaledAddr(*MI))
#46635|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#46636|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46641: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:46639: identical_branches: The same code is executed when the condition "llvm::AArch64_MC::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#46637|       }
#46638|       if (CPUID == 19) { // ThunderX3T110Model
#46639|->       if (AArch64_MC::isScaledAddr(*MI))
#46640|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#46641|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47611: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47609: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#47607|     case 34: // WriteLDIdx_ReadAdrBase
#47608|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#47609|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#47610|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#47611|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47621: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47619: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#47617|       }
#47618|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#47619|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#47620|           return 1620; // WriteLDIdx_ReadDefault
#47621|         return 1620; // WriteLDIdx_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47745: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47743: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#47741|     case 43: // WriteSTIdx_ReadST_ReadAdrBase
#47742|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#47743|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#47744|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#47745|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47755: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47753: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#47751|       }
#47752|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#47753|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#47754|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#47755|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47792: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47790: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#47788|       }
#47789|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#47790|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#47791|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#47792|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47797: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:47795: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#47793|       }
#47794|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#47795|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#47796|           return 1633; // WriteSTIdx_ReadST_ReadDefault
#47797|         return 1633; // WriteSTIdx_ReadST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48262: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48260: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48258|     case 653: // LDRBroW
#48259|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48260|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48261|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48262|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48272: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48270: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48268|       }
#48269|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48270|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48271|           return 1699; // M3WriteLE_ReadDefault
#48272|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48280: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48275: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48273|       }
#48274|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48275|->       if ((
#48276|               AArch64InstrInfo::isScaledAddr(*MI)
#48277|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48288: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48283: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48281|       }
#48282|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48283|->       if ((
#48284|               AArch64InstrInfo::isScaledAddr(*MI)
#48285|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48309: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48307: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48305|       }
#48306|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48307|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48308|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48309|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48314: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48312: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48310|       }
#48311|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48312|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48313|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48314|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48321: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48319: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48317|     case 654: // LDRBroX
#48318|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48319|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48320|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48321|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48331: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48329: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48327|       }
#48328|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48329|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48330|           return 1706; // WriteVLD_ReadDefault
#48331|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48339: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48334: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48332|       }
#48333|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48334|->       if ((
#48335|               AArch64InstrInfo::isScaledAddr(*MI)
#48336|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48347: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48342: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48340|       }
#48341|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48342|->       if ((
#48343|               AArch64InstrInfo::isScaledAddr(*MI)
#48344|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48368: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48366: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48364|       }
#48365|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48366|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48367|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48368|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48373: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48371: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48369|       }
#48370|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48371|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48372|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48373|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48380: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48378: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48376|     case 659: // LDRDroW
#48377|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48378|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48379|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48380|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48390: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48388: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48386|       }
#48387|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48388|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48389|           return 1699; // M3WriteLE_ReadDefault
#48390|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48398: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48393: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48391|       }
#48392|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48393|->       if ((
#48394|               AArch64InstrInfo::isScaledAddr(*MI)
#48395|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48406: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48401: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48399|       }
#48400|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48401|->       if ((
#48402|               AArch64InstrInfo::isScaledAddr(*MI)
#48403|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48427: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48425: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48423|       }
#48424|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48425|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48426|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48427|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48432: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48430: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48428|       }
#48429|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48430|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48431|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48432|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48439: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48437: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48435|     case 660: // LDRDroX
#48436|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48437|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48438|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48439|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48449: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48447: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48445|       }
#48446|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48447|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48448|           return 1706; // WriteVLD_ReadDefault
#48449|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48457: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48452: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48450|       }
#48451|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48452|->       if ((
#48453|               AArch64InstrInfo::isScaledAddr(*MI)
#48454|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48465: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48460: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48458|       }
#48459|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48460|->       if ((
#48461|               AArch64InstrInfo::isScaledAddr(*MI)
#48462|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48486: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48484: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48482|       }
#48483|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48484|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48485|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48486|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48491: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48489: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48487|       }
#48488|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48489|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48490|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48491|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48498: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48496: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48494|     case 662: // LDRHHroW
#48495|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48496|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48497|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48498|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48508: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48506: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48504|       }
#48505|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48506|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48507|           return 1707; // M3WriteLB_ReadDefault
#48508|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48516: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48511: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48509|       }
#48510|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48511|->       if ((
#48512|               AArch64InstrInfo::isScaledAddr(*MI)
#48513|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48524: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48519: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48517|       }
#48518|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48519|->       if ((
#48520|               AArch64InstrInfo::isScaledAddr(*MI)
#48521|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48534: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48532: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48530|       }
#48531|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48532|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48533|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48534|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48539: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48537: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48535|       }
#48536|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48537|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48538|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48539|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48546: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48544: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48542|     case 663: // LDRHHroX
#48543|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48544|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48545|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48546|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48598: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48596: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48594|       }
#48595|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48596|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48597|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48598|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48603: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48601: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48599|       }
#48600|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48601|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48602|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48603|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48610: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48608: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48606|     case 666: // LDRHroW
#48607|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48608|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48609|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48610|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48620: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48618: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48616|       }
#48617|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48618|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48619|           return 1699; // M3WriteLE_ReadDefault
#48620|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48628: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48623: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48621|       }
#48622|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48623|->       if ((
#48624|               AArch64InstrInfo::isScaledAddr(*MI)
#48625|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48636: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48631: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48629|       }
#48630|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48631|->       if ((
#48632|               AArch64InstrInfo::isScaledAddr(*MI)
#48633|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48657: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48655: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48653|       }
#48654|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48655|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48656|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48657|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48662: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48660: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48658|       }
#48659|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48660|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48661|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48662|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48669: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48667: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48665|     case 667: // LDRHroX
#48666|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48667|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48668|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48669|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48679: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48677: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48675|       }
#48676|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48677|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48678|           return 1706; // WriteVLD_ReadDefault
#48679|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48687: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48682: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48680|       }
#48681|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48682|->       if ((
#48683|               AArch64InstrInfo::isScaledAddr(*MI)
#48684|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48695: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48690: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48688|       }
#48689|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48690|->       if ((
#48691|               AArch64InstrInfo::isScaledAddr(*MI)
#48692|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48716: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48714: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48712|       }
#48713|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48714|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48715|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48716|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48721: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48719: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48717|       }
#48718|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48719|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48720|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48721|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48728: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48726: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48724|     case 672: // LDRQroW
#48725|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48726|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48727|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48728|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48746: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48741: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48739|       }
#48740|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48741|->       if ((
#48742|               AArch64InstrInfo::isScaledAddr(*MI)
#48743|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48754: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48749: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48747|       }
#48748|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48749|->       if ((
#48750|               AArch64InstrInfo::isScaledAddr(*MI)
#48751|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48775: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48773: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48771|       }
#48772|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48773|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48774|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48775|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48780: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48778: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48776|       }
#48777|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48778|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48779|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48780|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48787: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48785: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48783|     case 673: // LDRQroX
#48784|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48785|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48786|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48787|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48850: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48848: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48846|       }
#48847|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48848|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48849|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48850|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48855: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48853: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48851|       }
#48852|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48853|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48854|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48855|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48862: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48860: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48858|     case 675: // LDRSHWroW
#48859|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48860|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48861|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48862|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48872: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48870: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48868|       }
#48869|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48870|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48871|           return 1707; // M3WriteLB_ReadDefault
#48872|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48880: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48875: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48873|       }
#48874|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48875|->       if ((
#48876|               AArch64InstrInfo::isScaledAddr(*MI)
#48877|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48888: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48883: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48881|       }
#48882|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48883|->       if ((
#48884|               AArch64InstrInfo::isScaledAddr(*MI)
#48885|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48898: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48896: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48894|       }
#48895|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48896|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48897|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48898|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48903: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48901: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48899|       }
#48900|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48901|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48902|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48903|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48910: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48908: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48906|     case 676: // LDRSHWroX
#48907|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48908|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48909|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48910|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48962: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48960: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48958|       }
#48959|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#48960|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48961|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#48962|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48967: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48965: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48963|       }
#48964|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#48965|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48966|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#48967|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48974: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48972: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48970|     case 677: // LDRSHXroW
#48971|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#48972|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#48973|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#48974|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48984: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48982: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48980|       }
#48981|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#48982|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#48983|           return 1707; // M3WriteLB_ReadDefault
#48984|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48992: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48987: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48985|       }
#48986|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#48987|->       if ((
#48988|               AArch64InstrInfo::isScaledAddr(*MI)
#48989|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49000: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:48995: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#48993|       }
#48994|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#48995|->       if ((
#48996|               AArch64InstrInfo::isScaledAddr(*MI)
#48997|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49010: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49008: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49006|       }
#49007|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49008|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49009|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#49010|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49015: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49013: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49011|       }
#49012|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49013|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49014|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#49015|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49022: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49020: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49018|     case 678: // LDRSHXroX
#49019|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49020|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49021|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#49022|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49074: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49072: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49070|       }
#49071|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49072|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49073|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#49074|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49079: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49077: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49075|       }
#49076|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49077|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49078|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#49079|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49086: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49084: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49082|     case 682: // LDRSroW
#49083|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49084|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49085|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#49086|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49096: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49094: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49092|       }
#49093|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49094|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49095|           return 1699; // M3WriteLE_ReadDefault
#49096|         return 1699; // M3WriteLE_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49104: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49099: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49097|       }
#49098|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49099|->       if ((
#49100|               AArch64InstrInfo::isScaledAddr(*MI)
#49101|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49112: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49107: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49105|       }
#49106|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49107|->       if ((
#49108|               AArch64InstrInfo::isScaledAddr(*MI)
#49109|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49133: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49131: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49129|       }
#49130|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49131|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49132|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#49133|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49138: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49136: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49134|       }
#49135|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49136|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49137|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#49138|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49145: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49143: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49141|     case 683: // LDRSroX
#49142|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49143|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49144|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#49145|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49155: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49153: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49151|       }
#49152|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49153|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49154|           return 1706; // WriteVLD_ReadDefault
#49155|         return 1706; // WriteVLD_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49163: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49158: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49156|       }
#49157|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49158|->       if ((
#49159|               AArch64InstrInfo::isScaledAddr(*MI)
#49160|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49171: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49166: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49164|       }
#49165|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49166|->       if ((
#49167|               AArch64InstrInfo::isScaledAddr(*MI)
#49168|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49192: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49190: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49188|       }
#49189|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49190|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49191|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#49192|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49197: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49195: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49193|       }
#49194|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49195|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49196|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#49197|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49204: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49202: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49200|     case 710: // STRBroW
#49201|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49202|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49203|           return 1719; // A64FXWrite_STUR_ReadDefault
#49204|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49214: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49212: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49210|       }
#49211|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49212|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49213|           return 1715; // M3WriteSA_ReadDefault
#49214|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49222: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49217: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49215|       }
#49216|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49217|->       if ((
#49218|               AArch64InstrInfo::isScaledAddr(*MI)
#49219|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49230: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49225: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49223|       }
#49224|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49225|->       if ((
#49226|               AArch64InstrInfo::isScaledAddr(*MI)
#49227|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49251: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49249: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49247|       }
#49248|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49249|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49250|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49251|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49256: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49254: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49252|       }
#49253|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49254|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49255|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49256|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49263: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49261: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49259|     case 711: // STRBroX
#49260|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49261|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49262|           return 1719; // A64FXWrite_STUR_ReadDefault
#49263|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49273: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49271: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49269|       }
#49270|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49271|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49272|           return 1717; // WriteVST_ReadDefault
#49273|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49281: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49276: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49274|       }
#49275|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49276|->       if ((
#49277|               AArch64InstrInfo::isScaledAddr(*MI)
#49278|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49289: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49284: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49282|       }
#49283|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49284|->       if ((
#49285|               AArch64InstrInfo::isScaledAddr(*MI)
#49286|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49310: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49308: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49306|       }
#49307|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49308|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49309|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49310|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49315: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49313: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49311|       }
#49312|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49313|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49314|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49315|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49322: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49320: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49318|     case 716: // STRHHroW
#49319|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49320|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49321|           return 1719; // A64FXWrite_STUR_ReadDefault
#49322|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49332: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49330: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49328|       }
#49329|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49330|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49331|           return 1725; // M3WriteSB_ReadDefault
#49332|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49340: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49335: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49333|       }
#49334|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49335|->       if ((
#49336|               AArch64InstrInfo::isScaledAddr(*MI)
#49337|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49348: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49343: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49341|       }
#49342|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49343|->       if ((
#49344|               AArch64InstrInfo::isScaledAddr(*MI)
#49345|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49358: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49356: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49354|       }
#49355|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49356|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49357|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49358|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49363: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49361: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49359|       }
#49360|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49361|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49362|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49363|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49370: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49368: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49366|     case 717: // STRHHroX
#49367|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49368|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49369|           return 1719; // A64FXWrite_STUR_ReadDefault
#49370|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49380: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49378: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49376|       }
#49377|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49378|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49379|           return 1728; // WriteST_ReadDefault
#49380|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49388: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49383: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49381|       }
#49382|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49383|->       if ((
#49384|               AArch64InstrInfo::isScaledAddr(*MI)
#49385|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49396: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49391: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49389|       }
#49390|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49391|->       if ((
#49392|               AArch64InstrInfo::isScaledAddr(*MI)
#49393|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49406: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49404: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49402|       }
#49403|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49404|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49405|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49406|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49411: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49409: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49407|       }
#49408|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49409|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49410|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49411|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49418: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49416: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49414|     case 720: // STRHroW
#49415|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49416|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49417|           return 1719; // A64FXWrite_STUR_ReadDefault
#49418|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49428: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49426: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49424|       }
#49425|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49426|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49427|           return 1715; // M3WriteSA_ReadDefault
#49428|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49436: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49431: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49429|       }
#49430|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49431|->       if ((
#49432|               AArch64InstrInfo::isScaledAddr(*MI)
#49433|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49444: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49439: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49437|       }
#49438|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49439|->       if ((
#49440|               AArch64InstrInfo::isScaledAddr(*MI)
#49441|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49465: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49463: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49461|       }
#49462|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49463|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49464|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49465|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49470: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49468: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49466|       }
#49467|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49468|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49469|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49470|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49477: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49475: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49473|     case 721: // STRHroX
#49474|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49475|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49476|           return 1719; // A64FXWrite_STUR_ReadDefault
#49477|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49487: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49485: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49483|       }
#49484|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49485|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49486|           return 1717; // WriteVST_ReadDefault
#49487|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49495: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49490: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49488|       }
#49489|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49490|->       if ((
#49491|               AArch64InstrInfo::isScaledAddr(*MI)
#49492|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49503: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49498: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49496|       }
#49497|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49498|->       if ((
#49499|               AArch64InstrInfo::isScaledAddr(*MI)
#49500|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49524: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49522: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49520|       }
#49521|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49522|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49523|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49524|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49529: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49527: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49525|       }
#49526|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49527|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49528|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49529|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49536: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49534: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49532|     case 724: // STRQroW
#49533|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49534|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49535|           return 1719; // A64FXWrite_STUR_ReadDefault
#49536|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49546: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49544: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49542|       }
#49543|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#49544|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#49545|           return 1715; // M3WriteSA_ReadDefault
#49546|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49554: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49549: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49547|       }
#49548|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#49549|->       if ((
#49550|               AArch64InstrInfo::isScaledAddr(*MI)
#49551|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49562: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49557: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49555|       }
#49556|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#49557|->       if ((
#49558|               AArch64InstrInfo::isScaledAddr(*MI)
#49559|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49583: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49581: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49579|       }
#49580|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49581|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49582|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49583|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49588: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49586: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49584|       }
#49585|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49586|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49587|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49588|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49595: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49593: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49591|     case 725: // STRQroX
#49592|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#49593|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49594|           return 1719; // A64FXWrite_STUR_ReadDefault
#49595|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49658: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49656: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49654|       }
#49655|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#49656|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49657|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#49658|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49663: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:49661: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#49659|       }
#49660|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#49661|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#49662|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#49663|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50837: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50835: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50833|     case 924: // STRDroW_STRDroX_STRSroW_STRSroX
#50834|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#50835|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#50836|           return 1719; // A64FXWrite_STUR_ReadDefault
#50837|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50847: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50845: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50843|       }
#50844|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#50845|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#50846|           return 1717; // WriteVST_ReadDefault
#50847|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50855: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50850: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50848|       }
#50849|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#50850|->       if ((
#50851|               AArch64InstrInfo::isScaledAddr(*MI)
#50852|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50863: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50858: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50856|       }
#50857|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#50858|->       if ((
#50859|               AArch64InstrInfo::isScaledAddr(*MI)
#50860|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50884: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50882: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50880|       }
#50881|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#50882|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#50883|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#50884|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50889: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50887: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50885|       }
#50886|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#50887|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#50888|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#50889|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50905: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:50903: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#50901|     case 959: // LDRBBroW_LDRBBroX_LDRWroW_LDRWroX_LDRXroW_LDRXroX
#50902|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#50903|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#50904|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#50905|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51013: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51011: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51009|     case 966: // LDRSBWroW_LDRSBWroX_LDRSBXroW_LDRSBXroX_LDRSWroW_LDRSWroX
#51010|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#51011|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#51012|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#51013|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51185: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51183: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51181|     case 1004: // STRBBroW_STRBBroX_STRWroW_STRWroX_STRXroW_STRXroX
#51182|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#51183|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#51184|           return 1719; // A64FXWrite_STUR_ReadDefault
#51185|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51195: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51193: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51191|       }
#51192|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#51193|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#51194|           return 1728; // WriteST_ReadDefault
#51195|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51203: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51198: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51196|       }
#51197|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#51198|->       if ((
#51199|               AArch64InstrInfo::isScaledAddr(*MI)
#51200|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51211: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51206: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51204|       }
#51205|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#51206|->       if ((
#51207|               AArch64InstrInfo::isScaledAddr(*MI)
#51208|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51221: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51219: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51217|       }
#51218|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#51219|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#51220|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#51221|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51226: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:51224: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#51222|       }
#51223|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#51224|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#51225|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#51226|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52472: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52470: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52468|     case 1072: // LDRBBroW_LDRWroW_LDRXroW
#52469|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#52470|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52471|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#52472|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52482: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52480: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52478|       }
#52479|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#52480|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#52481|           return 1707; // M3WriteLB_ReadDefault
#52482|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52490: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52485: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52483|       }
#52484|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#52485|->       if ((
#52486|               AArch64InstrInfo::isScaledAddr(*MI)
#52487|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52498: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52493: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52491|       }
#52492|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#52493|->       if ((
#52494|               AArch64InstrInfo::isScaledAddr(*MI)
#52495|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52520: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52518: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52516|     case 1073: // LDRSBWroW_LDRSBXroW_LDRSWroW
#52517|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#52518|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52519|           return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault
#52520|         return 1617; // A64FXWrite_1Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52530: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52528: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52526|       }
#52527|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#52528|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#52529|           return 1707; // M3WriteLB_ReadDefault
#52530|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52538: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52533: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52531|       }
#52532|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#52533|->       if ((
#52534|               AArch64InstrInfo::isScaledAddr(*MI)
#52535|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52546: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52541: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52539|       }
#52540|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#52541|->       if ((
#52542|               AArch64InstrInfo::isScaledAddr(*MI)
#52543|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52568: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52566: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52564|     case 1074: // PRFMroW
#52565|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#52566|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#52567|           return 1707; // M3WriteLB_ReadDefault
#52568|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52576: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52571: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52569|       }
#52570|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#52571|->       if ((
#52572|               AArch64InstrInfo::isScaledAddr(*MI)
#52573|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52584: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52579: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52577|       }
#52578|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#52579|->       if ((
#52580|               AArch64InstrInfo::isScaledAddr(*MI)
#52581|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52596: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52594: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52592|     case 1075: // STRBBroW_STRWroW_STRXroW
#52593|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#52594|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52595|           return 1719; // A64FXWrite_STUR_ReadDefault
#52596|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52606: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52604: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52602|       }
#52603|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#52604|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#52605|           return 1725; // M3WriteSB_ReadDefault
#52606|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52614: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52609: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52607|       }
#52608|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#52609|->       if ((
#52610|               AArch64InstrInfo::isScaledAddr(*MI)
#52611|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52622: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52617: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52615|       }
#52616|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#52617|->       if ((
#52618|               AArch64InstrInfo::isScaledAddr(*MI)
#52619|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52632: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52630: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52628|       }
#52629|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#52630|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52631|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#52632|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52637: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52635: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52633|       }
#52634|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#52635|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52636|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#52637|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52644: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52642: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52640|     case 1085: // STRDroW_STRSroW
#52641|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#52642|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52643|           return 1719; // A64FXWrite_STUR_ReadDefault
#52644|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52654: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52652: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52650|       }
#52651|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#52652|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#52653|           return 1715; // M3WriteSA_ReadDefault
#52654|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52662: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52657: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52655|       }
#52656|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#52657|->       if ((
#52658|               AArch64InstrInfo::isScaledAddr(*MI)
#52659|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52670: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52665: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52663|       }
#52664|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#52665|->       if ((
#52666|               AArch64InstrInfo::isScaledAddr(*MI)
#52667|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52691: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52689: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52687|       }
#52688|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#52689|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52690|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#52691|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52696: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:52694: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#52692|       }
#52693|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#52694|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#52695|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#52696|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53439: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53437: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53435|     case 1221: // LDRWroW
#53436|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53437|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53438|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#53439|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53449: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53447: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53445|       }
#53446|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53447|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53448|           return 1707; // M3WriteLB_ReadDefault
#53449|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53457: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53452: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53450|       }
#53451|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53452|->       if ((
#53453|               AArch64InstrInfo::isScaledAddr(*MI)
#53454|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53465: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53460: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53458|       }
#53459|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53460|->       if ((
#53461|               AArch64InstrInfo::isScaledAddr(*MI)
#53462|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53475: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53473: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53471|       }
#53472|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53473|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53474|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#53475|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53480: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53478: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53476|       }
#53477|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53478|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53479|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#53480|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53487: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53485: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53483|     case 1222: // LDRXroW
#53484|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53485|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53486|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#53487|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53497: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53495: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53493|       }
#53494|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53495|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53496|           return 1707; // M3WriteLB_ReadDefault
#53497|         return 1707; // M3WriteLB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53505: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53500: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53498|       }
#53499|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53500|->       if ((
#53501|               AArch64InstrInfo::isScaledAddr(*MI)
#53502|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53513: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53508: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53506|       }
#53507|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53508|->       if ((
#53509|               AArch64InstrInfo::isScaledAddr(*MI)
#53510|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53523: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53521: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53519|       }
#53520|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53521|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53522|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#53523|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53528: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53526: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53524|       }
#53525|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53526|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53527|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#53528|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53535: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53533: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53531|     case 1223: // LDRWroX
#53532|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53533|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53534|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#53535|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53587: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53585: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53583|       }
#53584|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53585|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53586|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#53587|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53592: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53590: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53588|       }
#53589|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53590|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53591|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#53592|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53599: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53597: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53595|     case 1224: // LDRXroX
#53596|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53597|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53598|           return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault
#53599|         return 1703; // A64FXWrite_5Cyc_GI56_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53651: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53649: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53647|       }
#53648|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53649|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53650|           return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault
#53651|         return 1702; // THX2T99Write_4Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53656: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53654: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53652|       }
#53653|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53654|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53655|           return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault
#53656|         return 1628; // THX3T110Write_4Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53663: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53661: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53659|     case 1247: // STRBBroW
#53660|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53661|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53662|           return 1719; // A64FXWrite_STUR_ReadDefault
#53663|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53673: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53671: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53669|       }
#53670|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53671|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53672|           return 1725; // M3WriteSB_ReadDefault
#53673|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53681: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53676: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53674|       }
#53675|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53676|->       if ((
#53677|               AArch64InstrInfo::isScaledAddr(*MI)
#53678|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53689: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53684: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53682|       }
#53683|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53684|->       if ((
#53685|               AArch64InstrInfo::isScaledAddr(*MI)
#53686|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53699: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53697: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53695|       }
#53696|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53697|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53698|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#53699|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53704: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53702: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53700|       }
#53701|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53702|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53703|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#53704|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53711: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53709: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53707|     case 1248: // STRBBroX
#53708|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53709|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53710|           return 1719; // A64FXWrite_STUR_ReadDefault
#53711|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53721: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53719: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53717|       }
#53718|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53719|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53720|           return 1728; // WriteST_ReadDefault
#53721|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53729: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53724: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53722|       }
#53723|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53724|->       if ((
#53725|               AArch64InstrInfo::isScaledAddr(*MI)
#53726|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53737: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53732: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53730|       }
#53731|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53732|->       if ((
#53733|               AArch64InstrInfo::isScaledAddr(*MI)
#53734|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53747: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53745: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53743|       }
#53744|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53745|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53746|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#53747|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53752: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53750: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53748|       }
#53749|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53750|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53751|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#53752|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53759: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53757: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53755|     case 1249: // STRDroW
#53756|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53757|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53758|           return 1719; // A64FXWrite_STUR_ReadDefault
#53759|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53769: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53767: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53765|       }
#53766|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53767|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53768|           return 1715; // M3WriteSA_ReadDefault
#53769|         return 1715; // M3WriteSA_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53777: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53772: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53770|       }
#53771|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53772|->       if ((
#53773|               AArch64InstrInfo::isScaledAddr(*MI)
#53774|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53785: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53780: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53778|       }
#53779|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53780|->       if ((
#53781|               AArch64InstrInfo::isScaledAddr(*MI)
#53782|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53806: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53804: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53802|       }
#53803|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53804|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53805|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#53806|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53811: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53809: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53807|       }
#53808|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53809|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53810|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#53811|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53818: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53816: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53814|     case 1250: // STRDroX
#53815|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53816|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53817|           return 1719; // A64FXWrite_STUR_ReadDefault
#53818|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53828: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53826: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53824|       }
#53825|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53826|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53827|           return 1717; // WriteVST_ReadDefault
#53828|         return 1717; // WriteVST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53836: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53831: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53829|       }
#53830|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53831|->       if ((
#53832|               AArch64InstrInfo::isScaledAddr(*MI)
#53833|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53844: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53839: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53837|       }
#53838|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53839|->       if ((
#53840|               AArch64InstrInfo::isScaledAddr(*MI)
#53841|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53865: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53863: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53861|       }
#53862|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53863|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53864|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#53865|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53870: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53868: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53866|       }
#53867|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53868|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53869|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#53870|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53877: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53875: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53873|     case 1251: // STRWroW
#53874|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53875|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53876|           return 1719; // A64FXWrite_STUR_ReadDefault
#53877|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53887: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53885: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53883|       }
#53884|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53885|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53886|           return 1725; // M3WriteSB_ReadDefault
#53887|         return 1725; // M3WriteSB_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53895: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53890: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53888|       }
#53889|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53890|->       if ((
#53891|               AArch64InstrInfo::isScaledAddr(*MI)
#53892|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53903: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53898: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53896|       }
#53897|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53898|->       if ((
#53899|               AArch64InstrInfo::isScaledAddr(*MI)
#53900|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53913: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53911: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53909|       }
#53910|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53911|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53912|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#53913|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53918: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53916: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53914|       }
#53915|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53916|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53917|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#53918|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53925: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53923: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53921|     case 1252: // STRWroX
#53922|       if (SchedModel->getProcessorID() == 1) { // A64FXModel
#53923|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53924|           return 1719; // A64FXWrite_STUR_ReadDefault
#53925|         return 1719; // A64FXWrite_STUR_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53935: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53933: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53931|       }
#53932|       if (SchedModel->getProcessorID() == 9) { // ExynosM3Model
#53933|->       if (AArch64InstrInfo::isExynosScaledAddr(*MI))
#53934|           return 1728; // WriteST_ReadDefault
#53935|         return 1728; // WriteST_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53943: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53938: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53936|       }
#53937|       if (SchedModel->getProcessorID() == 10) { // ExynosM4Model
#53938|->       if ((
#53939|               AArch64InstrInfo::isScaledAddr(*MI)
#53940|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53951: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53946: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI) || llvm::AArch64InstrInfo::isExynosScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53944|       }
#53945|       if (SchedModel->getProcessorID() == 11) { // ExynosM5Model
#53946|->       if ((
#53947|               AArch64InstrInfo::isScaledAddr(*MI)
#53948|               || AArch64InstrInfo::isExynosScaledAddr(*MI)

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53961: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53959: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53957|       }
#53958|       if (SchedModel->getProcessorID() == 18) { // ThunderX2T99Model
#53959|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53960|           return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault
#53961|         return 1718; // WriteAdr_THX2T99Write_1Cyc_LS01_I012_ReadDefault

Error: IDENTICAL_BRANCHES (CWE-398):
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53966: implicit_else: The code from the above if-then branch is identical to the code after the if statement.
llvm-17.0.6.src/redhat-linux-build/lib/Target/AArch64/AArch64GenSubtargetInfo.inc:53964: identical_branches: The same code is executed when the condition "llvm::AArch64InstrInfo::isScaledAddr(MI)" is true or false, because the code in the if-then branch and after the if statement is identical. Should the if statement be removed?
#53962|       }
#53963|       if (SchedModel->getProcessorID() == 19) { // ThunderX3T110Model
#53964|->       if (AArch64InstrInfo::isScaledAddr(*MI))
#53965|           return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
#53966|         return 1720; // WriteAdr_THX3T110Write_1Cyc_LS01_I0123_ReadDefault
